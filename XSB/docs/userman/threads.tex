\chapter{Multi-Threaded Programming in XSB} \label{chap:threads}
\index{multi-threading|(}

id with Version 3.0, XSB supports the use of POSIX threads to
perform separable computations, and in certain cases to parallelize
them.  POSIX threads have a simple and clear API, and are available on
all Unixes and by using open-source libraries, on Windows as well (see
Section~\ref{sec:mt-windows} to configure under Windows).  This
chapter introduces how to program with threads in XSB through a series
of examplesi sections discuss performance aspects of our
implementation as well as describing relevant predicates.  A general
knowledge of multi-threaded programming is assumed, such as can be
found in \cite{LewB98,Bute97}.

\section{Getting Started with Multi-Threading}
%
In \version{} the default configuration of XSB does not include
multi-threading.  This is partly because multi-threading is new, and
despite our efforts, the multi-threaded engine may contain bugs not
present in the single-threaded engine.  However the main reason is
because in \version , not all libraries and packages have yet been
made thread-safe so that not all configurations are supported with
multi-threading.  Both the XSB-calling-C and the C-calling-XSB
interfaces are supported in the multi-threaded engine.  All XSB
libraries have been ported to the multi-threaded engine {\em except}
the profiling library and the {\tt string} library (which is not yet
thread-safe).  The packages {\tt ODBC} and {\tt CHR}, {\tt FLORA-2},
and {\tt regmatch} are supported by the multi-threaded engine, but the
packages {\tt dbdrivers}, {\tt xpath}, {\tt interprolog}, {\tt
  smodels}, {\tt perlmatch}, {\tt libwww} and {\tt posix} are not yet
fully supported.  We note, however that all basic/ISO Prolog
functionality is thread-safe (at least, as far as we know :-).

With this in mind, making the multi-threaded engine is simple:
configure and make XSB as in Chapter~\ref{chap:system}, but include
the command {\tt --enable-mt}.  When you invoke the newly made
configuration of XSB you should see {\tt engine: multi-threading} in
the configuration list below the banner rather than {\tt engine:
  slg-wam} as in the sequential engine.

\paragraph{Hello World for Beginners}
%
We naturally start with a program to print ``hello world''.  Within
the multi-threaded engine, import {\tt thread\_create/2} from the
module {\tt thread}, and type the command
\begin{center} 
{\tt ?- thread\_create(writeln('hello world'),Id)} 
\end{center} 
you should see something like 
\begin{center} 
{\tt Id = 1hello world} 
\end{center} 
%
while the output is a little ugly, the ``hello world'' program does
illustrate simple multi-threading at work.  The calling thread
(i.e. the thread controlling the command-line interpreter which we
call $T_{prompt}$) executes the predicate {\tt thread\_create/2} which
creates a thread $T_{child}$ and immediately returns with the {\em XSB
  thread id} of the created thread.  Meanwhile, $T_{child}$
initializes its stacks and other memory areas and executes the goal
{\tt writeln('hello world')}.  $T_{child}$ and $T_{prompt}$ share most
of their process-level information: in particular they share a common
I/O stream for standard output, leading to the output above.  What is
happening may be seen a little more easily by executing the command
%
\begin{center} 
{\tt ?- thread\_create((sleep(1),writeln('hello world')),Id)} 
\end{center} 
%
In this case the interpreter reports that {\tt F} is bound to a thread
id, then about a second later {\tt writeln/1} is executed.  

The simple ``hello world'' program illustrates a couple of points.
First, it is easy to create a thread in XSB and have that thread do
work.  Second, it can be tricky to coordinate actions among threads.
We'll explore these two themes in more detail, but first suppose we
are determined to extend out multi-threaded program so that it
produces good output.  One way to do this is to {\em join}
$T_{prompt}$ and $T_{child}$ as follows 
%
\begin{verbatim}
?- thread_create(writeln('hello world'),Id),
   thread_join(Id,ExitCode).
hello world

Id = 1
ExitCode = true
\end{verbatim}
%
In this case, as soon as $T_{prompt}$ has issued a command to create
$T_{child}$, it executes {\tt thread\_join/2}.  This latter predicate
makes a system call to the underlying operating system to suspend
$T_{prompt}$ until $T_{child}$ has exited.  {\tt thread\_join/2}
returns a status term indicating whether the goal to thread {\tt Id}
succeeded, failed, exited with an error term, or was cancelled (in
this case {\tt Id} succeeded).

\index{Prolog flags!{\tt max\_threads}}
So far, we've introduced a few concepts that have not been fully
discussed.  First is the concept of an {\em XSB thread id}: XSB
manages up to $M$ active threads using XSB thread ids.  The default
for $M$ in \version{} is 1024, but $M$ can be reset via the {\tt
  max\_threads} command line option to XSB
(cf. Section~\ref{sec:EmuOptions}).  Once XSB is initialized, the
maximum number of threads for an XSB session can be obtained at run
time via the Prolog flag {\tt max\_threads} (cf. Section~\ref{State}).
It should be noted that the XSB thread id of a thread is different
from the identifier of the underlying Pthread.  An XSB thread id is a
Prolog term, and unlike POSIX thread ids, XSB thread ids can be
compared for equality using unification.  The actual form of an XSB
thread id, however, is subject to change between versions, so programs
should not make use of the exact form of an XSB thread id.  In the
multi-threaded engine, the XSB thread id of any thread can be queried
using the predicate {\tt thread\_self/1}.

\section{Communication among Threads} \label{sec:shared}
%\index{tabling!thread\_private}
%\index{tabling!thread\_shared}

\begin{example}
Consider the program fragment
%
\begin{verbatim}
:- dynamic p/1.

test:- thread_create(assert(p(1)),_X).
\end{verbatim}
If you type the goal {\tt ?- test} and then the goal {\tt ?- p(X)},
the call {\tt p(X)} will fail.  
\end{example}

\noindent
This illustrates an important point about dynamic and tabled
predicates in the multi-threaded engine: by default clauses for a
dynamic predicate {\tt p/n} are private to the thread that asserts
them; and by default tables created in an evaluation of a goal for
{\tt p/n} are private to the thread that evaluates the goal.  This
behavior contrasts to that of static code which is always shared
between threads.  In the example above, to allow {\tt p(1)} to be
visible to various threads, {\tt p/1} must be declared to be shared
with the following declaration.
%
\begin{verbatim}
:- table p/1 as shared.
\end{verbatim}
or
\begin{verbatim}
:- dynamic p/1 as shared.
\end{verbatim}

%
Alternately, dynamic and tabled predicates can be made thread-shared
by default by invoking XSB with the command-line argument {\tt
  --shared\_predicates}, in which case a predicate may be declared
thread-private through the declaration
%
\begin{verbatim}
:- table p/1 as private.
\end{verbatim}
or 
\begin{verbatim}
:- dynamic p/1 as private.
\end{verbatim}

%
\index{shared\_predicates}

The ability to share dynamic code between predicates provides an
extremely powerful mechanism for threads to communicate.  So why does
XSB make dynamic predicates thread-private by default?  The main
reason for this is that if dozens or hundreds of threads are running
concurrently, shared dynamic code becomes an expensive synchronization
point.  Code for shared predicates must be more heavily mutexed than
code for private predicates.  In the case of dynamic code, XSB does
not always immediately reclaim the space of retracted clause, to avoid
the possibility of some computation backtracking into a clause that
has been reclaimed.  Rather, (like most Prologs), XSB may decide to
garbage collect the space of the retracted clauses at a later time.
While clause garbage collection is simple enough to implement for a
single thread, garbage collecting clauses for shared dynamic
predicates is difficult to do when multiple threads are active.
Accordingly, in \version , space for shared dynamic clauses is not
reclaimed until there is a single active thread.  However for {\em
  thread-private} dynamic predicates, there is no problem in
reclaiming space when multiple threads are active: from the engine's
perspective garbage collection is no different than in the sequential
case.  Thus one set of reasons for making dynamic predicates private
by default are based on efficiency~\footnote{Future versions may offer
  more powerful garbage collectors for shared predicates.}.

The second reason for making dynamic predicates thread-private by
default is semantic.  Suppose thread $T_1$ starts a tabled computation
that depends on the dynamic shared predicate {\tt p/1}.  While $T_1$
is computing the table, thread $T_2$ asserts a clause to {\tt p/1}.
$T_1$'s table is likely to be inconsistent, leading to the problem of
{\em read consistency} of any table that depends on thread-shared
dynamic predicates.  In \version , users are responsible for ensuring
read consistency of any tables that depend on shared dynamic data.
Future versions of XSB are intended to allow more sophisticated
mechanisms for read consistency.

Not only can tables depend on thread-shared or thread-private dynamic
data, but 
%in the default multi-threaded configuration of XSB, which uses local
%scheduling for tabled evaluation,
the tables themselves may be thread-shared or thread-private.  Like
dynamic code, the declaration {\tt table Predspec as shared} allows
sharing of tables for a predicate evaluated with call-variance to be
shared among threads~\footnote{In \version, tabled predicates using
  call-subsumption are always private; an attempt to make such a
  predicate thread-shared throws an exception.}.
%
To some extent, tabling considerations for making a predicate
thread-shared or thread-private are like those of dynamic code.
Thread-private tables require fewer synchronization points overall.
The situation for reclaiming space for abolished tables is analogous
to reclaiming space for retracted dynamic clauses: the garbage
collector treats abolished tables for thread-private predicates as in
the sequential case, while space for shared tables is not reclaimed
until there is a single active thread.  However the precise semantics
of how tabling information is shared depends on whether the
multi-threaded engine is configured with the default local evaluation
or with batched evaluation.  As discussed in
Chapter~\ref{chap:TablingOverview}, local evaluation is so-named
because computation always takes place in the SCC most recently
created, and no answer is returned outside of an SCC until the SCC has
been completely evaluated.  Within this scheduling strategy it is not
often useful to share answers between tables that have not been
completed -- as local evaluation would allow these answers to be
returned only if the tables were in the same SCC.  This leads to a
concurrency semantics called {\em Shared Completed
  Tables}~\cite{Marques07,MarS08,MarS10}.  Shared Completed Tables can
in fact be supported by a relatively simple algorithm for optimistic
concurrency control.  If goals to two mutually dependent tables
$Table_a$ and $Table_b$ are called concurrently by two different
threads, $Thread_a$ and $Thread_b$, nothing is done until it is
detected that $Table_a$ and $Table_b$ are both incomplete and are
contained in the same SCC of the table dependency graph.  At that
time, one of the threads (e.g. $Thread_a$) takes over recomputation of
all tables in the SCC, and when the SCC is completed, any remaining
answers are returned to other threads that had invoked goals in the
SCC.  While $Thread_a$ is completing this computation, $Thread_b$
suspends until the SCC is complete.  Thus the semantics of Shared
Completed Tables supports concurrency for the well-founded semantics,
but only supports the most coarse-grained parallelism.

Batched evaluation, on the other hand, allows answers to be returned
outside of an SCC before that SCC has been completed.  Concurrency
control for batched evaluation is similar to that for local
evaluation, except in the following case.  Assume as before that
$Table_a$, first called by $Thread_a$, and $Table_b$ first called by
$Thread_b$ are determined to be in the same SCC, and that $Thread_a$
takes over computation of subgoals in the SCC.  Now, $Thread_b$,
rather than suspending, may continue work.  In particular, $Thread_b$
can return any answers in $Table_b$ that it finds whenever it finds
them, regardless of whether they have been produced by $Thread_b$
(before $Thread_a$ took over the SCC) or by $Thread_a$ (afterwards).
We call this type of concurrency semantics, {\em Table Parallelism}.
Table Parallelism can be used to program producer-consumer examples,
as well as to implement Or- and And- parallelism.  Table Parallelism
was first introduced in~\cite{FHSW95}, but the mechanism now used for
implementing Table Parallelism differs significantly from what was
described there.  In \version{} of XSB, the implementation of Table
Parallelism is experimental: in particular, it does not yet support
tabled negation.

As mentioned, for either semantics of shared tables, in \version{},
users of thread-shared tables are responsible for ensuring read
consistency.  Note that, in principle, thread-shared tables may depend
on thread-private tables and vice-versa.  Either type of table may
depend on thread-private or thread-shared dynamic code.  In addition,
a predicate may be {\em both} dynamic and tabled, and its clauses and
tables may be either thread-private or thread-shared.

\section{Thread Statuses: Joinable and Detached Threads} \label{sec:thread-status}

So far we have assumed that the goal called in {\tt thread\_create/2}
terminates normally --- by success or failure.  But what if a thread
throws an error while executing a goal?  How long should error
information for a thread persist, and how can it be checked?

\index{thread!valid}

Our approach relies on the semantics of Pthreads, which can be either
{\em joinable} or {\em detached}.  Within this framework, we consider
a thread to be {\em valid} if it has not yet terminated, or if it is
joinable and has not yet been joined.  After a joinable Pthread
$T_{dead}$ has terminated, status information about $T_{dead}$
persists until some other thread joins it --- at which time the
information is removed.  On the other hand, if $T_{dead}$ is detached,
status information is removed as soon as $T_{dead}$ terminates.
Reclamation of thread status information may be contrasted to that of
thread-specific data structures such as stacks.  Upon normal or
exceptional termination of $T_{dead}$, any memory automatically
allocated in the process of initializing $T_{dead}$'s, or executing
its goal -- including stacks, private dynamic code, private tables is
reclaimed.  In addition, any mutexes held by $T_{dead}$, are released.
On the other hand, XSB-specific {\em status} information about threads
follows the Pthread model: by default, error information is available
when joining a joinable thread, but not otherwise~\footnote{This
  behavior can, of course, be overridden by embedding goals within
  {\tt catch/3} and handling errors separately, or simply by adding a
  default user error handler: see Chapter~\ref{chap:exception} for
  details.}.

\begin{example}
Suppose the goal 
\begin{verbatim}
 ?- thread_create(functor(X,Y,Z),F).
\end{verbatim}
%
is executed.  By default, this will produce the result
%
\begin{verbatim}
X = _h113
Y = _h127
Z = _h141
F = 1++Error[XSB/Runtime/P]: [Instantiation]  in arg 2 of predicate functor/3
\end{verbatim}
%
In fact, the variable bindings are output to {\tt STDOUT}, while the
error message
%
\begin{verbatim}
++Error[XSB/Runtime/P]: [Instantiation]  in arg 2 of predicate functor/3
\end{verbatim}
%
is output to {\tt STDERR}, and may be redirected.  The call
%
\begin{verbatim}
?- thread_join(2,Error).
\end{verbatim}
%
returns
%
\begin{verbatim}

Error = exception(error(instantiation_error, in arg 2 of predicate functor/3,
              [[Forward Continuation...,... standard:call/1,... standard:catch/3],
                Backward Continuation...]))
\end{verbatim}
%
In other words, {\tt Error} is instantiated to a {\tt exception/1}
structure, containing a standard XSB error term (including backtrace).
\end{example}
%
The error term in the above example is one example of a {\em thread
  status} term.  In XSB, these thread statuses are as follows.
\index{thread!thread status}
\label{page:thread-status} 
%
\bi
\item {\tt running} The thread is still executing
%
\item {\tt true} The thread has exited and successfully evaluated its goal.
%
\item {\tt false} The thread has exited and failed its goal.
%
\item {\tt exception(Exception)} The thread has been terminated due to
  an uncaught exception, represented by the term {\tt Exception} which
  is a standard XSB error term.
%
\item {\tt cancelled(Exception)} The thread has been terminated due to
  a thread cancellation, represented by the term {\tt Exception} which
  is a standard XSB error term.
%
\item {\tt exited(ExitTerm)} The thread has been terminated using the
  predicate {\tt thread exit/1} with {\tt ExitTerm} as its argument.
\ei 
%
Any of these statuses except {\tt running} may be returned by {\tt
  thread\_join/2}.  In Prolog, the statuses of exited threads 
provide much more information than C exit codes.  

\comment{but C exit codes may conceivably be useful if XSB is called
  by one of the interfaces for C calling XSB.  By default when no call
  to {\tt thread\_exit/1} has been made, an XSB thread that terminates
  normally will have an exit code of {\tt XSB\_SUCCESS} ({\tt 0}), a
  cancelled thread will have an exit code of {\tt 1} and a thread
  terminated with any other error will have an exit code of~{\tt
    XSB\_ERROR} ({\tt 2}).  }
%
As with pthreads, XSB threads are created as joinable by default, but
can be created as detached using an option in {\tt thread\_create/3}.
Alternatively, a thread created as joinable can be made detached by
{\tt thread\_detach/1}.  All of the predicates mentioned in this
section are fully described in Section~\ref{sec:mt-threading}.

\section{Prolog Message Queues}
%
\index{message queues}
While Prolog predicates can communicate through shared dynamic code
and tables, message queues provide a useful mechanism for one thread
to pass a command to another or to synchronize on the return of data.
A Prolog message queue contains an arbitrary Prolog Term, and
unification may be used to obtain a term from a queue.  More
specifically, when a producer writes $Term$ into a queue, the term is
copied into the queue so that no binding are shared between $Term$ and
the producer's stacks.  $Term$ may include structures or lists and
need not be bound, and any variable bindings within $Term$ are
preserved.  When a consumer $T_{cons}$ accesses the queue it provides
a goal $G$ and traverses the queue until it finds a term in the queue
that unifies with $G$.  If $T_{cons}$ finds a term in the queue that
unifies with $G$, it removes it from the queue and continues in its
computation.  If there is no term in the queue that unifies with $G$,
$T_{cons}$ will suspend until at least one other term is added to the
queue.  When it awakens it will retraverse the queue from the
beginning to find a term that unifies with $G$~\footnote{Note that
  this traversal is necessary since the position of $T_{cons}$ may in
  the queue may not be valid due to the addition and deletion of terms
  by other threads.}.  Because of the behavior of message queues, it
is usually good programming practice to ensure that terms written into
the queue will unify with the goals of consumers.  This can usually be
done by abstracting a consumers goal (say to a variable, {\tt X}) or
by splitting one ``multiplexed'' queue into two separate queues.

A Prolog message queue can be {\em public} or {\em private}: a public
message queue can have any number of readers and writers.  In
addition, each thread $T$ also has a private message queue $Q_{T}$:
any thread can write to $Q_{T}$ but only $T$ can read from it.  The
following example illustrates how to use private message queues:
%
\begin{verbatim}
test_private:- 
     thread_id(Tid),
     thread_create(child(Tid),Id),
     thread_get_message('Mom Im home'(ChildId)),
     thread_send_message(ChildId,'Im in the kitchen'),
     thread_join(Id,_).

child(Parent):- 
     thread_self(Id),
     thread_send_message(Parent,'Mom, Im home'(Id)),
     thread_get_message('Im in the kitchen').
\end{verbatim}
%
If {\tt ?- test} is called by $T_{parent}$, it will obtain its own
thread id, create a new thread $T_{child}$ to execute {\tt child/1},
wait for a message that $T_{child}$ is operational using {\tt
  thread\_get\_message/1}, send a message to $T_{child}$ using {\tt
  thread\_send\_message/2} and then wait for $T_{child}$ to terminate.
  When it is created, $T_{child}$ immediately sends a message to its
  parent, waits for a message back from its parent, and terminates.
%

It is illustrative to compare 
\begin{verbatim}
test_public:- 
     message_queue_create(Qid)
     thread_create(child(Qid),Id),
     thread_get_message(Qid,'Mom Im home'(ChildQ)),
     thread_send_message(ChildQ,'Im in the kitchen'),
     thread_join(Id,_),
     message_queue_destroy(Qid).

child(ParentQ):- 
     message_queue_create(Qid),
     thread_send_message(ParentQ,'Mom, Im home'(Qid)),
     thread_get_message(Qid,'Im in the kitchen'),
     message_queue_destroy(Qid).
\end{verbatim}
%
{\tt test\_public} is essentially the same program as {\tt
  test\_private}, but uses public message queues, rather than private
queues.  The public queues must be explicitly created and destroyed,
and they are referred to via a queue id (or alias) rather than via a
thread id (or alias).  Like thread ids, queue ids in XSB are integers,
but a user should not depend on their precise form: aliases should be
used if a user wants control of queue or thread identifiers.

Thus, apart from who can read from them, private and public message
queues have essentially the same behavior.  In addition, any queue can
be created with a bound, $size$ on the number of messages (terms) it
contains.  If $size$ is 0, the queue is taken to be unbounded.  If a
bounded queue already contains $size$ elements, the producer will
suspend until one or more elements are removed from the queue.  For
public queues, a size argument can be passed using the predicate {\tt
  message\_queue\_create/2} (See Section~\ref{sec:mt-threading}).  For
private queues, and for public queues created with {\tt
  message\_queue\_create/1}, the value for $size$ is taken from the
settable Prolog flag {\tt max\_queue\_terms}.  The default value for {\tt
  max\_queue\_terms} is currently 100.

\section{Thread Cancellation and Signalling} \label{sec:thread-signals}
%
There may be a number of situations in which it is useful to give one
thread the ability to cancel the execution of another thread.  Within
the semantics of pthreads, this is called {\em thread cancellation}.
At the C level, thread cancellation can be tricky, as mutexes must be
released, allocated memory freed, and so on.  Accordingly, the
predicate {\tt thread\_cancel/1} cancels XSB threads by acting purely
within the SLG-WAM engine.  When thread $T_1$ interrupts thread $T_2$,
$T_1$ writes to the thread-specific XSB interrupt vector in $T_2$.
Later, when $T_2$ checks its interrupt vector, it throws a
cancellation error, which causes it to clean up its mutexes, memory,
private tables and dynamic code, and then exit.

Thread cancellation is just a special case of Prolog thread
signalling, in which one thread can signl another thread to interrupt
what it is doing and execute a goal~\footnote{Prolog thread signalling
  should be distinguished from signalling at the OS level where
  functions such as {\tt pthread\_kill()} or {\tt kill()} are used.}.  The
following code provides an example of thread signalling.
%
\begin{verbatim}
test_signal:- 
     thread_self(Tid),
     thread_create(child(Tid),T1,[]),
     thread_get_message('Im alive'),
     thread_signal(T1,writeln('Excuse me, but did you just kick me?')),
     thread_join(T1,_Ball),
     writeln(test5_ok).

child(Tid):- 
     thread_send_message(Tid,'Im alive'),
     loop.

loop:- loop.
\end{verbatim}
%
{\tt test\_signal} begins like {\tt test\_private}, but rather than
waiting for a signal from its parent, the child goes into an infinite
loop.  The signal interrupts the child, which writes out a message and
returns to the infinite loop.

Thread signals may be any callable Prolog term.  As with private
message queues, each thread is created with its own private signal
queue (there are no public signal queues).  In XSB, threads handle
Prolog signal interrupts (including cancellation messages) at the same
time as attributed variable interruptions.  This means that Prolog
signal interrupts will be handled very quickly if SLG-WAM code is
being executed.  On the other hand, if a thread executing a built-in
to, e.g. waiting on a mutex, the thread may be immediately awakened to
process the signal, but not always: if a thread is waiting for input
on a stream or socket, the thread may not handle the signal interrupt
until the input is received.  Furthermore, in a very few critical
sections of code, thread signal handling may be distabled.  However,
the thread is guarenteed to handle the signal interrupt or
cancellation message very shortly after it finishes the built-in.

So, while thread cancellation and signalling is useful, it must be
used with a certain amount of care.  Any thread can signal any other
thread, and any thread can cancel any other thread, with the exception
that the {\em main} thread, which controls the console (or interface
to C or interprolog) cannot be cancelled.  The main thread always has
XSB thread id {\tt 0} in both the single-threaded and multi-threaded
systems, and has the thread alias {\tt main}.

\section{Performance and other Considerations}
%
For running programs that do not use multiple threads, the
multi-threaded engine has a minimal overhead compared to the
single-threaded engine.  Times for single-threaded execution of Prolog
or tabled programs range from about 10--20\% slower to 10--20\% {\em
  faster} for the multi-threaded engine compared to the
single-threaded engine.  Speedups for running multiple threads on
multiple processors depends heavily on the applications run and on the
underlying operating system.

The size of a given thread may be a consideration for multi-threaded
applications, especially on a 32-bit platform (the multi-threaded
engine has been tested on both 32-bit and 64-bit platforms).  Each
thread has an area of thread-private variables that are ``global'' to
its own virtual machine.  This area, called the {\em thread context},
which accounts for about 4 Kbytes of space.  Much larger are the
various stacks used by the threads for tabled and Prolog execution.
Almost all of XSB's memory areas are fully expandable, and the initial
size of the execution stacks may be set explicitly as options in {\tt
  thread\_create/3}.  Explicitly setting a default thread stack size
for an XSB thread to be smaller than the default process stack size
may be useful for applications that have a large number of
concurrently running threads.

Other performance considerations involve the contention by threads for
shared resources.  As discussed above, contention may arise when
creating or abolishing tables, or when asserting or retracting dynamic
code --- however in either case thread-private predicates give rise to
less contention than thread-shared predicates.  In terms of I/O, each
XSB stream up to the maximum number of file descriptors has its own
mutex; as a result threads writing to different streams will not
contend for I/O.  Thus, in multi-threaded applications, it may be more
efficient to open and close streams and access these streams
explicitly, than to redirect standard input or standard output through
{\tt see/1} and {\tt tell/1}.

\section{Examples of Multi-Threaded Programs in XSB} 
%
Figure~\ref{fig:ex-server} shows an example of a multi-threaded goal
server in XSB, which makes use of XSB's socket library (see Volume 2
of this manual)~\footnote{Material in this section is based on
  \cite{Marques07}.}.  The server listens for requests from clients
using {\tt socket\_accept/2} and spawns a thread to handle each
request via the goal {\tt accept\_client/2} which actually calls the
goals.  The goals executed by the server could be tabled and take
advantage of the shared table implementation, shared dynamic code, or
any other mechanism in XSB.  Halting of the server is done by the
thread cancellation mechanism, and a shared dynamic predicate is used
to make the server's thread identifier known to the other
threads. Note that this is the reason a specific thread was created to
execute {\tt server\_loop}, as the main thread cannot be canceled.

\begin{figure}
\begin{center}
\begin{tt}
\begin{tabbing}
fooo\=foo\=foo\=foo\=fooooooooooooooooooooooooooooooo\=ooooooooooooo\=\kill
\> :- dynamic server\_id/1 as shared. \\
\\
\> server :-\\
\> \> socket($SockFD$),\\
\> \> socket\_set\_option( $SockFD$, linger, SOCK\_NOLINGER ),\\
\> \> xsb\_port($XSBport$),\\
\> \> socket\_bind($SockFD$, $XSBport$),\\
\> \> socket\_listen($SockFD$,Q\_LENGTH),\\
\> \> thread\_create( server\_loop($SockFD$), Id, [] ),\\
\> \> assert( server\_id($Iden$) ),\\
\> \> thread\_join( $Iden$ ).\\
\\
\> server\_loop($SockFD$) :-\\
\> \> socket\_accept($SockFD$, $SockClient$),\\
\> \> thread\_create( attend\_client($SockClient$) ),\\
\> \> server\_loop($SockFD$).\\
\\
\> attend\_client($SockClient$) :-\\
\> \> socket\_recv\_term($SockClient$, $Goal$),\\
\> \> ( \> Goal == stop \verb|->| \\
\> \> \> retract(server\_id( $Server$ )),\\
\> \> \> thread\_cancel( $Server$ ),\\
\> \> \> socket\_close( $SockClient$ ),\\
\> \> \> thread\_exit\\
\> \> ; \> true\\
\> \> ),\\
\> \> ( \> is\_valid($Goal$) \verb|->|\\
\> \> \> call($Goal$), \\
\> \> \> socket\_send\_term($SockClient$, $Goal$),\\
\> \> \> fail,\\
\> \> ;	\> socket\_send\_term($SockClient$, invalid\_goal($Goal$))\\
\> \> ),\\
\> \> socket\_send\_term($SockClient$, end),\\
\> \> socket\_close($SockClient$).
\end{tabbing}
\end{tt}
\end{center}
\caption{A multi-threaded goal server in XSB}
\label{fig:ex-server}
\end{figure}

Figure~\ref{fig:ex-primes}!la
 uses a multi-threaded execution model to
compute a series of prime numbers in parallel~\footnote{This example
  was inspired by a similar example for multi-threaded computation of
  primes in from Logtalk~\cite{log-man}}, The master thread partitions
the work and creates two worker threads.  The worker threads each
compute its portion of the interval and return their results to the
master through a message queue.

Notice how the \texttt{primes/2} predicate uses difference lists to
avoid the use of the append predicate\footnote{For a description on
  how to program with difference lists see a Prolog programming text,
  such as\cite{StSh86}).}, and while threads don't share variables,
the bindings of the terms in the messages are correctly handled,
allowing Prolog's unification to assume its full power.  Although only
two threads are used, the program could easily be extended to use an
arbitrary number of threads

\begin{figure}
\begin{center}
\begin{tt}
\begin{tabbing}
fooo\=foo\=foo\=foo\=fooooooooooooooooooooooooooooooo\=ooooooooooooo\=\kill
prime($P$, $I$) :- $I$ < sqrt($P$),!.\\
prime($P$, $I$) :- $Rem$ is $P$ mod $I$, $Rem = 0$, !, fail.\\
prime($P$, $I$) :- $I_1$ is $I - 1$, prime($P$, $I_1$).\\
\\
prime($P$) :- $I$ is $P - 1$, prime($P$, $I$ ).\\
\\
list\_of\_primes($I$, $F$, $Tail$, $Tail$) :- $I > F$, !.\\
list\_of\_primes($I$, $F$, [$I$|$List$], $Tail$) :-\\
\>        prime($I$), !,\\
\>        $I_1$ is $I + 1$, list\_of\_primes($I_1$, $F$, $List$, $Tail$).\\
list\_of\_primes($I$, $F$, $List$, $Tail$) :-\\
\>        $I_1$ is $I + 1$, list\_of\_primes($I_1$, $F$, $List$, $Tail$).\\
\\
partition\_space($N$, $H$, $H_1$) :-\\
\>        $H$ is $N//2$, $H_1$ is $H + 1$.\\
\\
worker( $Q$, $Iden$, $I$, $F$, $List$, $Tail$) :-\\
\>        list\_of\_primes( $I$, $F$, $List$, $Tail$),\\
\>        thread\_send\_message( $Q$, primes($Iden$,$List$,$Tail$) ).\\
\\
master( $N$, $L$ )  :-\\
\>        partition\_space( $N$, $H$, $H_1$),\\
\\
\>       message\_queue\_create($Q$),\\
\>        thread\_create( worker($Q$, p1, 1,  $H$, $L$,  $L_1$) ),\\
\>        thread\_create( worker($Q$, p2, $H_1$, $N$, $L_1$, []) ),\\
\\
\>        thread\_get\_message( $Q$, primes(p1,$L$,$L_1$) ),\\
\>        thread\_get\_message( $Q$, primes(p2,$L_1$,[]) ).
\end{tabbing}
\end{tt}
\end{center}
\caption{A multi-threaded program to calculate prime numbers in XSB}
\label{fig:ex-primes}
\end{figure}


\section{Configuring the Multi-threaded Engine under Windows} \label{sec:mt-windows}

Libraries for pthreads are included on most versions of Unix and
Linux.  Windows also supports multi-threading, but with a somewhat
different semantics and API than that of pthreads.  To run
multi-threaded XSB under Windows, a library must be included to
translate the Pthread library, used by XSB, to the native thread API
of Windows.

Different libraries are available for this purpose.  Internally, the
multi-threaded engine has been tested using the Win32 pthreads
interface, available via {\tt http://sourceware.org/pthreads-win32},
but other libraries may also work, including Pthread library included
with Cygwin.  To install the sourceware library, let {\tt \$XSBENV} be
the parent directory of {\tt \$XSBDIR} the root directory of XSB --
i.e. {\tt \$XSBENV} is the directory into which XSB is installed.

\begin{itemize}
\item Download a version such as pthreads-2005-01-25.exe or later, and
  extract it into {\tt \$XSBENV}\\pthreads.  Add
  \verb|$XSBENV\pthreads\Pre-built\lib| to your system path

\item To configure with windows enter the commands: 
\begin{verbatim}
sh configure --enable-mt --with-wind \
--with-includes='c:\XSBSYS\XSBENV\pthreads\Pre-built\include \
--with-static-libraries='c:\XSBSYS\XSBENV\pthreads\Pre-built\lib

makexsb_wind
\end{verbatim}
Note that the Unix {\tt sh} shell must be available in order to
reconfigure.

\item To configure with cygwin enter the commands:
\begin{verbatim}
sh configure --enable-mt \
  --with-includes='/cygdrive/c/XSBSYS/XSBENV/pthreads/Pre-built/include' \
  --with-static-libraries='/cygdrive/c/XSBSYS/XSBENV/pthreads/Pre-built/lib'

sh makexsb --config-tag=mt
\end{verbatim}

\end{itemize}

\section{Predicates for Multi-Threading} \label{sec:mt-threading}

The predicates described in this section do not address tabling or
dynamic code.  With only a few minor deviations the provisional
working standard described in \cite{Prolog-MT-ISO} is supported.  As a
result, these predicates are substantially the same as those in SWI,
YAP, and other Prologs.  In the single-threaded engine, semantically
correct calls to these predicates will give a miscellaneous error.

\begin{description}

\index{aliases!threads}
\standarditem{thread\_create(+Goal,ThreadId,+OptionsList)}{thread\_create/3}
%
When called from thread $T$, this predicate creates a new XSB thread
$T_{new}$ to execute {\tt Goal}.  When goal either succeeds, throws an
unhandled error, exits, or fails, $T_{new}$ exits, but {\tt
  thread\_create/2} will succeed immediately, binding {\tt ThreadId}
to the XSB thread id of $T_{new}$.  {\tt Goal} must be callable, but
need not be fully instantiated.  No bindings from {\tt Goal} are
passed back from $T$ to $T_{new}$, so communication between $T_{new}$
and $T$ must be through tables, asserted code, message queues or other
side effects.

{\tt OptionList} allows optional parameters in the configuration for
the initial size of XSB stacks, for aliases, and to indicate whether
$T_{new}$ is to be created as detached.  Note that XSB threads allow
automatic stack allocation, so that the size options may be most
useful for (32-bit) applications with very large numbers of threads.
In this case, setting initial stack sizes to be small may allow more
threads to be created on a given hardware platform.  Also note that
only XSB stacks are affected, the stack size of the underlying Pthread
remains unaltered.
%
\index{Prolog flags!{\tt thread\_glsize}}
\index{Prolog flags!{\tt thread\_tcpsize}}
\index{Prolog flags!{\tt thread\_complsize}}
\index{Prolog flags!{\tt thread\_pdlsize}}
\bi

\item {\tt glsize(N)}: create thread with global (heap) plus local
  stack size initially set to {\tt N} kbytes.  If not specified, the
  default size is used.  The default size can be set at the command
  line (cf. Section~\ref{sec:EmuOptions}), and altered at run time by
  the Prolog flag {\tt thread\_glsize} (cf. Section~\ref{State}).
%
\item {\tt tcpsize(N)}: create thread with trail plus choice point
  stack size initially set to {\tt N} kbytes.  If not specified, the
  default size is used (cf. Section~\ref{sec:EmuOptions}).  The
  default size can be set at the command line
  (cf. Section~\ref{sec:EmuOptions}), and altered at run time by the
  Prolog flag {\tt thread\_tcpsize} (cf. Section~\ref{State}).
%
\item {\tt complsize(N)}: create thread with completion stack size
  initially set to {\tt N} kbytes. If not specified, the default size
  is used (cf. Section~\ref{sec:EmuOptions}).  The default size can be
  set at the command line (cf. Section~\ref{sec:EmuOptions}), and
  altered at run time by the Prolog flag {\tt thread\_complsize}
  (cf. Section~\ref{State}).
%
\item {\tt pdlsize(N)}: create thread with {\tt N} kbytes of
  unification stack.  If not specified, the default size is used
  (cf. Section~\ref{sec:EmuOptions}).  The default size can be set at
  the command line (cf. Section~\ref{sec:EmuOptions}), and altered at
  run time by the Prolog flag {\tt thread\_pdlsize}
  (cf. Section~\ref{State}).
%
\index{Prolog flags!{\tt thread\_detached}}
\item {\tt detached(Boolean)}: if {\tt Boolean} is true, creates
  detached thread.  If {\tt Boolean} is false, the thread created will
  be joinable, while if no option is given the default will be used.
  In \version{} threads are created joinable by default, but this
  default can be altered at run time by the Prolog flag {\tt
    thread\_default} (cf. Section~\ref{State}).
%
\item {\tt on\_exit(Handler)}: Ensures that {\tt Handler} is called
  whenever the thread exits: whether that exit arises from success of
  {\tt Goal}, failure, throwing an error that is unhandled in the
  user's program, or an explicit call to {\tt thread\_exit/1}.
%
\item {\tt alias(Alias)}: Allow thread {\tt ThreadId} to be referred
  to via {\tt Alias} in all standard thread predicates.  {\tt Alias}
  remains active for {\tt ThreadId} until it is joined.  Note that the
  main XSB thread has alias {\tt main}.
\end{itemize}

Finally, each thread is created with a signal queue and a private
message queue, so these queues do not need to be explicitly created.
Their size is obtained through the settable Prolog flag {\tt
  max\_queue\_terms}.

{\bf Error Cases}
\bi
\item 	{\tt Goal} is a variable
\bi
\item 	{\tt instantiation\_error}.
\ei
\item 	{\tt Goal} is not callable
\bi
\item 	{\tt type\_error(callable,Goal)}.
\ei
\item 	{\tt ThreadId} is not a variable
\bi
\item 	{\tt type\_error(variable,ThreadId)}
\ei
\item 	{\tt OptionList} is a partial list or contains an option that is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
\item 	{\tt OptionList} is neither a list nor a partial list
\bi
\item 	{\tt type\_error(list,OptionsList)}
\ei
\item 	{\tt OptionList} contains an option, {\tt Option} not described above
\bi
\item 	{\tt domain\_error(thread\_option,Option)}
\ei
\item An element of {\tt OptionsList} is alias(A) and A is already
  associated with an existing thread, queue, mutex or stream 
\bi
\item {\tt permission\_error(create,alias, A)}
\ei
\item An element of {\tt OptionsList} is alias(A) and A is not an atom
\bi
\item {\tt type\_error(atom,A)}
\ei
\item An element of {\tt OptionsList} is {\tt on\_exit(Handler)} and
      {\tt Handler} is not callable 
\bi
\item 	{\tt type\_error(callable,Handler)}.
\ei
\item   No more system threads are available (EAGAIN)
\bi
\item {\tt resource\_error(system threads)}
\ei
\ei

\standarditem{thread\_create(+Goal,-ThreadId)}
{thread\_create/2}
%
Acts as {\tt thread\_create(Goal,ThreadId,[])}.

\standarditem{thread\_create(+Goal)}
{thread\_create/1}
%
Acts as {\tt thread\_create(Goal,\_,[detached(true)])}.

\standarditem{thread\_join(+Threads\_or\_aliases,-ExitDesignators)}
{thread\_join/2}
% 
When {\tt thread\_join/2} is called by thread $T$, {\tt
  Threads\_or\_aliases} must be instantiated to either 1) an XSB
thread id or alias; or 2) a list where each element is an XSB thread
id or an alias; {\tt ExitDesignators} must be uninstantiated.  The
action of the predicate is to suspend $T$ until all of the threads
denoted by {\tt Threads\_or\_aliases} have exited.  At this time, any
remaining resources for the threads in {\tt ThreadIds} will have been
reclaimed.  Upon success {\tt ExitDesignators} is either a the thread
status of the associated thread (see page~\pageref{page:thread-status}) 
or a list of such elements.  

{\bf Error Cases}
\bi
\item 	{\tt Thread\_or\_Aliases} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Threads\_or\_aliases} is not a list of XSB thread ids or aliases
\bi
\item 	{\tt domain\_error(listof(thread\_or\_alias),ThreadIds)}
\ei
%
\item 	{\tt ExitDesignators} is not a variable
\bi
\item 	{\tt type\_error(variable,ExitDesignatorst)}
\ei
%
\item   {\tt ThreadId} does not correspond to a valid thread
\bi
\item   {\tt existence\_error(valid\_thread,ThreadId)}
\ei
\item   {\tt ThreadId} does not correspond to a joinable thread
  (i.e. {\tt ThreadId} is detached).
\bi
\item   {\tt permission\_error(join,non\_joinable\_thread,ThreadId)}
\ei
\ei

\comment{
a) Thread is a variable  instantiation_error
}

\standarditem{thread\_exit(+ExitTerm)}
{thread\_exit/1}
%
Exits a thread $T$ with {\tt ExitTerm} after releasing any mutexes
held by $T$, freeing any thread-specific memory allocated for $T$ (we
hope), as well as calling any exit handlers for $T$.  {\tt ExitTerm}
will be used if the caller of $T$ joins to $T$, but will be ignored in
other cases.  There is no need to call this routine on normal
termination of a thread as it is called implicitly on success or
(final) failure of a thread's goal.

{\bf Error Cases}
\bi
\item 	{\tt ExitCode} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
\ei

\standarditem{thread\_self(?ThreadId\_or\_Alias)}
{thread\_self/1}
%
If {\tt ThreadId} is an atom, unifies {\tt ThreadId\_or\_Alias} with
an alias of the calling thread.  Otherwise, unifies {\tt
  ThreadId\_or\_Alias} with the XSB thread id of the calling thread.
There are no error conditions.

%-------------------------------------------------------------------

\standarditem{thread\_detach(+Thread\_or\_Alias)}
{thread\_detach/1}
%
Detaches a joinable thread denoted by {\tt Thread\_or\_Alias} so that
all resources will be reclaimed upon its exit.  The thread denoted by
{\tt ThreadId} will no longer be joinable, once it is detached.  If
{\tt Thread\_or\_Alias} has already exited, all resources used by {\tt
  Thread\_or\_Alias} are removed from the system.

%Note, if it is known at thread creation time that a thread should be
%detached, it is better practice to create the thread as detached via {\tt
%  thread\_create/3}.

{\bf Error Cases}
\bi
%
\item 	{\tt Thread\_or\_Alias} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Thread\_or\_Alias} is not a thread id or alias
\bi
\item 	{\tt domain\_error(thread\_or\_alias,Thread\_or\_Alias)}
\ei
%
\item   {\tt Thread\_or\_Alias} does not correspond to a valid thread
\bi
\item   {\tt existence\_error(valid\_thread,Thread\_or\_alias)}
\ei
%
\item 	{\tt Thread\_or\_Alias} is active but not joinable
\bi
\item 	{\tt permission\_error(thread\_detach,thread,Thread\_or\_Alias)}
\ei
\ei

\standarditem{thread\_cancel(+Thread\_or\_Alias)}
{thread\_cancel/1}
%
Cancels the XSB thread denoted by {\tt Thread\_or\_Alias}.  The cancellation
does not use Pthread cancellation mechanisms, rather it uses XSB's
interrupt mechanism to set {\tt Thread\_or\_Alias}'s interrupt
vector~\footnote{This interrupt vector is checked upon every it is
  checked on every SLG-WAM {\sf call} and {\sf execute} instruction.}.
When this interrupt vector is checked, {\tt Thread\_or\_Alias} will throw a
thread cancellation error, which can be caught within {\tt Thread\_or\_Alias}
like any other error.  However, the default behavior is for {\tt
  Thread\_or\_Alias} to exit with an exit ball indicating that it has been
cancelled.  

As noted above, an executing thread that is cancelled will exit very
shortly after the {\tt thread\_cancel/1} predicate is called.  Blocked
threads, however, are not always guarenteed to exit when cancelled.
Currently a blocked thread may be cancelled
%
\begin{itemize}
%
\item when it is waiting to read or write a message on a queue
%
\item when it is executing {\tt thread\_sleep/1}
%
\end{itemize}
%
On the other hand, a blocked thread may not be cancelled while it is
waiting to read from a stream or waiting for a mutex.

During critical operations a thread may want to prevent itself from
being cancelled.  This can be done by If {\tt ?- thread\_cancel(T)} is
called for a thread {\tt T} for which cancelling has been disabled,
{\tt T} will be cancelled immediately after {\tt T} re-enables
cancellation through calling the predicate {\tt
  thread\_enable\_cancel/0}.

The main XSB thread cannot be cancelled; apart from that any thread
can cancel any other thread.

{\bf Error Cases}
\bi
\item 	{\tt Thread\_or\_Alias} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Thread\_or\_Alias} is not a thread id or alias
\bi
\item 	{\tt domain\_error(thread\_or\_alias,Thread\_or\_Alias)}
\ei
%
\item   {\tt Thread\_or\_Alias} does not correspond to valid thread
\bi
\item   {\tt existence\_error(valid\_thread,Thread\_or\_Alias)}
\ei
\item   {\tt Thread\_or\_Alias} denotes the main thread.
\bi
\item   {\tt permission\_error(cancel,main\_thread,Thread\_or\_Alias)}
\ei
\ei

\standarditem{thread\_signal(Thread\_or\_Alias,Goal)}
{thread\_signal/2}
% 
{\tt thread\_signal(ThreadOrAlias, Goal)} interrupts thread {\tt
  ThreadOrAlias} so that it executes {\tt Goal} at the first
opportunity.  Specifically, once {\tt Goal} is placed onto the signal
queue of {\tt ThreadOrAlias} and the interrupt vector of {\tt
  ThreadOrAlias} is adjusted, {\tt thread\_signal/2} succeeds.  {\tt
  ThreadOrAlias} handles the interrupt asynchronously, and if the
interrupt is handled while {\tt ThreadOrAlias} is executing a goal
with continuation $C$, all solutions for {\tt Goal} will be obtained,
and the failure continuation of {\tt Goal} will be $C$.  If {\tt Goal}
throws an exception $E$, the continuation will be the handler for $E$.

For blocked threads, signalling works much like cancellation
(described above), and a blocked thread will handle a signal whenever
it can be cancelled.  However, the thread does not return to the
blocking operation {\em after} the signal -- rather it will execute
the signal and then execute the continuation to be taken after the
blocking operation.

{\bf Error Cases}
\bi
\item 	{\tt Thread\_or\_Alias} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Thread\_or\_Alias} is not a thread id or alias
\bi
\item 	{\tt domain\_error(thread\_or\_alias,Thread\_or\_Alias)}
\ei
%
\item   {\tt Thread\_or\_Alias} does not correspond to valid thread
\bi
\item   {\tt existence\_error(valid\_thread,Thread\_or\_Alias)}
\ei
\item   {\tt Goal} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
\item   {\tt Goal} is not callable
\bi
\item 	{\tt type\_error(callable,Goal)}
\ei
\ei

\ourmoditem{thread\_disable\_cancel}{thread\_disable\_cancel/0}{thread}
% 
Disables the calling thread from being cancelled, so that it can be
ensured that critical operations can run to completion.  This
predicate always succeeds.

\ourmoditem{thread\_enable\_cancel}{thread\_enable\_cancel/0}{thread}
% 
Enables the calling thread to be cancelled.  By default, threads may
be cancelled, so this predicate needs to be called if {\tt
  thread\_disable\_cancel/0} has been previously called.  This
predicate always succeeds.

\standarditem{thread\_yield}{thread\_yield/0}
% 
Make the calling thread ready to be run {\em after} other threads of
the same priority.  This predicate relies on the real-time extensions
to pthreads specified in POSIX 1b, and may not be available on all
platforms.

{\bf Error Cases}
\bi
\item 	The current platform does not support POSIX real-time extensions
\bi
\item 	{\tt misc\_error}
\ei
\ei

\standarditem{thread\_property(?ThreadOrAlias,?Property)}
{thread\_property/2}
%
If {\tt ThreadOrAlias} is instantiated, unifies {\tt Property} with
current properties of the thread that unify with {\tt Property}; if
{\tt ThreadOrAlias} is a variable, backtracks through all the current
threads whose properties unify with {\tt Property}.  Note that there
is no guarantee that that the information returned will be valid, due
to concurrency issues.

Currently {\tt Property} can have the form 
\bi
\item {\tt detached(Bool)}: if {\tt Bool} is true the thread is
  detached, otherwise it is joinable.
%
\item {\tt alias(Alias)}: if the thread has an alias {\tt Alias}
%
\item {\tt status(Status)}: see Section~\ref{sec:thread-status} for
  thread statuses that are currently supported.
\ei

{\bf Example:} The following predicate may be used to clear resources
from the thread table, although due to concurreny reasons, non-running
threads may remain in the thread table after this predicate
terminates.
\begin{verbatim}
clear_thread_table:- 
    thread_property(Tid,status(S)),
    \+ (S = running),
    thread_join(Tid),
    fail.
clear_thread_table.
\end{verbatim}

{\bf Error Cases}
%
\bi
\item {\tt ThreadOrAlias} is neither a variable nor an XSB thread id
  nor an alias
\bi
\item {\tt domain\_error(thread\_or\_alias, ThreadOrAlias)}
\ei
\item {\tt ThreadOrAlias} is not associated with a valid thread
\bi
\item {\tt existence\_error(thread, ThreadOrAlias)}
\ei
\ei

\standarditem{thread\_sleep(+Seconds)}
{thread\_sleep/1}
%
Causes the calling thread to sleep approximately {\tt Seconds}
before resuming.  A thread may be cancelled while sleeping.  However,
a sleeping thread that is signaled will execute the signaled goal
and resume execution {\em without} returning to sleep.

{\bf Error Cases}
\bi
\item 	{\tt Seconds} is a variable
\bi
\item 	{\tt instantiation\_error}.
\ei
\item 	{\tt Seconds} is not a number
\bi
\item 	{\tt type\_error(number, Seconds)}.
\ei
\ei

%----------

\comment{
\ourmoditem{usleep(+Microseconds)}{usleep/1}{thread}
%
Causes the calling thread to sleep approximately {\tt Microseconds}
before resuming.

{\bf Error Cases}
\bi
\item 	{\tt Microseconds} is a variable
\bi
\item 	{\tt instantiation\_error}.
\ei
\item 	{\tt Microseconds} is not an integer
\bi
\item 	{\tt type\_error(integer, Microseconds)}.
\ei
\ei
}

% 
\end{description}

\subsection{Predicates for Thread Synchronization and Communication} 
\label{sec:synchronization}
%
Threads can communicate to some extent through shared tables and
dynamic code.  However, it is often useful to use message queues as a
synchronizable form of communication.  Similarly, while the XSB engine
itself is thread-safe, thread synchronization may be needed when
calling a package that is not itself thread safe (see the beginning of
this chapter for a list of which packages are and are not
thread-safe).  Synchronization may also be needed to protect data
accessed by foreign function calls, or to coordinate responses to
external events.

\subsubsection{Prolog Message Queues}~\label{sec:message-queues}
%
As described previously, each thread is created with a private message
queue that is readable only by itself.  The following predicates are
used to communicate using private and public message queues.
%
\index{aliases!message queues}
\begin{description}
\standarditem{message\_queue\_create(-Queue,+Options)}
{message\_queue\_create/2}
%
Creates a new public message queue with identifier {\tt Queue}.  {\tt
  Options} allows optional parameters to be passed for the maximum
number of terms in the queue, and for aliases of the queue.
%
\bi
\item {\tt max\_terms(N)}: create queue so that it can contain at most
  {\tt N} terms before writes to the queue block.  If not specified,
  the default size is used.  This default can be queried and altered
  at run time via the Prolog flag {\tt queue\_max\_terms}.
  (cf. Section~\ref{State}).  If the flag {\tt queue\_max\_terms} is
  set to 0, the queue size will be bounded only by available memory.
%
\item {\tt alias(Alias)}: Allow queue {\tt Queue} to be referred to
  via {\tt Alias} in all standard queue predicates.  {\tt Alias}
  remains active for {\tt Queue} until it is destroyed.
\ei

{\bf Error Cases}
\bi
\item 	Queue is not a variable
\bi
\item 	{\tt type\_error(variable,Queue)}
\ei
\item Options is a partial list or a list with an element that is a
  variable 
\bi
\item  instantiation error
\ei
\item Options is neither a partial list or a list
\bi
\item  type error(list, Options)
\ei
\item 	{\tt Options} contains an option, {\tt Option} not described above
\bi
\item 	{\tt domain\_error(queue\_option,Option)}
\ei
%
\item An element of {\tt Options} is {\tt alias(A)} and {\tt A} is
  already associated with an existing thread, queue, mutex or stream 
\bi
\item {\tt permission\_error(create,alias, A)}
\ei
\item An element of {\tt Options} is {\tt alias(A)} and {\tt A} is not an atom
\bi
\item {\tt type\_error(atom,A)}
\ei
\ei

\standarditem{message\_queue\_detroy(+Queue\_or\_Alias)}
{message\_queue\_destroy/1}
%
Destroys a public message queue with alias or id {\tt
  Queue\_or\_alias}, as created by {\tt message\_queue\_create/[1,2]}.
%  It is not allowed to
%de- stroy the queue of a thread. 
If any threads are currently waiting on {\tt Queue\_or\_Alias} to read
or write a term, they will be awakened and will throw an existence
error.
% or may try to wait for later?

{\bf Error Cases}
\bi
\item 	{\tt Queue\_or\_Alias} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Queue\_or\_Alias} is not a queue id or alias
\bi
\item 	{\tt domain\_error(queue\_or\_alias,Queue\_or\_Alias)}
\ei
\item {\tt Queue\_or\_Alias} denotes a private message queue or signal
  queue rather than a public message queue
\bi
\item {\tt permission\_error(destroy,private\_signal\_or\_message\_queue,Queue\_or\_Alias)}
\ei
\item {\tt Queue\_or\_alias} is not the queue name or alias of a
  public message queue.
\bi
\item {\tt existence\_error(message\_queue, Queue\_or\_Alias)}
\ei
\ei
%


\standarditem{thread\_send\_message(+Queue\_or\_Alias,\#Message)}
{thread\_send\_message/2}
%
{\tt Queue\_or\_alias} may either be a queue id or alias, or a thread
id or alias in which latter case the private queue for a thread is
used.  If there are fewer terms on {\tt Queue\_or\_Alias} than the
queue's maximum allowed number {\tt thread\_send\_message/2} puts {\tt
  Message} onto {\tt Queue\_or\_Alias}, and returns immediately.
Otherwise, the calling thread suspends until there are fewer elements
on {\tt Queue\_or\_Alias} than the queue's maximum allowed number,
when the thread will be awakened to put {\tt Message} onto the queue.

{\bf Error Cases}
\bi
\item 	{\tt Queue\_or\_Alias} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item {\tt Queue\_or\_Alias} is not a queue id, queue alias, thread
  id, or thread alias.  
\bi
\item 	{\tt domain\_error(queue\_or\_alias,Queue\_or\_Alias)}
\ei
\ei
%

\standarditem{thread\_get\_message(+Queue\_or\_Alias,?Message)}
{thread\_get\_message/2}
%
If there are terms on {\tt Queue\_or\_Alias} {\tt
  thread\_get\_message/2} traverses {\tt Queue\_or\_Alias} to obtain
the first term $T$ that unifies with {\tt Message}.  If $T$ exists,
the predicate returns with {\tt Message} bound to the most general
unifier of {\tt Message} and $T$.  If there are no terms on {\tt
  Queue\_or\_Alias} or if no terms unify with {\tt Message}, the
calling thread suspends until at least one term is added to {\tt
  Queue\_or\_Alias}.  When the thread awakes, it will recheck {\tt
  Queue} from its beginning for a term that unifies with {\tt
  Message}.

{\bf Error Cases}
\bi
\item 	{\tt Queue\_or\_Alias} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Queue\_or\_Alias} is not a queue id or alias
\bi
\item 	{\tt domain\_error(queue\_or\_alias,Queue\_or\_Alias)}
\ei
\bi
\item   {\tt existence error(queue, Queue\_or\_Alias)}
\ei
\ei
%
\standarditem{thread\_get\_message(?Message)}
{thread\_get\_message/1}
%
Acts as {\tt thread\_get\_message/2}, but on a thread's private queue.

\standarditem{thread\_peek\_message(+Queue\_or\_Alias,?Message)}
{thread\_peek\_message/2}
%
If there are terms on {\tt Queue\_or\_Alias} {\tt
  thread\_peek\_message/2} traverses {\tt Queue\_or\_Alias} to obtain
the first term $T$ that unifies with {\tt Message}.  If $T$ exists,
the predicate returns with {\tt Message} bound to the most general
unifier of {\tt Message} and $T$.  If there are no terms on {\tt
  Queue\_or\_Alias} or if no terms unify with {\tt Message}, the predicate fails.

{\bf Error Cases}
\bi
\item 	{\tt Queue\_or\_Alias} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Queue\_or\_Alias} is not a queue id or alias
\bi
\item 	{\tt domain\_error(queue\_or\_alias,Queue\_or\_Alias)}
\ei
\item {\tt Queue\_or\_Alias} is not associated with a current queue
\bi
\item   {\tt existence error(queue, Queue\_or\_Alias)}
\ei
\ei
%
\standarditem{thread\_peek\_message(?Message)}
{thread\_peek\_message/1}
%
Acts as {\tt thread\_peek\_message/2}, but on a thread's private queue.

\end{description}

\subsubsection{User-defined Mutexes}~\label{sec:mutexes}
%
\index{mutexes!user defined}

Usually, running multi-threaded evaluations does not requre a user to
set any mutexes -- necessary mutexes are handled by XSB itself (we
hope), and programs can often be written so that user-level locking is
unnecessary.  However, under certain conditions, locking is useful or
even necessary: for instance, a user may need to set a lock so that a
set of shared dynamic facts cannot be accessed when it is updated.

One of the simplest and most powerful primitives for locking are
mutexes.  The mutexes provided by the following predicates are {\em
  recursive}: if a thread $T$ locks a recursive mutex $M$, any calls
to {\tt mutex\_lock(M)} made by $T$ will immediately succeed without
suspending while $M$ is locked.  Other threads that attempt to lock
$M$ will suspend until $M$ is unlocked.  To unlock $M$ after $n$ calls
to {\tt mutex\_lock(M)}, $T$ must make $n$ calls to {\tt
  mutex\_unlock(M)}.

When using mutexes in XSB, programmers must not only avoid explicitly
creating deadlocks, but must also ensure that a mutex is unlocked when
leaving a critical area, and destroyed when it is no longer needed.
Making sure that this happens for successful goals, for failed goals
and for goals that raise exceptions can sometimes be complicated.  The
predicate {\tt with\_mutex/2} handles all of these cases.  We
recommend using it if possible, and making use of lower-level calls to
{\tt mutex\_lock/1}, {\tt mutex\_unlock/1} and {\tt mutex\_trylock/1}
only in rare cases when {\tt with\_mutex/2} is not applicable.

\begin{description}
\standarditem{with\_mutex(+Mutex,?Goal)}{with\_mutex/2}
%
Locks a current mutex or alias{\tt Mutex}, executes {\tt Goal}
deterministically, then unlocks {\tt Mutex}.  If {\tt Goal} leaves
choice-points, these are destroyed.  {\tt Mutex} is unlocked
regardless of whether {\tt Goal} succeeds, fails or raises an
exception. Any exception thrown by {\tt Goal} is re-thrown after the
mutex has been successfully unlocked.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Mutex} is not a mutex id or alias
\bi
\item 	{\tt domain\_error(mutex\_or\_alias,Mutex\_or\_Alias)}
\ei
%
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\item Locking {\tt Mutex} would give rise to a deadlock~\footnote{This
  error case handles the {\tt EDEADLK} return code on MacOS X, and other
  platforms.}
\bi
\item 	{\tt permission\_error(mutex,lock,Mutex)}
\ei
\item {\tt Goal} is a variable
\bi
\item  instantiation error
\ei
%
\item {\tt Goal} is neither a variable nor a callable term
\bi
\item type error(callable, Goal)
\ei
%
\ei

\index{aliases!mutexes}
\standarditem{mutex\_create(?Mutex)}
{mutex\_create/1}
%
Creates a new recursive user mutex with identifier {\tt Mutex}.  {\tt
  Options} allows optional parameters to be passed, currently only for
aliases of the mutex.
%
\bi
\item {\tt alias(Mutex)}: Allow queue {\tt Mutex} to be referred to
  via {\tt Mutex} in all standard queue predicates.  {\tt Mutex}
  remains active for {\tt Mutex} until it is destroyed.
\ei

{\bf Error Cases}
\bi
\item 	Mutex is not a variable
\bi
\item 	{\tt type\_error(variable,Mutex)}
\ei
\item Options is a partial list or a list with an element that is a
  variable 
\bi
\item  instantiation error
\ei
\item Options is neither a partial list or a list
\bi
\item  type error(list, Options)
\ei
\item 	{\tt Options} contains an option, {\tt Option} not described above
\bi
\item 	{\tt domain\_error(mutex\_option,Option)}
\ei
%
\item An element of {\tt Options} is {\tt alias(A)} and {\tt A} is
  already associated with an existing thread, queue, mutex or stream 
\bi
\item {\tt permission\_error(create,alias, A)}
\ei
\item An element of {\tt Options} is {\tt alias(A)} and {\tt A} is not an atom
\bi
\item {\tt type\_error(atom,A)}
\ei
\ei

\standarditem{mutex\_destroy(+Mutex)}
{mutex\_destroy/1}
%
Destroys a current unlocked mutex with alias or id {\tt Mutex} along
with any memory it uses.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Mutex} is not a mutex id or alias
\bi
\item 	{\tt domain\_error(mutex\_or\_alias,Mutex\_or\_Alias)}
\ei
%
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\item 	{\tt Mutex} is locked
\bi
\item 	{\tt permission\_error(mutex,destroy,Mutex)}
\ei
\ei

\standarditem{mutex\_lock(+Mutex)}
{mutex\_lock/1}
%
{\tt mutex\_lock(Mutex)} locks a (recursive) mutex with alias or id
{\tt Mutex}. Locking and unlocking mutexes should be paired carefully
in order to avoid deadlocks. In particular, a programmer needs to
ensure that mutexes are properly unlocked even if the protected code
fails or raises an exception.
%For most common cases, the built-in predicate with mutex/2 (3.4.3)
%provides a safer way for using mutexes.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Mutex} is not a mutex id or alias
\bi
\item 	{\tt domain\_error(mutex\_or\_alias,Mutex\_or\_Alias)}
\ei
%
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\item Locking {\tt Mutex} would give rise to a deadlock~\footnote{This
  error case handles the {\tt EDEADLK} return code on MacOS X, and other
  platforms.}
\bi
\item 	{\tt permission\_error(mutex,lock,Mutex)}
\ei
\ei

\standarditem{mutex\_trylock(+Mutex)}
{mutex\_trylock/1}
%
Works as {\tt mutex\_lock/1} but fails immediately if {\tt Mutex} is
held by another thread,  rather than suspending the calling thread.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Mutex} is not a mutex id or alias
\bi
\item 	{\tt domain\_error(mutex\_or\_alias,Mutex\_or\_Alias)}
\ei
%
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\ei

\standarditem{mutex\_unlock(+Mutex)}
{mutex\_unlock/1}
%
Unlocks the mutex with alias or id {\tt Mutex} when called by the same
thread that locked {\tt Mutex}.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Mutex} is not a mutex id or alias
\bi
\item 	{\tt domain\_error(mutex\_or\_alias,Mutex\_or\_Alias)}
\ei
%
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\item 	{\tt Mutex} is not held by the calling thread
\bi
\item 	{\tt permission\_error(unlock,mutex,Mutex)}
\ei
\ei

\standarditem{mutex\_unlock\_all}{mutex\_unlock\_all/0}
%
{\tt mutex\_unlock\_all/0} unlocks all user mutexes owned by the
current thread.  It has no error cases.

\standarditem{mutex\_property(?MutexOrAlias,?Property)}
{mutex\_property/2}
%
If {\tt MutexOrAlias} is instantiated, unifies {\tt Property} with current
properties of the mutex; if {\tt MutexOrAlias} is a variable, backtracks
through all the current mutexes whose properties unify with {\tt
  Property}.  Note that there is no guarantee that that the
information returned will be valid, due to concurrency issues.

Currently {\tt Property} can have the form 
\bi
\item {\tt alias(Alias)}: if the mutex has an alias {\tt Alias}
%
\item {\tt status(Status)}.  If the mutex is locked, {\tt Status} will
  be a term of the form {\tt locked(ThreadId,NumLocks)} where {\tt
    ThreadId} is the thread id of the owner of the lock, and {\tt
    NumLocks} is the number of times the mutex has been locked by the
  current owner (recall that user-defined mutexes are recursive and
  must be unlocked as many times as they have been locked in order to
  be freed).  If the mutex is unlocked, {\tt Status} will be a term
  of the form {\tt unlocked}.  \ei

{\bf Example:} The query
\begin{verbatim}
?- mutex_property(M,status(_)).
\end{verbatim}
can be used to enumerate all active user-defined mutexes.

{\bf Error Cases}
%
\bi
\item {\tt MutexOrAlias} is neither a variable nor an XSB mutex id
  nor an alias
\bi
\item {\tt domain\_error(mutex\_or\_alias, MutexOrAlias)}
\ei
\item {\tt MutexOrAlias} is not associated with an active mutex
\bi
\item {\tt existence\_error(mutex, MutexOrAlias)}
\ei
\item {\tt Property} is neither a variable nor a valid mutex property
\bi
\item {\tt domain\_error(mutex\_property, Property)}
\ei
\ei

\end{description}

%--------------------------------------------------------------------
\comment{
mutex_statistics not yet implemented.
}
%--------------------------------------------------------------------

\index{multi-threading|)}
