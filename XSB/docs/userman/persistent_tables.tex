
\chapter{The {\tt persistent\_tables} Package}

  \begin{center}
    {\Large {\bf By David S Warren}}
  \end{center}

This package supports the generation and maintenance of persistent
tables stored in data files on disk (in a choice of formats.)
Persistent tables store tuples that are computed answers of subgoals,
just as internal XSB tables do.  Persistent tables allow tables to be
shared among concurrent processes or between related processes over
time.  XSB programmers can declare a predicate to be persistently
tabled, and the system will then, when a subgoal for the predicate is
called, look to see if the corresponding table exists on disk, and, if
it does, read the tuples that are answers for the subgoal on demand
from the data file.  If the persistent table for the subgoal does not
exist, the XSB subgoal will be called and the tuples that are returned
as answers will be stored on disk, and then returned to the call.
Persistent tables cannot be recursively self-dependent, unlike
internal XSB tables.  Normally the tables use call subsumption and
abstracted from the original call.  They act like (internal)
subsumptive tables with call abstraction.

A persistent table can serve to communicate between two XSB processes:
a process that requests the evaluation of a subgoal and a sub-process
that evaluates that subgoal.  This is done by declaring a persistently
tabled predicate to have its subgoals be evaluated by a subprocess.
In this case, when a persistent table for a subgoal needs to be
created, a subprocess will be spawned to compute and save the subgoal
answers in the persistent table.  The calling process will wait for the
table to be computed and filled and, when the table is completed, will
continue by reading and returning the tuples from the generated
persistent table to the initial calling subgoal.

Persistent tables and internal tables (i.e., normal XSB tables) are
independent: a predicate may be persistently tabled but not (internally)
tabled, tabled but not persistently tabled, neither or both.  In many
cases one will want to (internally) table a persistently tabled
predicate, but not always.

Persistent tables provide a declarative mechanism for accessing data
files, which could be generated by other mechanisms such as the {\tt
  viewsys} package, or by other programming languages or
organizations.  When this is done, simply invoking the goal will
access the persistent table, i.e., the data from the data file.  In
such a case, the data file format must conform to the format declared
for the persistent table for its goal.
% TES: I dont understand
%One may, or may not, want to (internally) table this goal.  If
%it is (internally) tabled then this will act similarly to a load\_dyn
%of the original data.

%A data file can be used to define a persistent table.  

\section{Using Persistent Tables with {\tt viewsys}}

Persistent tables can be used as views in the {\tt viewsys}
package.This is done by:

\begin{enumerate}

\item Defining a module that contains persistent tabled predicates
that correspond to the desired (stored) views.

\item Using {\tt pt\_need/1} declarations (see below) to declare table
dependencies to support concurrent table evaluation.

\item Running a view-generation process ({\tt pt\_fill/1/2}) to
compute the desired views by calling XSB processes.  The
view-generation process will ""pre""-compute the requred tables in a
bottom-up order, using multiple concurrent processes as specified.
Since no XSB persistently tabled predicate will be called until after
all the persistent tables that it depends on have been computed, all
XSB predicates will run using those precomputed persistent tables,
without blocking and without having to re-compute any of them.

\end{enumerate}

The {\tt persistent\_tables} subsystem maintains persistent tables in
directories and files in a subdirectory of the directory containing
the source code for a module that defines persistently tabled
predicates.  The subdirectory is named {\tt xsb\_persistent\_tables}.
Only predicates defined in a (non-usermod) module can be persistently
tabled.  For each module with declared persistent tables, there is a
subdirectory (whose name is the module name) of
{\tt xsb\_persistent\_tables} that contains the contents of its
tables.  In such a subdirectory there is a file, named
{\tt PT\_Directory.P}, that contains information on all existent
persistent tables (stored or proposed.)  The subdirectory also
contains all the files that store the contents of persistent tables
for the given module.

Currently the way a predicate is declared to be persistently tabled is
somewhat verbose.  This is because, at this time, there is no XSB
compiler support for persistent tables, and therefore the user must
define explicitly all the predicates necessary for the
implementation.~\footnote{In the future, if this facility proves to be
  useful, we will extend the compiler to simplify the necessary
  declarations.}

The following declarations are needed in any module {\tt <Module>}
that uses persistent tables:

\begin{verbatim}
:- packaging:bootstrap_package('persistent_tables','persistent_tables').
:- import table_persistent/5, pt_call/1 from persistent_tables.
:- export ensure_<Module>_loaded/0.
ensure_<Module>_loaded.
\end{verbatim}

The {\tt ensure\_<Module>\_loaded/0} predicate is called by the system
when it is required that the module be loaded.

A persistent table for predicate {\tt Pred/K} is declared and defined as
follows:

\begin{verbatim}
:- export <Pred>/K, <Pred>_ptdef/K.
:- table_persistent(PredSkel,ModeList,TableInfo,ProcessSpec,DemandGoal).
PredSkel :- pt_call(PredSkel).
Pred_ptdef(....) :- ... definition of Pred/K ....
\end{verbatim}
	   
{\tt PredSkel} indicates a most-general goal for the predicate
{\tt Pred/K}.

As can be seen, the user must define an auxiliary predicate, in this
case {\tt <Pred>\_ptdef/K}.  This predicate is defined using the
clauses intended to define {\tt Pred/K}.  {\tt Pred/K} itself is
defined by the single clause that calls the persistent-tabling
meta-predicate {\tt pt\_call/1}.  This meta-predicate will generate
subgoals for {\tt Pred\_undef/K} and call them as is required.

%TES: example needed

The arguments of the {\tt table\_persistent/5} declaration are as
follows:

\begin{itemize}

\item{{\tt PredSkel}}: is the goal whose instances are to be persistently
tabled.  Its arguments must be distinct variables.

\item{{\tt ModeList}}: a list of mode-lists (or a single mode-list.)
A mode-list is a list of constants, {\tt +}, {\tt t}, {\tt -}, and
{\tt -+} with a length equal to the arity of {\tt Goal}.  
%The mode
%indicates constraints on the state of its corresponding argument in a
%subgoal call.  
A {\tt -} mode indicates that the corresponding position of a call to
this goal may be bound or free and is to be abstracted when filling
the persistent table; a {\tt +} mode indicates that the
corresponding position must be bound and is not abstracted, and so a
separate persistent table will be kept for each call bound to any
specific constant in this argument position; a {\tt t} mode
indicates that this argument must be bound to a timestamp value.
I.e., it must be bound to an integer obtained from the persistent
tabling system that indicates the snapshot of this table to use.  (See
{\tt add\_new\_table/2} for details on using timestamps.)  A
{\tt -+} mode indicates that the corresponding argument may be
bound or free, but on first call, it will be abstracted and a separate
table will be constructed for each value that this argument may take
on.  So it is similar to a {\tt -} mode in that it is abstracted,
but differs in that it generates multiple tables, one for each
distinct value this argument takes on.  This can be used to split data
into separate files to be processed concurrently. 

% (A future implementation may use a single indexed file to store the
%generated set of tables, indexed on the {\tt -+} argument.)

There may be multiple such mode-lists and the first one that a
particular call of {\tt Goal} matches will be used to determine the
table to be generated and persistently stored.  A call does {\em not}
match a mode-list if the call has a variable in a position that is a
{\tt +} in that mode-list.  If a call does not match any mode-list, an
error is thrown.  Clearly if any mode list contains a {\tt t} mode, all
must contain one in the same position.  
%(Note: I have not as yet found
%much need for multiple mode lists.)

\item{{\tt TableInfo}}: a term that describes the type and format of
the persistent tables for this predicate.  It currently has only the
following possibilities:

\begin{itemize}

\item{{\tt canonical}}: indicates that the persistent table will be
stored in a file as lists of field values in XSB canonical form.
These files support answers that contain variables.  (Except, answers
to goals with modes of {\tt -+} must be ground.)

\item{{\tt delimited(OPTS)}}: indicates that the persistent table will
be stored in a file as delimited fields, where OPTS is a list of
options specifying the separator (and other properties) as described
as options for the predicate {\tt read\_dsv/3} defined in the XSB lib
module {\tt proc\_files}.  Goal answers stored in these files must be
ground.

\end{itemize}

\item{{\tt ProcessSpec}}: a term that describes how the table is to
be computed.  It can be one of the following forms:

\begin{itemize}

\item{{\tt xsb}}: indicating that the persistent table will be filled by
calling the goal in the current xsb process.

\item{{\tt spawn\_xsb}}: indicating that the persistent table will be
filled by spawning an xsb process to evaluate the goal and fill the table.

\end{itemize}

\item{{\tt DemandGoal}}: a goal that will be called just before the
main persistently tabled goal is called to compute and fill a
persistent table.  The main use of this goal is to invoke
{\tt pt\_need/1} commands (see below) to indiate that
the persistent tables that this goal depends on are needed.  This
allows tables that will be needed by this computation to be computed
concurrently by other processes.  

%This is the way that parallel
%computation of a complex query is supported.

%[Note: A future extension may try to automatically generate these goals from
%the source program, or from a previous execution of the program.  The
%details remain to be designed and implemented...]

\end{itemize}

%The file named {\tt PT\_Directory.P} is maintained by the subsystem to
%keep track of the state of persistent tables for its associated module.
%It contains facts for two predicates: {\tt table\_instance/8} and
%{\tt table\_instance\_cnt/2}.

%The predicate {\tt table\_instance(TId, Goal, Module, Status,
%GoalArgs, AnsVars, TableInfo, FileName)} contains information on a
%particular persistent table, as follows:

%\begin{itemize}	   

%\item{{\tt TId}}: a unique id for the persistent table.  It is unique
%for the module.  It is generated by concatenating the predicate name
%and a unique number (generated using the fact in
%{\tt table\_instance\_cnt/2}.)  (The predicate name is actually
%unnecessary, since the number uniquely identifies the table.  The name
%is included to make it easier for a user to see the goal a table file
%is associated with.)

%\item{{\tt Goal}}: the goal of the persistently tabled predicate that
%generates this table.
%
%\item{{\tt Module}}: the module of the persistently tabled
%predicate. (Maybe should eliminate this field, since it is not
%necessary, the super-directory is now the module, so we need to know
%it to get here...)

%\item{{\tt Status}}: the status of this persistent table.  It can be:

%\begin{itemize}							 

%\item{{\tt generated(DateTimeGen,DateTimeUsed)}}: indicating that the
%table is completed and available for use. {\tt DateTimeGen} is the
%date and time it was generated.  {\tt DateTimeUsed} is the date and
%time it was most recently used.  (Updating this date means writing the
%PT\_Directory.P file more often.  Is it worth that overhead to keep
%this value?)

%\item{{\tt group\_generated(DateTimeGen,DateTimeUsed)}}: indicating
%that this goal generated a group of files, based on a {\tt -+} mode.
%This fact does not describe a single table but stands for group of
%tables.

%\item{{\tt being\_generated(Pid,DateTime)}}: indicating that the table
%is in the process of being generated by process with process ID
%{\tt Pid}, and started generation at {\tt DateTime}.
%
%\item{{\tt invalid(DateTime)}}: indicating that the generation of this
%table failed or aborted in some way, at time {\tt DateTime}, and so is
%%not valid.  (There is work to do to maintained this field, by catching
%errors, associating them with the correct Tid, and updating this
%value to allow propagation of failure.)
%
%\item{{\tt needs\_generation(DateTime)}}: indicating that the table was
%requested to be generated (at {\tt DateTime}), but no process is
%currently in the process of generating it.  This status is set by
%{\tt pt\_need/1} and is used to support concurrent generaton of
%persistent tables.

%\end{itemize}							 

%\item{{\tt GoalArgs}}: a list, {\tt Arity} long, of arguments to
%{\tt Goal}, that generates this persistent table.  These are exactly the
%arguments of {\tt Goal}.
%
%\item{{\tt GoalVars}}: the list of variables in {\tt Goal}.  These
%generate the answer tuples and correspond to the fields in the
%persistent table.
%
%\item{{\tt TableInfo}}: the table info for this table, as described
%above for {\tt table\_persistent/5}.
%
%\item{{\tt FileName}}: the name of the file containing the table data.
%
%\end{itemize}	   

%The predicate {\tt table\_instance\_cnt/2} has one fact that defines
%two system values: 1) the last number used to name a unique table
%file, when generating a {\tt TId} for a persistent table.  This is
%incremented every time a new persistent table file is created and used
%in the name of that file.  And 2) a non-negative integer represeting
%the most-recent version time-stamp used.  (See the predicates below
%for how time-stamps can be used.)
%
%The contents of the persistent tables that are described in
%{\tt table\_instance/8} are stored in files in the same directory as
%its {\tt PT\_Directory.P} file.  The files are named +""table\_<TId>.P""
%(for files containing canonical terms, and .txt for delimited files
%containing separated values.)

\section{Methodology for Defining View Systems}

As mentioned above, persistent tables can be used to construct view
systems, i.e., DAGs representing expressions over functions on
relations.  A relational function is a basic view definition.  An
expression over such functions is a view system.  The leaf relations
in the expression are the base relations, and every sub-expression
defines a view.  A view expression can be evaluated bottom up, given
values for every base relation.  Independent subexpressions can be
evaluated in parallel.  Failing computations can be corrected, and
only those views depending on a failed computation need to be
re-computed.

Sometimes view systems are required to be ""incremental"".  That is,
given a completely computed view system, in which the base relations
are given and all derived relations have been computed, we are given
tuples to add to (and maybe delete from) the given base relations, and
we want to compute all the new derived view contents.  In many systems
such incremental changes to the base relations result in incremental
changes to the derived relations, and those new derived relations can
be computed in much less time than would be required to recompute all
the derived relations starting from scratch with the new (updated)
base relations.

To implement a view system in XSB using persistent tables, each view
definition is provided by the definition of a persistently tabled
predicate.  Then given table instances for the base relations, each
view goal can be called to create a persistent table representing the
contents of the corresponding derived view.

The following describes, at a high level, a methodology for
implementing a given view system in XSB using persistent tables.

\begin{enumerate}

\item Define the top-level view relations, just thinking Prolog, in a
single XSB module.  A top-level relation is the ultimate desired
output of a view system, i.e., a relation that is normally not used in
the definition of another view.  Define supporting relations as seems
reasonable.  Don't worry about efficiency. Use Prolog intuitions for
defining relations.  Don't worry about incrementality; just get the
semantics defined correctly.

\item Now think about bottom-up evaluation.  I.e., we use subsumptive
tables, so goals will be called (mostly) open, with variables as
arguments.  Decide what relations will be stored intermediate views.
Restructure if necessary to get reasonable stored views.

\item Now make it so the stored views can be correctly evaluated
bottom-up, i.e., with an open call.  This will mean that the Prolog
intuition of passing bound values downward into called predicates
needs to be rethought.  For bottom-up evalution, all head variables
have to be bound by some call in the body.  So some definitions may
need new body calls, to provide a binding for variables whose values
had been assumed to be passed in by the caller.

\item Declare the stored views as table\_persistent, and test on
relatively small input data. For each table\_persistent, decide initially
whether to compute it in the given environment or to spawn a process
to evaluate in a new process environment.

\item If you don't need incrementality (i.e., given relatively small
additions/deletions to the base relations, compute the new derived
relations without recomputing results for old unchanged data): then
tune (maybe adding split-compute-join concurrency, using the {\tt -+}
mode, as appropriate.)  And you're done.

\item If you *do* need incrementality: In principle, the system ought to
be able automatically to transform the program given thus far into an
incremental version.  (See Annie Liu's research.)  But at this point,
I don't know how to do this ensuring that the reslting performance is
close to optimal.  (Maybe Annie does, but...)  So we will transform
the existing program by hand, and we will give ""rules-of-thumb"" to
help in this process.

%\item To begin, we will assume that we are only adding new contents to
%the existing views.  Now, for every stored view predicate P in the
%existing definition, we make two predicates: old\_P and delta\_P.  
%The
%predicate old\_P will contain the tuples of the existing ... (to be
%continued...)

\end{enumerate}

\section{Using Timestamps (or version numbers)}

The persistent table package provides some support for integer
timestamps for versioning of tables.  The programmer can define view
predicates with an argument whose value is a version number.  The
version number must be bound on all calls to persistently tabled goals
that contan them.  Normally a subgoal of a persistently tabled
predicate with a given version number will depend on other subgoals
with the same version.  This allows the programmer to keep earlier
versions of tables for view systems, in order to back out changes or
to keep a history of uses of the view system.  So normally a new set
of base tables will get a new version number, and then all subgoals
depending of those base tables will have that same version number.

The {\tt pt\_add\_table/3} predicate will add base tables and give them
a new version number, returning that new version number.  This allows
the programmer to use that version number in subsequent calls to
{\tt pt\_fill} to fill the tables with the correct version.  Also,
when calling the predicate {\tt pt\_eval\_viewsys/5} the {\tt Time}
variable can be used in the subgoals in the {\tt FillList} to invoke
the correctly versioned subgoals.

A particularly interestng use of versions is in the implementation of
incremental view systems.  Recall that in an incremental view system,
one has a table that contains the accumulated records named, say,
old\_records/5, and receives a base table of new records to process
named, say, new\_records/5.  The incremental view system will define an
updated record file named, say, all\_records/5, which will contain the
updated records after processing and includng the new\_records.  It is
natural to use versions here, and make each predicate old\_record/5,
new\_record/5, and old\_record/5 have a version argument, say the first
argument.  Then note that we can define old\_records in terms of the
previous version of all\_records, as follows:

\begin{verbatim}
old_records(Time,....) :-
     Time > 1,
     PrevTime is Time - 1,
     all_records(PrevTime,...).
\end{verbatim}

Note that the version numbers, being always bound on call (and treated
according to a {\tt +} mode), will not appear in any stored table.  The
numbers will appear only in the called subgoals that are stored in the
{\tt table\_instance/8} predicate in the {\tt PT\_Directory.P} file.
So using version numbers does not make the persistent tables any
larger.

\section{Predicates for Persistent Tabling}

\begin{description}

\ourmoditem{pt\_call(+Goal)}{pt\_call/1}{persistent\_tables}
%
This predicate assumes that {\tt Goal} is persistently tabled and
calls it.  This predicate is normally used only in the definition of
the {\tt \_ptdef} version of the persistently tabled predicate, as
described above.

If the table for {\tt Goal} exists, it reads the table file and
returns its answers.  If the table file is being generated, it waits
until it is generated and then reads and returns its answers.  If the
table file doesn't exist and is not in the process of being generated,
it generates the table and then returns its results.  If the persistent
table process declaration indicates {\tt spawn\_xsb}, it spawns a
process to generate the table and reads and returns those answers when
the process is completed.  If the process indication is {\tt xsb}, it
calls the goal and fills the table if necessary, and returns the
answers.  

\ourmoditem{pt\_fill(+GoalList)}{pt\_fill/1}{persistent\_tables}
%
The predicate {\tt pt\_fill(+GoalList)} checks
if the persistent table for each persistently tabled {\tt Goal} in
{\tt GoalList} exists and creates it if not.  It should always succeed
(once, unless it throws an error) and the table will then exist.  If
the desired table is already generated, it immediately succeeds.  If
the desired table is being generated, it looks to see if there is
another table that is marked as {\tt needs\_generating} and, if so,
invokes the {\tt pt\_fill/1} operation for that table.  It continues
this until it finds that {\tt Goal} is marked as {\tt generated}, at
which time it returns successfully.  If no table for {\tt Goal} exists
or is being generated, it generates it.  

\ourmoditem{pt\_fill(+Goal,+NumProcs)}{pt\_fill/2}{persistent\_tables}
%
{\tt pt\_fill(+Goal,+NumProcs)} is similar to
{\tt pt\_fill/1} except that it starts {\tt NumProcs} processes to
ensure that the table for {\tt Goal} is generated.  Note that filling
the table for {\tt Goal} may require filling many other tables.  And
those table may become marked as {\tt needs\_generation}, in which case
multiple processes can work concurrently to fill the required tables.


\ourmoditem{pt\_need(+Goals)}{pt\_need/1}{persistent\_tables}
%
{\tt pt\_need(+Goals)} creates table entries in
the {\tt PT\_Directory.P} file for each persistently tabled {\tt Goal}
in the list of goals {\tt Goals}.  ({\tt Goals} alternatively may be a
single persistently tabled goal.  The new entry is given status
{\tt needs\_generation}.  This predicate is intended to be used in a
goal that appears as the 5th argument of a {\tt table\_persistent/5}
declaration.  It is used to indicate other goals that are required for
the computation of the goal in the first argument of its
{\tt table\_persistent/5} declaration.  By marking them as ""needed"",
other processes (started by a call to {\tt pt\_fill/2}) can begin
computing them concurrently.  Note that these {\tt Goals} can share
variables with the main {\tt Goal} of the declaration, and thus
appropriate instances of the subgoals can be generated.  For example,
if time stamps are used, the needed subgoals should have the same
variable as the main goal in the corresponding ""time"" positions.

Note that a call to {\tt pt\_need/1} should appear {\bf only} in the
final argument of a {\tt table\_persistent/5} declaration.  Its correct
execution requires a lock to be held and predicates to be loaded,
which are ensured when that goal is called, but cannot be correctly
ensured by any other call(s) to the {\tt persistent\_tables} subsystem.

\ourmoditem{table\_persistent(+Goal,+Modes,+TableInfo,+ProcessSpec,+DemandGoal)}{table\_persistent/5}{persistent\_tables}
%
This predicate (used as a directive)
declares a predicate to be persistently tabled.  The form is
{\tt table\_persistent(+Goal, +Modes, +TableInfo, +ProcessSpec,
+DemandGoal)}, where:

\begin{itemize}

\item{{\tt Goal}}: is the goal whose instances are to be persistently
tabled.  Its arguments must be distinct variables.
{\tt Goal} must be defined by the single clause:

\begin{verbatim}
Goal :- pt_fill(Goal).
\end{verbatim}

Clauses to define the tuples of {\tt Goal} must be associated with
another predicate (of the same arity), whose name is obtained from
{\tt Goal}'s predicate name by appending {\tt \_ptdef}.

\item{{\tt ModeList}}: a list of mode-lists (or a single mode-list.)
A mode-list is a list of constants, {\tt +}, {\tt t}, {\tt -}, and
{\tt -+} with a length equal to the arity of {\tt Goal}.  The mode
indicates puts constraints on the state of corresponding argument in a
subgoal call.  A ""{\tt -}"" mode indicates that the corresponding
position of the goal is to be abstracted for the persistent table; a
""{\tt +}"" mode indicates that the corresponding position is not
abstracted and a separate persistent table will be kept for each call
bound to any specific constant in this argument position; a ""{\tt t}""
mode indicates that this argument will have a ""timestamp"".  I.e., it
will be bound to an integer obtained from the persistent tabling system
that indicates the snapshot of this table to use.  (See
{\tt add\_new\_table/2} for details on using timestamps.)  A mode of
""{\tt -+}"" is similar to a ""{\tt -}"" mode in that the associated
argument is abstracted.  The difference is that instead of all the
answers being stored in a single table, there are multiple tables, one
for each value of this argument for which there are answers.

There may be multiple such mode-lists and the first one that a
particular call of {\tt Goal} matches will be used to determine the
table to be generated and persistently stored.  A call does {\em not}
match a mode-list if the call has a variable in a position that is a
""+"" in that mode-list.  If a call does not match any mode-list, an
error is thrown.  If any mode list contains a {\tt t} mode, all must
contain one in the same position.

\item{{\tt TableInfo}} is a term that describes the type and format of the
persistent tables for this predicate.  It may have the following forms,
with the described meanings:

\begin{itemize}

\item{{\tt file(canonical)}}: indicates that the persistent table will be
stored in a file as lists of field values in XSB canonical form.

\item{{\tt file(delimited(OPTS))}}: indicates that the persistent table
will be stored in a file as delimited fields, where OPTS is a list of
options specifying the separator (and other properties) as described
as options for the predicate {\tt read\_dsv/3} in the XSB lib module
{\tt proc\_files}.

\end{itemize}

\item{{\tt ProcessSpec}} is a term that describes how the table is to
be computed.  It can be one of the following forms:

\begin{itemize}

\item{{\tt xsb}}: indicating that the persistent table will be filled by
calling the goal in the current xsb process.

\item{{\tt spawn\_xsb}}: indicating that the persistent table will be
filled by spawning an xsb process to evaluate the goal and fill the table.

\end{itemize}

\item{{\tt DemandGoal}}: a goal that will be called just before the
main persistently tabled goal is called to compute and fill a persistent
table.  The main use of this goal is to invoke {\tt pt\_need/1}
commands (see below) to indicate to the system that the persistent
tables that this goal depends on are indeed needed.  This allows
tables that will be needed by this computation to be computed by other
processes.  This is the way that parallel computation of a complex
query is supported.

\end{itemize}

\ourmoditem{pt\_abolish\_subgoals(+GoalList)}{pt\_abolish\_subgoals/1}{persistent\_tables}
%
{\tt pt\_abolish\_subgoals(+GoalList)} abolishes the persistent tables
for all goals in {\tt GoalList} by removing the corresponding facts in
table\_instance. The table files containing the data remain, and can be
cleaned up using {\tt pt\_remove\_unused\_tables/1}.  

\ourmoditem{pt\_move\_tables(+MoveList)}{pt\_move\_tables/1}{persistent\_tables}
%
{\tt pt\_move\_tables(+MoveList)} moves persistent tables.  {\tt
  MoveList} is a list of pairs of goals of the form {\tt FromGoal >
  ToGoal}, where {\tt FromGoal} and {\tt ToGoal} are persistently
tabled goals and their persistent tables have been filled.  For each
such pair the table file for {\tt ToGoal} is set to the file
containing the table for {\tt FromGoal}.  The table files must be of
the same format.  {\tt FromGoal} has its table\_instance fact removed.
This predicate may be useful for updating new and old tables when
implementing incremental view systems.

\ourmoditem{pt\_remove\_unused\_tables(+Module)}{pt\_remove\_unused\_tables/1}{persistent\_tables}
%
This predicate cleans up unused files from the directory that stores
persistent tables. {\tt pt\_remove\_unused\_tables(+Module)} looks
through the {\tt PT\_Directory.P} file for the indicated module and
removes all files with names of the form \file(table\_<Tid>.P) (or
.txt) for which there is no table id of {\tt <Tid>}.  So a user may
delete (or abolish) a persistent table by simply editing the {\tt
  PT\_Directory.P} file (when no one is using it!) and deleting its
table\_instance fact.  Then periodically running this predicate will
clean up the storage for unnecessary tables.

\ourmoditem{pt\_reset(+Module)}{pt\_reset/1}{persistent\_tables}
%
{\tt pt\_reset(+Module)} processes the {\tt PT\_Directory.P} file and
deletes all table\_instance records for tables that have status {\tt
  being\_generated}.  This will cause them to be re-evaluated when
necessary.  This is appropriate to call if all processes computing
these tables have been aborted and were not able to update the
directory.  It may also be useful if for some reason all processes are
waiting for something to be done and no progress is being made.

\ourmoditem{pt\_delete\_later(Module,TimeStamp)}{pt\_delete\_later/2}{persistent\_tables}
%
{\tt pt\_delete\_later(Module,TimeStamp)} delete all tables that have a
timestamp larger than {\tt Timestamp}.  It keeps the tables of the
TimeStamp snapshot.  It deletes the corresponding table records from
the PT\_Directory, and removes the corresponding files that store the tuples.  

\ourmoditem{pt\_delete\_earlier(Module,TimeStamp)}{pt\_delete\_earlier/2}{persistent\_tables}
%
{\tt pt\_delete\_earlier(Module,TimeStamp)} delete all tables that have a
timestamp smaller than {\tt Timestamp}.  It keeps the tables of the
TimeStamp snapshot.  It deletes the corresponding table records from
the PT\_Directory, and removes the corresponding files that store the tuples. 

\ourmoditem{pt\_delete\_table(+Goal)}{pt\_delete\_table/1}{persistent\_tables}
%
{\tt pt\_delete\_table(+Goal)} deletes the table for {\tt Goal} in its
{\tt PT\_Directory.P} file, so it will need to be regenerated when next
invoked.  The actual file containing the table data is {\em not}
removed.  (It may be a file in another directory that defines the
table via a call to {\tt pt\_add\_table/2} or friend.)  To remove a
local file that contains the tabled data, use {\tt
  pt\_remove\_unused\_tables/1}.

\ourmoditem{pt\_add\_table(+Goal,+FileName)}{pt\_add\_table/2}{persistent\_tables}
%
{\tt pt\_add\_table(+Goal,+FileName)} uses
the file {\tt FileName} to create a persistent table for {\tt Goal}.
{\tt Goal} must be persistently tabled. It creates a new
table\_instance record in the {\tt PT\_Directory.P} file and points it
to the given file.  The file is not checked for having a format
consistent with that declared for the persistently tabled predicate,
i.e., that it is correctly formated to represent the desired tuples.
The user is responsible for ensuring this.  

%%pt\_add\_table(new\_callout(3,demo,CO,SE,TA),'../test\_data/....txt'))
pt\_add\_table(Goal0,FileName) :-
	pt\_add\_table(Goal0,FileName,none).

\ourmoditem{pt\_add\_table(+Goal,+FileName,?TimeStamp)}{pt\_add\_table/3}{persistent\_tables}
%
{\tt pt\_add\_table(+Goal,+FileName,?TimeStamp)} uses the
file {\tt FileName} to create a persistent table for {\tt Goal}, which
must be persistently tabled.  It returns in {\tt TimeStamp} a new (the
next) time stamp for this module (obtained from the fact for predicate
{\tt table\_instance\_cnt/2} in the ET Directory.)  It is assumed that
{\tt Goal} has a time argument and the returned value will be used in
its eventual call.

This predicate creates a new table\_instance record in the {\tt
  PT\_Directory.P} file and sets its defining file to be the value of
{\tt FileName}.  The file is not checked for consistency, that it is
correctly formated to represent the desired tuples.  The user is
responsible for insuring this.  

\ourmoditem{pt\_add\_tables/2}{\tt pt\_add\_tables(+GoalList,+FileList)}{persistent\_tables}
%
{\tt pt\_add\_tables(+GoalList,+FileList)} is similar to {\tt
  pt\_add\_table/2} but takes a list of goals and a corresponding list
of files, and defines the tables of the goals using the files.

\ourmoditem{pt\_add\_tables(+GoalList,+FileList,-Time)}{pt\_add\_tables/3}{persistent\_tables}
%
{\tt pt\_add\_tables(+GoalList,+FileList,-Time)} is similar to
{\tt pt\_add\_table/3} but takes a list of goals and a corresponding
list of files, and defines the tables of the goals using the files,
returning the snapshot time in {\tt Time}.  

\ourmoditem{pt\_eval\_viewsys(+GoalList,+FileList,-Time,+FillList,+NProcs)}{pt\_eval\_viewsys/5}{persistent\_tables}
%
The predicate {\tt pt\_eval\_viewsys(+GoalList, +FileList, -Time,
  +FillList, +NProcs)} adds user files containing base tables to a
persistent tabling system and invokes the computing and filling of
dependent tables.  {\tt GoalList} is a list of subgoals that
correspond to the base tables of the view system. {\tt FileList} is
the corresponding list of files that contain the data for the base
tables.  They must be formated as the {\tt table\_persistent}
declarations of their corresponding subgoals specify.  {\tt Time} is a
variable that will be set to the timestamp, if the base goals of {\tt
  GoalList} contain time stamp arguments.  {\tt FillList} is a list of
persistently tabled subgoals to be filled (using {\tt pt\_fill/1/2}.)
{\tt NProcs} is an integer indicating the maximum number of processes
to use to evaluate the view system.  This predicate provides a simple
interface to {\tt pt\_add\_tables/3} and {\tt pt\_fill/2}.

\end{description}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual2"
%%% End: 
