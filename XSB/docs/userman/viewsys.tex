

\chapter{The {\tt viewsys} Package}{chapter:viewsys}

  \begin{center}
    {\Large {\bf By David S Warren}}
  \end{center}

The {\tt viewsys} package provides a powerful mechanism to support
tasks information is combined from different sources.  Views can be
constructed either from external data or from other views.  In this
way, a {\em View System} supports a DAG of views.

%Most simply a view
%is a file (or table) that is generated by a process applied to a
%set of input files.  
%A view that has no inputs is called a 'base
%view'.

More precisely we can think of a view as an abstracted data source --
say a web query or database query.  Base views are data sources from
outside the system.  A non-base view is a data source that is
determined (and computed) by its process applied to its input data
sources.  An example of a non-base view might consist of data from two
sources where information from one source may override that of another
source under certain conditions.

%The process should be idempotent, so normally it creates a
%new file (or table).  (The system does allow non-idempotent updates,
%but they may be problematic under some circumstances.)

A view system workflow ({\em ViewSys} for short) describes the names
of the views, their input views, the command to be run to generate a
view from its inputs, etc.  A particular {\em instance} of a ViewSys
is determined by the specific external data sources associated with
the base views of the ViewSys.  An {\em instance} of a Viewsys
designates the set of views constructed from a given set of (external)
base views at a given time.  It is useful to give names to such
instances, usually indicating the external source of the base data
sources.  
%Many view systems will have only one instance.

Another useful component of a view system is what is called a {\em
  consistency view}.  The purpose of a consistency view is to check to
see whether a regular view is 'consistent'.  The command for a
consistency view should return non-zero if the view instance is not
deemed to be consistent.
%
The view system will run consistency views where applicable and will
not use a view as input to another view that it supports if it is
deemed not consistemt.  A single view may have zero or more
consistency views associated with it.


\section{An Example}

Consider a situation in which we are collecting data from four
institutions of higher education and want to integrate that data into
a dataset that allows us to make coherent queries across the data from
all institutions.  We might want to answer questions about the
possibility of transferring classes between the schools, or perhaps
whether a student might take a class scheduled at one that would be
equivalent to one at another, if schedules don't conflict.

Say we have two community colleges, AJC and ACC, and two 4-year
colleges, UC and UD.  And we collect information from each of them
concerning, say, currently scheduled classes at their institutions.

To integrate data from all four institutions, we might create the
following view system:

\begin{verbatim}
    clnajc
ajc ------> ajc-cleaned--+
                         | comb2
    clnacc               |------>2-year-info--+
acc ------> acc-cleaned--+                    |
                                              |  comb24
    clnuc                                     |--------> 2-4-info
UC -------> uc-cleaned--+                     |
                        | comb4               |
    clnud               |------>4-year-info---+
UD -------> ud-cleaned--+
\end{verbatim}

For each raw-data input from an institution, we have a process to
``clean'' that data (indicated in the diagram by a name {\tt
  cln<inst>}), that generates a file (view) containing ``cleaned''and
``standardized'' data (indicated in the diagram by {\tt
  <inst>-cleaned}.)  Then we have a process, {\tt comb2}, that
combines the two cleaned community college datasets to create a view,
2-year-info; and another, {\tt comb4}, that combines the two cleaned
4-year college datasets to create the view, 4-year-info.  And finally,
we have a process, {\tt comb24}, that takes those two views and
generates a fully combined dataset (i.e., view), 2-4-info.

This viewsys system has 11 views, 4 of which are base views and 7
derived views.  And it has 7 processes, one to generate each derived
view.

We can imagine what these processes might do: the cleaning processes
would do institution-specific transformations of the input data, maybe
standardizing names of equivalent classes; inferring a new variable of
the level of the classe (intro, intermediate, advanced) from the class
naming/numbering conventions of the particular institution;
standardizing class-time representations given different scheduling
conventions; etc.  The {\tt comb<?>} processes might simply project
and union their inputs, but in the real world, they are more likely to
perform other more complex inferences and transformations.

We could easily imagine having other (mostly static) data inputs (not
shown here) to these cleaning processes that provide
institution-specific information necessary to do such transformations.
We can also imagine that we have another process that uses, say, the
2-year-info view, to combine it with other information we've gleaned
from 2-year colleges to provide another view that can answer other
questions of interest.

We can imagine that the datasets we get from the source institutions
arrive at different times but we want the best data in the coherent
eviews to be available to any query.  So if a new file from, say, {\tt
  UC}, shows up, we need only run the processes {\tt clnuc}, {\tt
  comb4}, and {\tt comb24} to be sure that all data is up to date.

\section{The ViewSys Data Model}

A ViewSys workflow is specified by a set of facts of the following
predicates.  Users should put the appropriate facts for these
predicates that define their view system into a file named {\tt
  viewsys\_view\_info.P}.

\subsubsection{View Framework Model}

For each view (base or derived), there is a {\tt view/6} fact that
describes it:

{\tt view(View,Type,ViewNameTemplate,[InputViews],[Opts],ShCmd)}
\noindent
where:

\begin{itemize}
\item {\tt View} is the name of the view;

\item {\tt Type} is {\tt file}, {\tt dir(<FileNames>)}, or {\tt
  table}.
%(or maybe in the  future db(...)?).  
<If it is {\tt file}, the view is stored in a file (that is generated
by the {\tt ShCmd}).  It {\tt dir(<FileNames>)} the view is stored in
multiple files in a directory.  {\tt <FileNames>} are the (relative)
names of the files that store the view in that directory
(instance). Finally, if the type is {\tt table}, the view is a
database table.

\item {\tt ViewNameTemplate} is the path template for where instance
  versions are stored.  This template string normally contains the
  pattern variable \$INSTANCE\$ which will be replaced by the instance
  name to obtain the name of an instance of this view.  (If the
  viewsys will have only one instance, the \$INSTANCE\$ variable is
  not required.)  
 
  A template may also contain user-defined pattern variables of the
  form \$USERVARNAME\$ where \$USERVARNAME\$ is any upper-case letter
  sequence (except those reserved for viewsys system variables.)
  User-defined pattern variable values are defined in facts of the
  form 

{\tt viewsys\_uservar(\$USERVARNAME\$,VarValueString)}.  

\noindent
When
  instantiated by an instance name and user-variable values, the
  template identifies the instance of the given view (e.g., a file,
  table or directory).

\item {\tt [InputViews]} is a list of the names of views that this
  view directly depends on, i.e., the inputs needed to generate this
  view.  This is an empty list for base views.  Normally these input
  view indicators are atoms for which there is another {\tt view/6}
  fact that describes it.  However, if that view generates a directory
  and the input to this view is a file in that directory, then that
  filename should be put as an argument to the view atom.  E.g., if
  the view, m\_view, generates a directory and several files in it and
  this view needs to use the file 'first\_file.P' from that directory,
  then the input view indicator in this list should be the term {\tt
    m\_view('first\_file.P')}.

\item {\tt [Opts]} is a list of options. The possible options are:

\begin{itemize}				       

\item {\tt split(N)} where {\tt N} is a positive integer.  This tells
  {\tt viewsys} to split the first input view file into {\tt N}
  subfiles; to run this command on each of those subfiles; and to
  concatenate all the resulting subfiles back together to get the
  output file for this view.  Of course, this is only appropriate for
  view commands for which this process gives the same answer as
  running it on the large unsplit file.  When the command satisfies
  this property, this option can allow the records in a large file to
  be processed in parallel.

  If this option is used, the user must first run {\tt
    expand\_views(ViewDir)} to generate a viewsys file that implements
  the splitting.  It will move the {\tt viewsys\_view\_info.P} file to
  {\tt viewsys\_view\_orig\_info.P} replace it with a modified version
  of the file that will drive the {\tt viewsys} processing.  (If the
  file {\tt viewsys\_view\_orig\_info.P} exists, the operation will
  indicate an error, in order to protect against inadvertantly
  overwriting the original {\tt viewsys\_view\_info.P} file.)

\end{itemize}				       

\item {\tt ShCmd} is the shell command to execute to generate the view
instance from its input view instances. (Ignored for base views.)  The
shell command can be in one of two forms:

\begin{enumerate}

\item a string containing metavariables of the form \$INP1\$, \$INP2\$,
..., and \$OUT\$, which will be replaced by the filenames of the input
view instance files/directories and the output view instance
file/directory, respectively; or

\item a string containing the metavariables \$INPUTFILES\$ and
\$OUTPUTFILE\$, which will be replaces with the sequence of input
filenames and the output filename, respectively, where each filename
is enclosed in double-quotes.  This is often appropreate for shell
commands.  If the shell string doesn't contain any of the
metavariables, then it is treated as if it were: <ShCmd> \$INPUTFILES\$
\$OUTPUTFILE\$'.

\end{enumerate}

\end{itemize}

User-defined syntactic variables can be used in filename templates and
in shell command templates to make it easier to define filenames and
commands.  The predicate {\tt viewsys\_uservar/2} is used to define
user variables, and facts for this predicate should be placed in the
{\tt viewsys\_view\_info.P} file.  For example, assume the user adds
the following facts to that file:

\begin{verbatim}
viewsys_uservar('$DATA_DIR$','C:/userfiles/project1/data').
viewsys_uservar('$SCRIPT_LIB$','c:/userfiles/project1/scripts').
\end{verbatim}

With these declarations in {\tt viewsys\_view\_info.P}, a file
template string could be of the form {\tt
  \$DATA\_DIR\$/data\_file\_13}, which after replacement of the
syntactic variable by its value would refer to the file
'C:/userfiles/project1/data/data\_file\_13'.  A shell command string
could be {\tt sh \$SCRIPT\_LIB\$/script\_cc.sh}, which after
replacements would cause the command {\tt sh
  c:/userfiles/project1/scripts/script\_cc.sh} to be run.  User
variables are normally defined at the beginning of the view file and
can be used to allow locations to be easily changed.  The value of a
user variable may contain another user variable, but, of course,
cycles are not permitted.

The user must define a uservar of \$STDOUTFILE\$ which is the filename
into which the stdout streams from the execution of a view generation
will be put.  The user should use the \$INSTANCE\$ and \$VIEW\$ variables
to make it unique for each output stream.

\paragraph{Consistency Views}

For each consistency view, there is a {\tt consView/5} fact:

\noindent 
{\tt consView(ConsViewName, CheckedViewName, FileTemplate, [Inputs], ShCmd)}

\noindent 
where

\begin{itemize}
\item {\tt ConsViewName} is the name of the consistency view.

\item {\tt ViewName} is the name of the view this view checks.

\item {\tt FileTemplate} is the template for the output file for this
consistency check.  This file may be used to provide information as to
why the consistency check failed (or passed.)

\item {\tt [InputViews]} is a list of parameter input views (maybe empty)

\item {\tt ShCmd} is the shell command the executes the consistency
check.  The inputs are the the filename containing the view instance
to be checked followd by the input view file instances.  The output is
the output file instance.  These parameters are processed similarly to
the processing for shell-commands for regular views.

\end{itemize}

\section{View Instance Model}

A ViewSys Instance is a particular instantiation of a ViewSys workflow
that is identified by a name, usually indicating the source of the
base views.  Of course, the files (directories) that contain instances
of views must all be distinct.

View instances are described by another set of facts, which are stored
in a file named {\tt viewsys\_instance\_info.P}.  Whereas the user is
responsible for creating the {\tt viewsys\_view\_info.P} file, viewsys
creates and maintains the {\tt viewsys\_instance\_info.P} file in
response to viewsys commands entered by the user.

For each view instance (base or derived), there is a {\tt viewInst/5}
fact:

\noindent viewInst(View,InstName,Status,Date,Began)
where:
\begin{itemize}

\item {\tt View} is the name of a view;

\item {\tt InstName} is the name of the instance;
	   
\item {\tt Status} is the status of this view instance
{\tt not\_generated}, {\tt being\_generated(ProcName)}, {\tt generated},
{\tt generation\_failed}. (For base view instances this is always
{\tt generated}.)

\item {\tt Date} is the date-time the view instance was generated.
%(Better? the filetime of the base view last used to regenerate view
%instances. 
%Not used for non-base views.)

\item {\tt Began} is the date-time at which the generation of this
view began.  (This is the same as Date above for base view instances.)
It is used to estimate how long it will take to generate this view
output given its inputs.

\end{itemize}

For each consistency view instance, there is a consViewInst/5 fact:

\noindent consViewInst(ConsViewName, InstName, Status, Date, Began)

\noindent 
where;

\begin{itemize}

\item {\tt ConsViewName} is the name of the consistency view.

\item {\tt Status} is this consistency view, same as for viewInst
status.

\item {\tt Date} is the date-time the check was generated.

\item {\tt Began} is the date-time at which the generation of this
view began.

\end{itemize}

The ViewSys relations, {\tt view/6}, {\tt consView/5}, and {\tt
  viewOrig/6}, are stored in the file named {\tt
  viewsys\_view\_info.P}.  It is read for most commands, but not
updated.  (Only {\tt expand\_views/1} generates this file from the
file namsd {\tt viewsys\_view\_orig\_info.P}.)  {\tt viewInst/5},
  and {\tt consViewInst/5} are stored in the file named {\tt
    vieewsys\_instance\_info.P}, and the directory containing these
    files is explicitly provided to predicates that need to operate on
    it.  The contents of the files are Prolog terms in canonical form.

A lockfile (named {\tt lock\_view} in the viewsys directory) is
obtained whenever these files are read, and it is kept until reading
and rewriting (if necessary) is completed.

\section{Using ViewSys}

The viewsys system is normally used as follows.  The user creates a
directory to hold the viewsys information.  She creates a file
{\tt viewsys\_view\_info.P} in this directory containing the desired
{\tt view/6}, and {\tt consView/5} facts that describe the desired
view system.  Then the user consults the viewsys.P package, and runs
{\tt check\_viewsys/1} to report any obvious inconsistencies in the
view system specified in the file {\tt viewsys\_view\_info.P}.  After
the check passes, if any views have the {\tt split(N)} option, the user
should copy the {\tt viewsys\_view\_info.P} file to a file named
{\tt viewsys\_orig\_view\_info.P} and then run {\tt expand\_views/1} to
generate the appropriate file {\tt viewsys\_view\_info.P} to contain
the views necessary to split, execute and combine the results.  This
will overwrite the {\tt viewsys\_view\_info.P} file.  (From then on,
should the viewsys need to be modified, the user should edit the
{\tt viewsys\_orig\_view\_info.P} file, and rerun {\tt expand\_views/1}
to regenerate the {\tt viewsys\_view\_info.P} file.)  The user will
then run {\tt generate\_view\_instance/2} to generate an instance (or
instances) of the view system into the file
{\tt viewsys\_instance\_info.P}.  After that the user will run
{\tt update\_views/4} to run the workflow to generate all the view
contents.  Then the user checks the generated logging to determine if
there were any errors.  If so, the user corrects the programs (the
viewsys specification, whatever), executes {\tt reset\_failed/2} and
reruns {\tt update\_views/4}.  The user can also use
{\tt viewsys\_status/1} to determine what the state of the view system
is, and to determine what needs to be fixed and what needs to be
rerun.  If the execution of {\tt update\_views/4} is aborted or
somehow does not complete, the user can run {\tt reset\_unfinished/2}
to reset the views that were in process, so that a subsequent
{\tt update\_views/4} will try to recompute those unfinished
computations.

\begin{description}

\ourmoditem{generate\_new\_instance(ViewSys,VInst)}
%%{generate\_new\_instance/2}
{view\_sys}
%
{\tt generate\_new\_instance(+ViewSys,+VInst)} creates a brand new
instance of the view system {\tt ViewSys} named {\tt VInst}.  It
generates {\tt new\ viewInst/5} facts for every view (base and
derived) according to the file templates defined in the {\tt
  baseView/4}, and {\tt view/6} facts of the ViewSys.  {\tt VInst} may
be a list of instance names, in which case initial instances are
created for each one.

\ourmoditem{update\_instance(ViewSys,VInst)}
%%{update\_instance/2}
{view\_sys}
{\tt update\_instance(+ViewSys,+VInst)} updates an instance of the
view system {\tt ViewSys} named VInst.  It is similar to
{\tt generate\_new\_instance/2} but doesn't change existing instance
records.  It generates a new {\tt viewInst/5} (or
{\tt consViewInst/5}) fact for every view (base and derived) that
does not already exist in the \\
{\tt viewsys\_instance\_info.P} file.  It
doesn't change instances that already exisit, thus preserving their
statuses and process times.  

\ourmoditem{delete\_instance(ViewSys,VInst)}
%%{delete\_instance/2}
{view\_sys}
%
{\tt delete\_instance(+ViewSys,+VInst)} removes an entire instance
from the view system.  Any files of view contents that have been
generated remain; only information concerning this instance in the
{\tt viewsys\_instance\_info.P} file is removed, so these view
instances are no longer maintained.

\ourmoditem{update\_views(ViewSys,ViewInstList,ProcName,NProcs)}
%%{update\_views/2}
{view\_sys}
{\tt update\_views(+ViewSys, +ViewInstList, +ProcName, +NProcs)} is
the predicate that runs the shell commands of view instances to create
view instance contents.  It ensures that most recent versions of the
view instances in {\tt ViewInstList} (and all instances required for those
views, recursively) are up to date by executing the commands as
necessary.  A view instance is represented in this list by a term
{\tt View:InstName}.  If {\tt ViewInstList} is the atom 'all', all
view instances will be processed.  This predicate will determine what
computations can be done concurrently and will use up to {\tt NProcs}
concurrent processes (using spawn\_process on the current machine) to
compute them.  {\tt ProcName} is a user-provided process namde that
used to identify this (perhaps very long-running) process; it is used
to indicate, in {\tt Ststus=being\_updated(ProcName)} that a view
instance is in the process of being computing by this update\_views
invocation.  {\tt reset\_unfinished/2} uses the name to identify the
view instances that a particular invocation of this process is
responsible for.  

\ourmoditem{start\_available\_procs(ViewSys,ViewInstList,ExecutingPids,ProcName,NProcs,Slp,OStr)}
%%{start\_available\_procs/7}
{view\_sys}
{\tt start\_available\_procs(+ViewSys, +ViewInstList, +ExecutingPids,
  +ProcName, +NProcs, +Slp, +OStr)} is an internal predicate that
supports the {\tt view\_update/4} processing.  It finds all views that
can be generated (or checked), starts processes to compute {\tt
  NProcs} of them, and then calls {\tt monitor\_running\_procs/7} to
monitor their progress and start more processes as these terminate.
This is an internal predicate, not available for call from outside the
module. The parameters to {\tt start\_available\_procs/7} are:

\begin{enumerate}

\item {\tt ViewSys} is the directory containing the
{\tt viewsys\_info.P} file describing the view system.

\item {\tt ViewInstList} is a) an explicit list of records of the form
{\tt View:Inst} identifying the (derived) views, normally 'root'
views, that are intended to be generated by the currently running
{\tt update\_view/4} invocation; or b) the constant 'all' indicating
that all view instances of the view system are intended to be
generated.

\item {\tt ExecutingPids} are pid records of the currently running
processes that have been spawned.  A pid record is of the form:
{\tt pid(Pid,ShCmd,SStr,FileOut,Datime, \linebreak[2] View,File,Inst)}, where

\begin{itemize}

\item {\tt Pid} is the process ID of the process (as returned by
{\tt spawn\_process/5}.)

\item {\tt ShCmd} is the shell command that was used to start the process.

\item {\tt SStr} is the output stream of the process's stdout and stderr file.

\item {\tt FileOut} is the name of the file connected to the stdout/stderr stream.

\item {\tt Datime} is the datime that the process was started.

\item {\tt View} is the view the process is generating.

\item @var(File) is the name of the output file to contain the
contents of the view instance.

\item {\tt Inst} is the instance of the view the process is generating.

\end{itemize}

\item {\tt ProcName} is the user-provided name of this entire update
process, and is used to mark views (in the
{\tt viewsys\_instance\_info.P} file) during processing so they can be
identified as associated to this view-update process if some error
occurs.

\item {\tt NProcs} is the number of 'processors' available for a
process to be scheduled on.  The 'processors' are virtual, and this is
used to control the maximum number of concurrently running processes.

\item {\tt Slp} is the number of seconds to sleep if no subprocess is
available for starting before checking again to see if some subprocess
has completed in the interim.

\item {\tt OStr} is the output stream used to write progress messages
when processes start and complete.

\end{enumerate}

\ourmoditem{monitor\_running\_procs(Pids,NProcs,ViewSys,VInstList,ProcName,Slp,OStr)}
%%{monitor\_running\_procs/7}
{view\_sys}
%
{\tt monitor\_running\_procs(+Pids, +NProcs, +ViewSys, +VInstList,
  +ProcName, +Slp, +OStr)} is an internal predicate that monitors
previously spawned running processes, calling {\tt
  start\_available\_procs/7} to spawn new ones when running processes
finish.

\begin{enumerate}

\item {\tt Pids} is the list of process IDs of running processes.
Each entry is a record of the form
{\tt pid(Pid,Cmd,StdStr,FileOut,Datime,View,File,Inst)} where:

\begin{itemize}

\item {\tt Pid} is the process ID of the process (as returned by
{\tt spawn\_process/5}.)

\item {\tt ShCmd} is the shell command that was used to start the process.

\item {\tt SStr} is the output stream of the process's stdout and stderr file.

\item {\tt FileOut} is the name of the file connected to the stdout/stderr stream.

\item {\tt Datime} is the datime that the process was started.

\item {\tt View} is the view the process is generating.

\item @var(File) is the name of the output file to contain the
contents of the view instance.

\item {\tt Inst} is the instance of the view the process is generating.

\end{itemize}

\item {\tt NProcs} is the number of 'processors' that are currently
available for use.  starrt\_available\_procs can start up to this number
of new processes.

\item {\tt ViewSys} is the viewsys directory;

\item {\tt VInstList} is the list of view instances (or 'all') that are
being updated by this execution of update\_views/4.;

\item {\tt ProcName} is the caller-provided name of this update
processor used to mark views that are being updated by this update
process; and

\item {\tt Slp} is the number of seconds to sleep if no process is
available for starting.

\item {\tt OStr} is the output stream for writing status messages;

\end{enumerate}

\ourmoditem{generate\_file\_from\_template(+FileTempl,+View,+Inst,-FileName)}
%%{generate\_file\_from\_template/4}
{view\_sys}
%
{\tt generate\_file\_from\_template(+FileTempl,+View,+Inst,-FileName)}
takes a file template string (with embedded \$\$ variable names), a view
name, {\tt View}, an instance name, {\tt Inst}, and replaces the
variable names with their values, returnning {\tt FileName}.

\ourmoditem{invalidate\_all\_instances(ViewSys)}
%%{invalidate\_all\_instances/1}
{view\_sys}
{\tt invalidate\_all\_instances(+ViewSys)} invalidates all views, so a
subsequent invocation of {\tt update\_views/4} would recompute them
all.  ).

\ourmoditem{invalidate\_view\_instances(ViewSys,ViewInstList)}
%%{invalidate\_view\_instances/2}
{view\_sys}
{\tt invalidate\_view\_instances(+ViewSys,+ViewInstList)} invalidates a
set of view instances indicated by {\tt ViewInstList}.  If
{\tt ViewInstList} is the atom 'all', this invalidates all instances
(exactly as {\tt invalidate\_all\_instances/1)} does.)  If
{\tt ViewInstList} is a list of terms of the form
{\tt View:VInst} then these indicated view instances (and all
views that depend on them) will be invalidated.  If {\tt ViewInstList}
is the atom 'filetime', then the times of the instance files will be
used to invalidate view instances where the filetime of some view
instance input file is later than the filetime of the view instance
output file.  Note this does not account for the time it takes to run
the shell command that generates the view output, so for it to work,
no view instance input file should be changed while a view instance is
in the process of being generated.

This predicate can be used if a base instance file is replaced with a
new instance.  It can be used if the contents of a view instance are
found not to be correct, and the generating process has been modified
to fix it.

\ourmoditem{reset\_unfinished(ViewSys,ProcName)}
%%{reset\_unfinished/2)}
{view\_sys}
{\tt reset\_unfinished(+ViewSys,+ProcName)} resets view instances that
are unfinished due to some abort, i.e., that are marked as
{\tt being\_generated(ProcName)} after the {\tt view\_update} process
named {\tt ProcName} is no longer running scripts to generate view
instances.  This should only be called when the {\tt ProcName}
{\tt view\_update} process is not running.  The statuses of these view
instances will be reset to {\tt not\_generated}.  After this, the next
applicable {\tt update\_views/4} will try to recreate these view
instances.

\ourmoditem{show\_failed(VSDir,VInst)}
%%{show\_failed(VSDir,VInst)}
{view\_sys}
{\tt show\_failed(+VSDir,+VInst)} displays each failed view
instance and consistency view instance, with file information to help
a user track down why the generation, or check, of the view failed.

\ourmoditem{reset\_failed(ViewSys,VInst)}
%%{reset\_failed/2}
{view\_sys}
{\tt reset\_failed(+ViewSys,+VInst)} resets view instances with name
{\tt VInst} that had failed, i.e., that are marked as
{\tt generation\_failed}.  Their status will be reset to
{\tt not\_generated}, so after this, the next applicable call to
{\tt update\_views/4} will try to regenerate the view.  If {\tt VInst}
is 'all', then views of all instances will be reset.  ).

\ourmoditem{check\_viewsys(ViewDir)}
%%{check\_viewsys/1}
{view\_sys}
%
  {\tt check\_viewsys(+ViewDir)} checks the contents of the {\tt
    viewsys\_view\_info.P} file of the {\tt ViewDir} viewsys directory
  for consistency and completeness.

\ourmoditem{viewsys\_view\_status(+ViewDir,+View:Inst,-Status)}
%%{viewsys\_view\_status/3}
{view\_sys}
{\tt viewsys\_view\_status(+ViewDir,+View:Inst,-Status)} returns the
Status of the indicated view in the indicated view instance.

\ourmoditem{viewsys\_status(+ViewDir)}
%%{viewsys\_status/1}
{view\_sys}
%
{\tt viewsys\_status(+ViewDir)} prints out the status of the view
system indicated in {\tt ViewDir} for all the options in {\tt
  viewsys\_status/2}.

\ourmoditem{viewsys\_status(+ViewDir,+Option)}
%%{viewsys\_status/2}
{view\_sys}
%
  {\tt viewsys\_status(+ViewDir,+Option)} prints out a particular list
  of view instance statuses as indicated by the value of {\tt option}
  as follows:

\begin{description}

\item{active:} View instances currently in the process of being
generated.

\item{roots:} Root View instances and their current statuses.  A root
view instance is one that no other view depends on.

\item{failed:} View instances whose generation has failed

\item{waiting:} View instances whose computations are waiting until
views they depend on are successfully update.

\item{checks\_waiting:} View instances that are waiting for consistency
checks to be executed.

\item{checks\_failed:} View instances whose checks have executed and
failed.

\end{description}

\ourmoditem{expand\_views(ViewSys)}{expand\_views/1}{view\_sys}
{\tt expand\_views(+ViewSys)}
processes view/6 definitions that have a split(N) option, generates
the necessary new view/6 facts to do the split, component processing,
and rejoin.  It overwrites the viewsys\_view\_info.P file, putting the
original view/6 facts into viewOrig/6 facts.  This must be called (if
necessary) when creating a new viewsys system and before calling
generate\_view\_instance/2.  ).

\ourmoditem{generate\_required\_dirs(+SubstList,+LogFiles)}{generate\_required\_dirs/2}{view\_sys}
%
This predicate can be used to help the user generate {\tt
  viewsys\_required\_file/1} facts that may help in configuration and
deployment of view systems.  It is not needed to create and run normal
view systems, only help configure the viewsys\_view\_info.P file to
support using {\tt copy\_required\_files/2} to move them for
deployment, when that is necessary.

{\tt generate\_required\_dirs(+SubstList,+LogFiles)} takes an
XSB\_LOGFILE (or list of XSB\_LOGFILEs), normally generated by running a
step in the view system, and generates (to userout)
viewsys\_required\_file/1 facts.  These can be edited and the copied
into the viewsys\_view\_info.P file to document what directories (XSB
code and general data files) are required for running this view
system.  The viewsys\_required\_file/1 facts are used by
copy\_required\_files/2 to generate a new set of files that can run the
view system.

This predicate can be called in one shell when {\tt update\_views/4}
is running in another shell.  This allows the user to monitor the
status a long-running invocation of {\tt update\_views/4}.

{\tt SubstList} is a list of substitutions of the form {\tt
  s(VarString,RootDir)} that are applied to @em{generalize} each
directory name.  For example if we have a large library file
structure, in subdirectories of {\tt C:/XSBSYS/XSBLIB}, the many
loaded files (in an {\tt XSB\_LOGFILE}) will start with this prefix,
for example,\\
{\tt C:/XSBSYS/XSBLIB/apps/app\_1/proc\_code.xwam}.
\\
By
using the substitution, {\tt s('\$DIR\$','C:/XSBCVS/XSBLIB')}, that
file name will be abstracted to: {\tt '\$DIR\$/apps/app\_1'} in the
{\tt viewsys\_required\_file/1} fact.  Then {\tt
  copy\_required\_files/2} can replace this variable {\tt \$DIR\$}
with different roots to determine the source and target of the
copying.

{\tt LogFiles} is an {\tt XSB\_LOGFILE}, that is generated by running
xsb and initially calling machine:stat\_set\_flag(99,1).  This will
generate a file named {\tt XSB\_LOGFILE.txt} (in the current
directory) that contains the names of all files loaded during that
execution of xsb.  (If the flag is set to @{tt}K > 1, then the name of
the generated file will be {\tt XSB\_LOGFILE\_<K>.txt} where {\tt <K>} is
the number {\tt K}.)

So, for example, after running three steps in a workflow, setting flag
99 to 2, 3, and 4 for each step respectively, one could execute:
\begin{verbatim}	   
| ?- generate_required_dirs([s('$DIR$','C:/XSBCVS/XSBLIB')],
                            ['XSB_LOGFILE_2.txt',
                             'XSB_LOGFILE_3.txt',
                             'XSB_LOGFILE_4.txt']).
\end{verbatim}	   

\noindent which would print out facts for all directories for files in
those LOGFILEs, each with the root directory abstracted.

\ourmoditem{copy\_required\_files(+VSDir,+FromToSubs)}
%%{copy\_required\_files/2}
{view\_sys}
%
This predicate can be used (perhaps with configuration help from {\tt
  generate\_required\_dirs/2}) to copy and deploy view systems and the
files they need to run.  This predicate is not needed for normal
execution of view systems.

{\tt copy\_required\_files(+VSDir,+FromToSubs)} uses the
{\tt viewsys\_required\_file/1} facts in the {\tt viewsys\_view\_info.P}
file in the {\tt VSDir} viewsys directory to copy all directories (and
files) in those facts.  {\tt FromToSubs} are terms of the form
{\tt s(USERVAR,FROMVAL,TOVAL)}, where {\tt USERVAR} is a variable in the
file templates in the {\tt viewsys\_required\_file/1} facts.  A
recusrive {\tt cp} shell command will be generated and executed for
each template in {\tt viewsys\_required\_file/1}, the source file being
the template with {\tt USERVAR} replaced by {\tt FROMVAL} and the target
File being the template with {\tt USERVAR} replaced by {\tt TOVAL}.

All necessary intermediate directories will be automatically created.

E.g.,
\begin{verbatim}
copy\_required\_files('.',[s('$DIR$','C:/XSBSYS/XSBLIB','C:/XSBSYS/XSBTEST/XSBLIB')]).
\end{verbatim}

\noindent would copy all files/directories indicated in the {\tt
  viewsys\_required\_file/1} facts in the local {\tt
  viewsys\_view\_info.P} file from under {\tt C:/XSB/XSBLIB} to a
(possibly) new directory {\tt C:/XSBSYS/XSBTEST/XSBLIB} (assuming all
file templates were rooted with {\tt $DIR$}


\end{description}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual2"
%%% End: 
