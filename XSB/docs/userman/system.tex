\chapter{System Description} \label{chap:system}
\label{system}

Throughout this chapter, we use \verb'$XSB_DIR' to refer to the
directory in which XSB was installed.

\section{Entering and Exiting XSB from the Command Line}
%=================================

After the system has been installed, the emulator's executable code appears 
in the file:
\begin{verbatim}
                     $XSB_DIR/bin/xsb
\end{verbatim}
If, after being built, XSB is later installed  at a central location,
\verb'$SHARED_XSB', the emulators executable code appears in
\begin{verbatim}
                     $SHARED_XSB/bin/xsb
\end{verbatim}
Either of these commands invokes XSB's top-level interpreter, which is
the most common way of using XSB.

XSB can also directly execute object code files from the command line
interface.  Suppose you have a top-level routine {\tt go} in a file
{\tt foo.P} that you would like to run from the UNIX or Windows
command line.  As long as {\tt foo.P} contains a directive, e.g. {\tt
  :- go.}, and {\tt foo.P} has been compiled to an object file ({\tt
  foo.xwam}), then
\begin{verbatim}
                     $XSB_DIR/bin/xsb foo
\end{verbatim}
will execute {\tt go} (and any other directives), loading the
appropriate files as needed~\footnote{In XSB, all extensions except
  '.pl' and '.prolog' --- (default '.P', '.H', '.xwam', '.D' (output by mode
  inferencing), and '.A' (assembly dump) --- are defined in C and
  Prolog code using macros in {\tt \$XSB\_DIR/emu/extensions\_xsb.h}
  and can be changed by a user if desired.  Of course, such a step
  should not be taken lightly, as it can cause severe compatibility
  problems.}.
%
In fact the command
\verb'$XSB_DIR/bin/xsb' is equivalent to the command:
\begin{verbatim}
             $XSB_DIR/bin/xsb -B $XSB_DIR/syslib/loader.xwam
\end{verbatim}
%%$
There is one other way to execute XSB from a command line.  Using the
{\tt -e} command-line option any goal can be can be executed, up to
1024 characters.  For instance 
\begin{verbatim}
             $XSB_DIR/bin/xsb -e "writeln('hello world'),halt."
\end{verbatim}
%%$
writes ``hello world'' and exits XSB.  Within the 1024 character
limit, any query or command can be executed, including consulting
files, so this method is actually quite general~footnote{Various
  options can suppress XSB's startup and end messages, as discussed
  below.}.

There are several ways to exit XSB.  A user may issue the
command \verb'halt.' or \verb'end_of_file.', or simply type
\verb'CTRL-d' at the XSB prompt.  To interrupt XSB
while it is executing a query, strike \verb'CTRL-c'.

\section{The System and its Directories}
%=======================================
When installed, the XSB system resides in a single directory that
contains several subdirectories.  For completeness, we review the
information in all subdirectories.  Normally, only the documentation
and files in the Prolog subdirectories, particularly {\tt examples},
{\tt lib}, and {\tt packages} will be of interest to users.
\begin{enumerate}
\item {\tt bin} contains scripts that call XSB executables
for various configurations.
%
\item {\tt build} contains XSB configuration scripts.  You may
already be familiar with the {\tt build} directory, which is used to
build XSB.
%
\item {\tt config} contains executables and other files specific to
particular configurations.
%
\item {\tt docs} contains the user manuals and other documentation,
including homepage sources.  
%
\item {\tt emu} contains the C source code for the XSB virtual
  machine, for I/O and for various interfaces.
%
\item {\tt etc} contains miscellaneous files used by XSB.
%
\item {\tt examples} contains some examples for Prolog, tabling,
HiLog and various interfaces.
%
\item {\tt cmplib} contains Prolog source and object code for the
compiler. 
%
\item {\tt gpp} contains a copy of the Gnu pre-processor used to
  preprocess Prolog files when they are compiled or dynamically
  loaded (i.e., loaded as dynamic code).
%
\item {\tt lib} contains Prolog source and object code for extended
librarie (cf. Section~\ref{library_utilities}). 
%
\item {\tt packages} The directory {\tt packages} contains various
  interfaces (e.g., {\tt sgml}, {\tt minizinc}, {\tt curl} and {\tt
    dbdrivers}); applications, such as {\tt chr}, {\tt pita} and {\tt
    cdf}. along with a number of other interfaces and applications.
  These packages are described in Volume 2 of this manual.
%
\item {\tt Prolog\_includes} contains include files for the Prolog
libraries, which are preprocessed using GPP.
%
\item {\tt syslib} contains Prolog source and object code for core XSB
libraries. 
\end{enumerate}

\noindent
All Prolog source programs are written in XSB, and all object (byte
code) files contain SLG-WAM instructions that can be executed by the
virtual machine.  These byte-coded instructions are
machine-independent, so usually no installation procedure is needed
for the byte code files.

If you are distributing an application based on XSB and need to cut
down space, the {\tt packages}, {\tt examples} and {\tt docs}
directories are not usually needed (unless of course you are using one
of the packages in your application).  {\tt lib} might not be needed,
(most core system files are in syslib) nor are Prolog source files
necessary if they have already been compiled into byte code.  Unless
your application needs to rebuild XSB, the {\tt emu} and {\tt build}
directories do not need to be distributed.

\section{How XSB Finds Files: Source File Designators}  \label{sec:filenames}
%
\index{base file name}
\index{source file designator}
Three files are associated with Prolog source code in
XSB~\footnote{Other types of files may be associated with foreign code
--- see Volume 2.}.
\begin{itemize}
\item A single {\it source} file, whose name is the {\em base file
  name} plus an optional extension suffix {\tt .P}, {\tt .pl}, or {\tt .prolog}.
\item An {\it object (byte-code)} file, whose name consists of the
  base file name plus the suffix {\tt .xwam}.
\item An optional {\it header} file, whose name is the base file name
  plus the suffix ``{\tt .H}''.  When used, the header file normally
  contains file-level declarations and directives while the source
  file usually contains the actual definitions of the predicates
  defined in that module.  However, such information can be
  equivalently put into the {\tt .P} ({\tt .pl}, or {\tt .prolog}) file.
\end{itemize}
%
Most of the XSB system predicates for compiling, consulting, and
loading code, such as {\tt consult/[1,2]}, {\tt compile/[1,2]}, {\tt
  load\_dyn\_gen/2} and others are somewhat flexible in how they
designate the file of interest.  Each of these predicates take as
input a {\em source file designator} which can be a base file name, a
source file name; or the relative or absolute paths to a base or
source file name.  Unfortunately, in \version{} there remain minor
differences in the ways in which the file designator can be indicated,
by different system predicates across different platforms.

In general, however, when given a source file designator, system
predicates perform {\em name resolution}.  There are two steps to name
resolution: determining the proper directory prefix and determining
the proper file extension.  When {\tt FileName} is absolute (i.e. it
contains a path from the file to the root of the file system)
determining the proper directory prefix is straightforward.  If {\tt
  FileName} is relative, i.e. it contains a {\tt '/'} in Unix or
\verb|\| in Windows, {\tt FileName} is expanded to a directory prefix
in an OS-dependent way, resolving symbols like {\tt '.'}, {\tt '..'}
and {\tt '\~{}'} when applicable.  However, the user may also enter a
name without any directory prefix. In this case, XSB tries to
determine the directory prefix using a set of directories it knows
about: those directories in the on-demand loader path (see
Section~\ref{LibPath}).  As it searches through directory prefixes,
different forms of the file name may be checked.  If the source file
designator has no extension the loader first checks for a file in the
directory with the {\tt .P} extension, (or {\tt .c} for foreign
modules); next checks for a file without the extension; and finally
checks for a file with a {\tt .pl} or {\tt .prolog} extension.  Note
that since directories in the on-demand loader path are searched in a
predetermined order (see Section~\ref{LibPath}), if the same file name
appears in more than one of these directories, the first one
encountered will be used.

\input{module_system} 


\section{Standard Predicates in XSB} \label{sec:standard}
%========================================================

Whenever XSB is invoked, a large set of {\em standard} predicates are
defined and can be called from the command-line interpreter or other
interface~\footnote{Such predicates are sometimes called ``built-ins''
  in other Prologs.}.  These predicates include the various ISO
predicates~\cite{ISO-Prolog}, along with predicates for tabling, I/O,
for interaction with the operating system, for HiLog, and for much
other functionality.  Standard predicates are listed in this manual
under the index heading {\em Index of Standard Predicates} and at an
implementation level are declared in the file {\tt
  \$XSB\_DIR/syslib/std\_xsb.P}.

If a user wishes to redefine a standard predicate, the compiler option
{\tt allow\_redefinition} can be used
(Section~\ref{sec:CompilerOptions}).  If a user wants to make a new
definition or new predicate standard, the safest course is to put the
predicate into a module in the {\tt lib} directory, then add or modify
an associated fact in {\tt \$XSB\_DIR/syslib/std\_xsb.P}.

%========================================================
\section{The On-Demand Loader and its Search Path} \label{LibPath}
\index{load search path}

XSB differs from some other Prolog systems in its ability to lazily
load modules on demand.  In XSB, the loading of user modules and
Prolog libraries (such as the XSB compiler) is delayed until
predicates in them are actually needed, saving program space for large
Prolog applications. On-demand loading is done by default, unlike other
systems where it is not the default for non-system libraries.

When a predicate imported from another module (see
Section~\ref{Modules}) is called during execution, the on-demand
loader is invoked automatically if the module is not yet loaded into
the system, The default action of the on-demand loader is to search for
the byte code file of the module first in the system library
directories (e,g,, {\tt lib, syslib, cmplib} others), and finally in
the current working directory.  The exact directories and their order
can be found by backtracking through the query:

\demo{loader:library\_directory(Dir)}

If the module or file is found in one of these directories, then it
will be loaded ({\em on a first-found basis}). Otherwise, an existence
error will be displayed on the current error stream reporting that the
module or file was not found.

%Because system modules are dynamically
%loaded, the time it takes to compile a file is slightly longer the
%first time the compiler is invoked in a session than for subsequent
%compilations.


\predrefindex{library\_directory/1}
\index{environment variables!{\tt XSB\_USER\_AUXDIR}}
\subsection{Changing the Default Search Path} \label{sec:search-path}
%=========================================================
%\begin{description}
%\repeatstandarditem{add\_lib\_dir(+Directories)}{consult}
%\standarditem{add\_lib\_dir(+Root,+Directories)}{consult}
%\end{description}
The default search path of the on-demand loader is based on the
dynamic predicate {\tt library\_directory/1} so it can easily be
changed.  For instance, to make sure a user's home directory is
loaded, the goal \verb|add_lib_dir(('~/'))| needs to be executed from
the
%\verb|assert(library_directory('~/'))| needs to be executed from the
command line or from within a program (of course if the user's home
directory is the current working directory, this is not necessary).
If you always want XSB to search particular directories, the easiest
way is to have a file named {\verb|.xsb/xsbrc.P|} in your home
directory.  (Or, if the environment variable
\texttt{XSB\_USER\_AUXDIR} is set then
       {\verb|$XSB_USER_AUXDIR/xsbrc.P|} is used.)  User-supplied
       library directories are searched by the on-demand loader {\em
         before} searching the default library directories.  The
       {\verb|.xsb/xsbrc.P|} file, which is automatically consulted by
       the XSB interpreter, might look like the following:
\begin{verbatim}
             :- add_lib_dir(('~/')).
             :- add_lib_dir(('/usr/lib/xsbprolog')).
\end{verbatim}

%The recommended way to add directories to the {\tt
%  library\_directory/1} predicate is to use the standard predicate
%{\tt add\_lib\_dir/1} or {\tt add\_lib\_dir/2}.

\begin{description}
\repeatstandarditem{add\_lib\_dir(+Directories)}{add\_lib\_dir/1}
\standarditem{add\_lib\_dir(+Root,+Directories)}{add\_lib\_dir/1}
%
The standard predicate {\tt add\_lib\_dir(Directories)} adds the
directories of {\tt Directories} to the system predicate {\tt
  library\_directory/1}.  {\tt Directories} is either a single
directory name or a comma-list of directory names.  A directory name
may be an atom or a simple structure of the form {\tt a(DirName)}
which indicates that the directory {\tt DirName} should be added as
the first directory in the {\tt library\_directory/1} facts; otherwise
it will be added as the last directory.  

The standard predicate {\tt add\_lib\_dir(+Root,+RelativeDirectories)}
concatenates the directory indicated by {\tt Root} to each of the
relative directory names in (the comma-list) {\tt RelativeDirectories}
and adds them all to {\tt library\_directory/1}.

In \verb|add_lib_dir(('~/'))| in the example above, note that the
``extra parentheses'' are needed since {\tt add\_lib\_dir/1} takes a
single argument, here a comma-pair.  Also the trailing slash in a
directory name is optional.

For example, to add two XSB library directories from a set of
libraries stored under a particular directory containing all XSB
libraries, one might do:
\begin{verbatim}
:- add_lib_dir('/usr/lib/xsb_libs', (string_lib,table_lib)).
\end{verbatim}

(Note that the necessary slash-separators are automatically added if
necessary.) 

If {\tt Root} is a term of the form {\tt ancestordir(DirFileName)}
where {\tt DirFileName} is an atom, the system will search up from the
current directory to find a containing directory named {\tt
  DirFileName}, and the full pathname of that directory will be
considered as the {\tt Root} directory.  This can be used to help in
making XSB code less dependent at compile-time on the exact full
filename of XSB code files, and allowing directories of libraries to
be moved.
\end{description}

\index{xsbrc.P initialization file} 
\subsubsection{A user's configuration file: {\tt xsbrc.P}}

Returning to the previous example, executing the two directives causes
the user's home directory to be searched first, then {\tt
  "/usr/lib/xsbprolog/"}, then XSB's system library directories, and
finally the current working directory.  Although these directives
byexecuting the directives at the command line or by loading a file
with these directives, it can also be performed automatically whenever
XSB is started by using an {\tt .xsb/xsbrc.P} file.

%Xsb also uses {\tt library\_directory/1} for internal
%purposes.  
This file works as follows.  Before the user's {\verb|.xsb/xsbrc.P|}
is consulted, XSB puts both the {\tt packages} directory and the
directory \verb|.xsb/config/$CONFIGURATION| on the library search
path.  The directory \verb'.xsb/config/$CONFIGURATION' is used to
store user libraries that are machine or OS
dependent. (\verb'$CONFIGURATION' for a machine is something that
looks like {\tt i386-apple-darwin19.6.0} or {\tt pc-linux-gnu}, and is
selected by XSB automatically at run time).  These
configuration-specific directories are useful to maintain a user's
OS-dependent XSB code for foreign-language modules, or scripts that
make heavy use of {\tt shell/[1-3]}.

If a user wished, say, to search the current working directory {\em
  before} her home directory, she could simply add
\begin{verbatim}
             :- add_lib_dir(a('./')).
\end{verbatim}
to her {\verb|.xsb/xsbrc.P|} file (or anywhere else).  The file
{\verb|.xsb/xsbrc.P|} is not limited to setting the library search
path.  In fact, arbitrary Prolog code can go there so that XSB can be
initialized in any manner desired.

We emphasize that in the presence of a {\verb|.xsb/xsbrc.P|} file {\em
it is the user's responsibility to avoid module name clashes with
modules in XSB's system library directories}.  Such name clashes can
cause unexpected behavior as system code may try to load a user's
predicates.  The list of module names in XSB's system library
directories can be found by looking through the directories {\tt
\$XSB\_DIR/\{syslib,cmplib,lib\}}.

\subsection{The Packaging System}
\index{packages} Apart from the user libraries, XSB also has a simple
packaging system.  A {\em package\/} is an application consisting of
one or more files that are organized in a subdirectory of one of the
XSB system or user libraries.  The system directory
\verb|$XSB_DIR/packages| has a number of examples
%%$
of such packages, many of which are documented in Volume 2 of this
manual, or contain their own manuals.  Packages are convenient
as a means of organizing large XSB applications, and for simplifying
user interaction with such applications.  User-level packaging is
implemented through the predicate
%%
\begin{description}
  \ourmoditem{bootstrap\_userpackage(+LibraryDir, +PackageDir, +PackageName)}{bootstram\_userpakage/3}{packaging}
\end{description}
%%
To illustrate the use of this predicate suppose you wanted to create a
package, {\tt foobar}, inside your own library, {\tt my\_lib}. Here is
a sequence of steps you can follow:
%%
\begin{enumerate}
\item Make sure that {\tt my\_lib}\ is on the library search path by putting
  an appropriate assert statement in your {\tt xsbrc.P}.
\item Make a subdirectory \verb|~/my_lib/foobar| and organize all the
  package files there. Designate one file, say, {\tt foo.P}, as the
  entry point, {\it i.e.}, the application file that must be loaded first.
\item Create the interface program \verb|~/my_lib/foobar.P| with the
  following content:
    %%
    \begin{verbatim}
   :- bootstrap_userpackage('~/my_lib', 'foobar', foobar), [foo].
    \end{verbatim}
    %%
  The interface program and the package directory do not need to have the
  same name, but it is convenient to follow the above naming schema.
\item Now, if you need to invoke the {\tt foobar} application, you can
  simply type \verb|[foobar].| at the XSB prompt. This is because both and
  \verb|~/my_lib/foobar| have already been automatically added to the
  library search path.
\item If your application files export many predicates, you can
  simplify the use of your package by having \verb|~/my_lib/foobar.P|
  import all these predicatesand then export them, renaming them if
  desired (see the discussion of {\tt import ... as} in
  Section~\ref{Modules}).  This provides a uniform interface to the
  {\tt foobar} module, since all the package predicates can now be
  imported from just one module, {\tt foobar}.
\end{enumerate}
%%
In addition to adding the appropriate directory to the library search
path, the predicate \verb|bootstrap_userpackage/3| also adds
information to the predicate

\demo{package\_configuration/3}

\noindent
so that other applications could query information about loaded
packages.

\begin{description}
\ourmoditem{unload\_package(+Package)}{unload\_package/1}{packaging}
%%
Can be used to unload {\tt Package}.  For instance,

\begin{verbatim}
       :- unload_package(foobar).  
\end{verbatim}
%%
removes the directory \verb|~/my_lib/foobar| from the library search
path and deletes the associated information from
\verb|package_configuration/3|.
\end{description}
\index{packages!\texttt{unload\_package/1}}
\index{packages!\texttt{package\_configuration/2}}

Finally, if you have developed and tested a package that you think is
generally useful and you would like to distribute it with XSB, please
contact {\tt xsb-development@sourceforge.net}.


\section{Command Line Arguments} \label{sec:EmuOptions}
%========================================================
\index{emulator!command line options}
\index{options!command line arguments}
\index{stacks!default sizes}
\index{stacks!expanding}
%========================================================

There are several command line options for the emulator. The general 
synopsis obtained by the command {\tt \$XSB\_DIR/bin/xsb --help} is: 
\index{tabling!call subsumption}
{\small 
\begin{verbatim}
xsb [flags] [-l] 
xsb [flags] module
xsb [flags] -B boot_module [-D cmd_loop_driver] [-t] 
xsb [flags] -B module.suffix -d
xsb [-h | -v | --help | --version]

module:
    Module to execute after XSB starts up.
    Module should have no suffixes, and either be an absolute pathname
    the file module.xwam must be on the library search path.
boot_module:
    This is a developer's option.
    The -B flags tells XSB which bootstrapping module to use instead
    of the standard loader.  The loader must be specified using its
    full pathname, and boot_module.xwam must exist.
module_to_disassemble:
    This is a developer's option.
    The -d flag tells XSB to act as a disassembler.
    The -B flag specifies the module to disassemble.
cmd_loop_driver:
    The top-level command loop driver to be used instead of the
    standard one.  Usually needed when XSB is run as a server.

                 -B : specify the boot module to use in lieu of the standard loader
                 -D : Sets top-level command loop driver to replace the default
                 -t : trace execution at the SLG-WAM instruction level
                       (for this to work, build XSB with the --debug option)
                 -d : disassemble the loader and exit
      -v, --version : print the version and configuration information about XSB
         -h, --help : print this help message

Flags: 
               -e goal : evaluate goal when XSB starts up
                    -p : enable Prolog profiling through use of profile_call/1
                    -l : the interpreter prints unbound variables using letters
            --nobanner : don't show the XSB banner on startup
           --quietload : don't show the `module loaded' messages
            --noprompt : don't show prompt (for non-interactive use)
                    -S : set default tabling method to call-subsumption
 --max_subgoal_size  N : set maximum tabled subgoal size to N (default is maximum integer)
--max_subgoal_action A : set action on maximum subgoal depth: e(rror)/a(bstract)/w(arn)
         --max_tries N : allow up to N tries for interning terms
            -g gc_type : choose heap garbage collection ("indirection" or"none")
           -c N [unit] : initially allocate N units (default KB) for the trail/choice-point stack
           -m N [unit] : initially allocate N units (default KB) for the local/global stack
           -o N [unit] : initially allocate N units (default KB) for the SLG completion stack
                   unit: k/K memory in kilobytes; m/M in megabytes; g/G in gigabytes
                    -r : turn off automatic stack expansion
                    -T : print a trace of each called predicate

\end{verbatim}
}
%   --shared_predicates : make predicates thread-shared by default
%       --max_threads N : maintain information for up to N threads (MT engine only)
%       --max_mqueues N : allow up to N message queues (MT engine only)

%\paragraph*{Flags}

\index{scripting}
\subsection{General Options}
The order in which options appear makes no difference.
\begin{description}
\item[{\tt -e goal}] Pass {\tt goal} to XSB at startup. This goal is
  evaluated right before the first prompt is issued. For instance,
  \verb'xsb -e "write('Hello!'), nl."'  will print a heart-warming
  message when XSB starts up.  Since {\tt goal} can be any
  command-line goal (including a conjunction or disjunction of other
  goals, including {\tt halt}, this option serves as a convenient way
  to use XSB in scripts, or for scripting, particularly in combination
  with some of the following options.
%
\item[{\tt -p}] Enables the engine to collect information that can be
  used for profiling.  See Section~\ref{sec:profile} for details.
%
\item[{\tt -l}] Forces the interpreter to print unbound variables as
	letters, as opposed to the default setting which prints
	variables as memory locations prefixed with an underscore.
	For example, starting XSB's interpreter with this option will
	print the following:
        \begin{verbatim}
                  | ?- Y = X, Z = 3, W = foo(X,Z).

                  Y = A
                  X = A
                  Z = 3
                  W = foo(A,3)
	\end{verbatim}
	as opposed to something like the following:
	\begin{verbatim}
                  | ?- Y = X, Z = 3, W = foo(X,Z).

                  Y = _h118
                  X = _h118
                  Z = 3
                  W = foo(_h118,3);
	\end{verbatim}
  \item[{\tt --nobanner}] Start XSB without showing the startup banner.
    Useful in batch scripts and for interprocess communication (when XSB is
    launched as a subprocess).  For instance, 
\begin{verbatim}
 xsb -e "writeln('hello world'),halt."
[xsb_configuration loaded]
[sysinitrc loaded]

XSB Version 3.1 (Incognito) of August 10, 2007
[i386-apple-darwin8.9.1; mode: optimal; engine: slg-wam; scheduling: local; word size: 32]


Evaluating command line goal:  
| ?-  writeln('hello world'),halt.

| ?- hello world

End XSB (cputime 0.02 secs, elapsetime 0.02 secs)
\end{verbatim}
Prints out quite a bit of verbiage.  Using the {\tt --nobanner} option
reduces this verbiage somewhat.
\begin{verbatim}
xsb --nobanner -e "writeln('hello world'),halt."
[xsb_configuration loaded]
[sysinitrc loaded]

Evaluating command line goal:  
| ?-  writeln('hello world'),halt.

| ?- hello world
\end{verbatim}
%
 \item[{\tt --quietload}] Do not tell when a new module gets
   loaded. Again, this option is useful in non-interactive activities
   and for interprocess communication.  Continuing our example:
\begin{verbatim}
xsb --quietload --nobanner -e "writeln('hello world'),halt."
| ?- 
| ?- hello world
\end{verbatim}
%
  \item[{\tt --noprompt}] Do not show the XSB prompt.
%
\item[{\tt --nofeedback}] Do not print the feedback messages such as
  ``yes'' and ``no'' after queries.
    This and the \texttt{--noprompt} options are useful only in batch
    mode and in interprocess communication when you do not want the prompt
    to clutter the picture.  Putting all this together, we finally get: 
\begin{verbatim}
xsb --noprompt --quietload --nobanner --nofeedback -e "writeln(hello),halt."

hello world
\end{verbatim}
So that XSB can be used to write reasonable scripts, or used as a subprocess.
%\item[{\tt --max\_threads N}] Allows XSB to maintain information for
%  up to {\tt N} threads.  This means that XSB can currently run {\tt
%    N} threads that are active, or that are inactive, non-detached,
%  and not yet joined.  Has no effect if the engine has been configured
%  without multi-threading.
\item[{\tt -D}] Tells XSB to use a top-level command loop driver specified
  here instead of the standard XSB interpreter. This is most useful when
 XSB is used as a server.
\index{tabling!call subsumption}
\item[{\tt -S}] Indicates that tabled predicates are to be evaluated
  using subsumption-based tabling as a default for tabled predicates
  whose tabling method is not specified by using

  {\tt table Predspec as subsumptive}

or 

{\tt table Predspec as variant}
  
\noindent
  (see Section \ref{sec:TablePred:Decl&Mod}).  If this
  option is not specified, variant-based tabling will be used as the
  default tabling method by XSB\@.  \index{shared\_predicates}
%\index{tabling!shared}
%\item[{\tt --shared\_predicates}] In the multi-threaded engine, makes
%    all predicates thread-shared by default; has no effect in the
%    single-threaded engine.
  %
%
%\item[{\tt --max\_subgoal\_size} {\em N}] : set maximum tabled subgoal
%  size to {\em N} (default is maximum integer).  This flag sets the
%  size of a tabled subgoal upon which an action may be taken (such as
%  throwing an error, abstracting, or issuing a warning.
%%
%\item[{\tt --max\_subgoal\_action} {\em A}] : set action on maximum
%  subgoal depth: e(rror)/a(bstract)/w(arn)
\end{description}
%
%\end{description}
\subsection{Other Command-line Options}
%
These options tend to be most useful for developers, and are not needed by most users.

\subsubsection{Memory Management Options} \label{sec:memory-flags}

\begin{description}
\index{garbage collection}
\item[{\tt -g gc\_type}] Chooses the heap garbage collection strategy
  that is employed; choice of the strategy is between the default {\tt
    indirection}  or {\tt
    none}. See \cite{CaSC01} for a description of the indirection
  garbage collector.
\end{description}
%; {\tt copying}, which is not fully supported;
%, and \cite{CATmem@ISMM-98} for the copying garbage
%  collector.
%
The following memory management flags should rarely need to be used by
non-developers since XSB's memory management has been quite stable for
a number of years.

\begin{description}
\item[{\tt -r}] Turns off automatic stack expansion.  This can
  occasionally be useful for isolating memory management problems.
  (Usually when working with XSB developers.)  This command-line
  argument is obsolescent, since XSB has moved towards the use of
  Prolog flags as a uniform interface for session control.

\item[{\tt -c} {\em size [units]}] Allocates {\em initial size\/}
  units of space to the trail/choice-point stack area.  The trail
  stack grows upward from the bottom of the region, and the choice
  point stack grows downward from the top of the region.  If units is
  not provided or is {\tt k} or {\tt K}, the size is allocated in
  kilobytes; if {\tt m} or {\tt M} in megabytes; and if {\tt g} or
  {\tt G} in gigabytes.  Because this region is expanded
  automatically, this option is rarely needed.
%  If this option is not
%  specified a default initial size is used; this size may differ for
%  the single-threaded and multi-threaded engine.
%
\item[{\tt -m} {\em size [units]}] Allocates {\em initial size\/}
  units of space to the local/global stack area.  The global stack
  grows upward from the bottom of the region, and the local stack
  grows downward from the top of the region.  If units is not provided
  or is {\tt k} or {\tt K}, the size is allocated in kilobytes; if
  {\tt m} or {\tt M} in megabytes; and if {\tt g} or {\tt G} in
  gigabytes.  Because this region is expanded automatically, this
  option is rarely needed.
%  If this option is not
%  specified a default initial size is used; this size may differ for
%  the single-threaded and multi-threaded engine.
%
\item[{\tt -o} {\em size [units]}] Allocates {\em initial size\/}
  units of space to the completion stack area.  If units is not
  provided or is {\tt k} or {\tt K}, the size is allocated in
  kilobytes; if {\tt m} or {\tt M} in megabytes; and if {\tt g} or
  {\tt G} in gigabytes.  Because this region is expanded
  automatically, this option is rarely needed.
%  If this option is not
%  specified a default initial size is used; this size may differ for
%  the single-threaded and multi-threaded engine.

%
% \item[{\tt -u} {\em size [units]}] Allocates {\em initial size} KBytes of
%   space to the unification (and table copy) stack.  If units is not
%   provided or is {\tt k} or {\tt K}, the size is allocated in
%   kilobytes; if {\tt m} or {\tt M} in megabytes; and if {\tt g} or
%   {\tt G} in gigabytes.  Default 64 KBytes.  (This option is rarely
%   needed.)
%
%\item[{\tt -i}] Brings up the XSB interpreter.  This is the normal
%  use, and the option is kept only for backward compatibility.
%
%\item[{\tt -n}] Formerly used in conjunction when XSB was called from
%  C.  This option is used only for backward compatibility.
\end{description}

\subsubsection{Options for Developers}
\begin{description}
\item[{\tt -d}] Produces a disassembled dump of {\tt byte\_code\_file} to 
    {\tt stdout} and exits.
  \item[{\tt -t}] Traces through code at SLG-WAM instruction level.
  This option is intended for developers and is not fully supported.
  It is also not available when the system is being used at the
  non-debug mode (see Section~\ref{debugging}).
\item[{\tt -T}]
    {\em This flag is rarely used}

    Generates a trace at entry to each called predicate
    (both system and user-defined).  This option is available mainly
    for people who want to modify and/or extend XSB, and it is
    {\em not\/} the normal way to trace XSB programs.  For the
    latter, the standard predicates {\tt trace/0} or {\tt debug/0}
    should be used (see Chapter~\ref{debugging}).
    Note: This option is not available when the system is being used
    at the non-tracing mode (see Section~\ref{debugging}).

\end{description}

\section{Memory Management}\label{memory_management}
\index{memory management} \index{garbage collection}
%===================================================

Memory management in \version{} of XSB is quite sophisticated due to
the demands of tables, interned terms, dynamic code ... not to mention
those of Prolog itself.  Fortunately, XSB's memory management almost
always is stable and ``does the right thing''.  However, in uncommon
instances, these settings may need to be adjusted by users who push
XSB to its limits. \footnote{You know who you are.}

All execution stacks are automatically expanded in \version{},
including the local stack/heap region, the trail/choice point region,
and the completion stack region.  Execution stacks increase their size
(usually by doubling) until it is not possible to do so with available
system memory.  At that point XSB tries to find the maximal amount of
space that will still fit in system memory.  For the main thread, it
is almost always sufficient simply to use the default value, but each
of these regions can be initialized to a value set by the user at the
command-line or with a default value (see Section~\ref{sec:EmuOptions}). 
%When a thread is created within an XSB
%process, the size of the thread's execution stacks may be set by {\tt
%  thread\_create/3}, otherwise the default values indicated in
%Section~\ref{sec:EmuOptions} are used.
%Once XSB is running, these
%default values may be modified using the appropriate Prolog flags (see
%Section~\ref{State}).
%In addition, whenever a thread exits, memory
%specific to that thread is reclaimed.

\predrefindex{gc\_heap/0}
\predrefindex{gc\_atoms/0}
%
Heap garbage collection is automatically performed in XSB
\cite{CaSC01,CATmem@ISMM-98}.  Heap garbage collection in XSB is quite
stable, but might need to be turned off if you are making use of some
of the newest features of XSB.  This can be done via the Prolog flag
{\tt heap\_garbage\_collection/1} (Section~\ref{State}) or the
command-line option {\tt -g} (Section~\ref{sec:EmuOptions}).  In
\version{} the default behavior is indirect garbage collection, which
can be forced via {\tt gc\_heap/0}.  Heap garbage collection
automatically invokes garbage collection of XSB's atom table, which
stores Prolog's atomic constants.  Atom
garbage collection can be turned off by itself using the Prolog flag
{\tt atom\_garbage\_collection} (Section~\ref{State}) and forced via the
command {\tt gc\_atoms/0}.
%Expansion and garbage collection of execution stacks can occur when
%multiple threads are active; however atom garbage collection will not
%be invoked if there is more than one active XSB thread.

\index{garbage collection!dynamic clauses}
\predrefindex{gc\_dynamic/1}
The program area (the area into which XSB byte-code is loaded) is also
automatically expanded as needed.  For dynamic code (created using
{\tt assert/1}, or standard predicates such as {\tt load\_dyn\_gen/3}
and friends) index size is also automatically reconfigured.  Space
reclaimed for dynamic code depends on several factors.
%If there is only one active thread,
Space is reclaimed for retracted clauses and abolished predicates as
long as (1) there are no choice points that may backtrack into the
retracted or abolished code, and (2) if the dynamic predicate is
tabled, all of its tables are completed.  Otherwise, the code is
marked for later garbage collection.  This behavior can be turned off
by the Prolog flag {\tt clause\_garbage\_collection}
(Section~\ref{State}). \footnote{In \version{} this garbage collector
  appears to be slightly less stable than the others, particularly if
  the dynamic code has many different indexes set for it.}.  Clause
garbage collection can also be forced via the predicate {\tt
  gc\_dynamic/1} (Section~\ref{sec:assert}).
%If more than one thread is active, private predicates behave as just
%described, however space reclamation for shared predicates will be
%delayed until there is a single active thread.  See
%Section~\ref{sec:assert} for details.

\index{garbage collection!tables}
\predrefindex{gc\_tables/1}
Space for tables is automatically allocated as needed and reclaimed
through use of {\tt abolish\_all\_tables/0}, {\tt
  abolish\_table\_pred/1}, {\tt abolish\_table\_call/1} and other
predicates.  As with dynamic code, space for tables may be reclaimed
immediately or marked for later garbage collection depending on
whether choice points may backtrack into the abolished tables,
% on the number of active threads,
etc.  Tabling also includes various stacks used to copy information
into or out of tables, most of which are automatically allocated and
expanded.
%These stacks may be
%thread-private or shared among threads: space for thread-private
%stacks is reclaimed when a thread exits.
See Section~\ref{sec:TablePred:Deleting} for details.



\index{Prolog flags!{\tt max\_memory}} \predref{bounded\_call/4}
Perhaps more than a standard Prolog system, XSB is used to evaluate
queries in knowledge representation languages that have a higher level
of declarativity than Prolog and as a result may consume a great deal
of space.  If XSB needs memory that is unobtainable from the operating
sytsem, it will usually abort with a resource error, and become ready
for a new query from its command line or API.  In such a case, a user
or program can use {\tt statistics/[0,1,2]} to investigate whether and
how XSB is consuming memory.  Other options to bounding memory include
the use of {\tt bounded\_call/4} or the use of the {\tt max\_memory}
flag.  Use of the {\tt max\_memory} flag is recommended in cases where
XSB is embedded in a C program through the C/XSB interface, or is
embedded in or communicating with a java program through InterProlog.
In such a case, XSB will abort with a resource error whenever a memory
allocation would exceed the user-defined threshold~\footnote{In rare
  cases, XSB will exit if the inability to allocate more memory will
  leave it in an inconsistent state (e.g. if XSB cannot allocate
  needed memory during heap garbage collection).}.  Using this option
can ensure that the calling program will have enough memory to handle
the resource error and continue.

\section{Compiling, Consulting, and Loading} \label{Consulting}
%====================================================
Like other Prologs, XSB provides for both statically compiled code and
dynamically asserted code (or dynamically loaded code).  Both types of
code have advantages, as discussed further in
Section~\ref{sec:dynamic-code}.  On the one hand, static compiled code
may be more optimized than asserted code, particularly for clauses
that have large bodies; on the other hand, certain types of indexing,
such as trie and star indexing are (currently) available only for
dynamically asserted predicates (see {\tt index/2}).

\subsection{Static Code}
%
In XSB, there is no difference between compiled and consulted static
code: ``compiling'' in XSB means creation of a file containing SLG-WAM
byte-code; ``consulting'' means loading such a byte-code file, after
compiling it (if the source file was altered later than the object
file).

\begin{description}
\repeatstandarditem{consult(+Files,+OptionList)}{compile/2}
\repeatstandarditem{consult(+Files)}{compile/1}
\standarditem{[+Files]}{[]/1 (consult)}
%
The standard predicate {\tt consult/[1,2]} is the most convenient
method for entering static source code rules into XSB's
database~\footnote{In XSB, {\tt reconsult/[1,2]} is defined to have
  the same actions as {\tt consult/[1,2]}.}.  Files is either s source
file designator (see Section~\ref{sec:filenames}) or a list of source
file designators, and {\tt Options} is a list of options to be passed
to XSB's compiler if the file needs to be compiled (see
Section~\ref{the_compiler}).  {\tt consult(Files)} is defined as {\tt
  consult(Files,[])}, as is {\tt [Files]}.

Consulting a file {\tt File} (module) conceptually consists of the
following five steps which are described in detail in the following
paragraphs.
\begin{description}
\item[Name Resolution:] determine the file that {\tt File} designates,
  including directory and drive location and extension, as discussed
  in Section~\ref{sec:filenames}.
\item[Compilation:] if the source file or header has changed later
  than the object file (or if there is no byte-code file) compile the
  file using {\tt compile/2} with the options specified, creating a
  byte-code file.  This strategy is used whether the source file is
  Prolog, C, or C++.
\item[Loading:] load the byte-code file into memory. 
\item[Importing:] if the file is a module, import any exported
	predicates of that module to {\tt usermod}.
\item[Query Execution:] execute any queries that the file may contain,
  i.e. any terms with principal functor {\tt '?-'/1}, or with the
  principal functor {\tt ':-'/1} and that are not directives like the
  ones described in Section~\ref{the_compiler}.  The queries are
  executed in the order in which they appear in the source file.
\end{description}
\comment{
Once the file is compiled into byte-code, the byte-code for the file
is loaded into XSB's database.  After loading the file all exported
predicates of that module are imported into the current environment
(the current working module {\tt usermod}) if the file is a module.
For non-modules, all predicates are imported into the current working
module.  }

Error conditions for {\tt consult(+File,+Options)} are as follows: 
\bi
\item 	{\tt File} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt File} is not an atom
\bi
\item 	{\tt type\_error(atom,File)}
\ei
\item 	{\tt File} does not exist in the current set of library directories
\bi
\item 	{\tt existence\_error(file,File)}
\ei
%
\item 	{\tt File} has an object code extension (e.g. {\tt .xwam})
\bi
\item 	{\tt permission\_error(compile,file,File)}
\ei
%
%\item {\tt File} has been loaded previously in the session {\em and}
%  there is more than one active thread.
%\bi
%\item 	{\tt misc\_error}
%\ei
\ei
Error conditions of compiler options are determined by {\tt compile/2}
which {\tt consult/[1,2]} calls.
\end{description}

In addition, {\tt ensure\_loaded/[1-3]} acts much like {\tt
  consult/[1,2]}, but does not reload a file unless needed.  These
predicates are fully documented in Section~\ref{sec:LoadDyn}.  On the
other hand, the predicate {\tt compile/[1,2]}
(Section~\ref{compiler_invoking}) compiles a file as static code, but
does not load it.

\index{dynamic code!loading}
\index{canonical format}
\subsection{Dynamic Code} \label{sec:dynamic-code}
% 
In XSB, in addition to static compilation, most source code file can
be loaded as dynamic code via the predicates {\tt load\_dyn\_gen/2},
{\tt load\_dyn/[1,2]}, {\tt load\_dync/[1,2]}, {\tt
  ensure\_loaded/[2,3]} and other predicates described in
Section~\ref{sec:LoadDyn}.  These predicates act as {\tt consult/2} in
that if a given file {\em File} has already been loaded, old versions
of predicates defined in {\em File} will be retracted and their new
definitions loaded to correspond to those in {\em File} (except for
predicates in which a {\tt multifile/1} declaration is present in {\em
  File}).  Loading as dynamic code can be performed using XSB's reader
of canonical terms (which does not include operators or HiLog, but
does allow list and comma-list notation) via {\tt load\_dync/2} and
{\tt load\_dynca/1}; loading as dynamic code using XSB's general
reader for Hilog terms is performed via {\tt
  load\_dyn/2}.~\footnote{In previous versions of this manual, the
  term ``dynamic loading'' was sometimes used to refer to lazy,
  on-demand loading.  Because this usage may also refer to loading
  dynamic code, the term ``dynamic loading'' is now restricted to
  refer to loading as dynamic code.}

The predicates mentioned above are described more fully in
Section~\ref{sec:LoadDyn}.  Here, we overview the tradeoffs of
loading static and dynamic code.

\index{dynamic code!advantages and disadvantages}
\bi
\item Advantages for loading as dynamic code
\bi
\item For large files, containing $10^5-10^8$ clauses, loading as
  dynamic code can be much faster than loading as static code (via
  XSB's compiler), especially if the clauses do not need to be
  ordered, as with e.g., knowledge graphs.
%
\item When loaded as dynamic code, predicates have the advantages of
  dynamic code including star-, trie, compound, and alternate indexes,
  as well as being modifiable via assert and
  retract. \footnote{Dynamically code also allows larger atoms than
    static code.}
  %
  \item Loading as dynamic code fully supports module import and
    export, tabling declarations except for those mentioned below, and
    XPP-based preprocessing before load.  In addition it supports the
    use of operators and DCGs as long the dynamic load is not based on
    canonical reading.
    %
    \ei
\item Advantages for Static Compilation
\bi
\item Although dynamic code is compiled into SLG-WAM instructions as
  is static code, static code is more optimized than dynamic code.
  particularly when the clauses have large bodies or when arithmetic
  is used.  For facts and pure binary predicates (those containing a
  single literal in their body) however, static and dynamic byte code
  is essentially the same (modulo indexing).
  %
\item When a file is loaded as dynamic code, the loading does not
  perform usage and definition checks for modules, or other static
  compilation checks such as singleton variable checks or checks of
  arithmetic expressions.
  %
\item Dynamic loading does not support a few features that are
  supported by static consulting, such as mode declarations; the
  predicate tabling declarations answer subsumption or call
  subsumption with indexing, or the general tabling declarations {\tt
    auto\_table} and {\tt suppl\_table}.  
  %
\item Importantly, statically compiled code has been used longer and
  tested more thoroughly than dynamically loaded code.  While dynamic
  loading is safe for most files/modules and recommended for
  files/modules that contain a large number of facts or simple rules,
  static compilation may be the safer choice for programs that use
  complex clauses together with newer forms of tabling.  \ei \ei

\subsection{The multifile directive}
\index{declarations!\texttt{multifile/2}}
The default action upon loading a file or module is to delete all
previous byte-code for predicates defined in the file being loaded.  If this is not
the desired behavior, the user may add to the file a declaration
\begin{center}
{\tt :- multifile Predicate\_List .} \\
\end{center}
where {\tt Predicate\_List} is a list of predicates in {\em
  functor/arity\/} form.  The effect of this declaration is, on
loading, to delete {\em only\/} those clauses of {\tt predicate/arity}
that were defined in the file itself, but not that defined from other
files.  {\em If a predicate $P$ is to be treated as multifile, the
  {\tt multifile/1} directive for $P$ must appear in all files that
  contain clause definitions for $P$.}  If $P$ is dynamic, this means
that the multifile declaration for $P$ must appear in files defining
$P$ whether they are compiled and consulted, or loaded as dynamic code
via {\tt load\_dyn/[1,2]} or similar predicates.  Note that predicates
declared as {\tt multifile} can be defined only in usermod.

\section{The Compiler} \label{the_compiler} \index{compiler}
%========================================================

The XSB compiler translates XSB source files into
byte-code object files.  It is written entirely in Prolog.
Both the sources and the byte code\index{byte code!files!compiler}
for the compiler can be found in the XSB system directory
{\tt cmplib}\index{compiler!\texttt{cmplib}}.
%
\index{GPP}
\index{preprocessing}
Prior to compiling, XSB filters the programs through \emph{GPP}, a 
preprocessor written by Denis Auroux (auroux@math.polytechnique.fr).
This preprocessor maintains high degree of compatibility with the C
preprocessor, but is more suitable for processing Prolog programs.
The preprocessor is invoked with the compiler option \verb|xpp_on|
as described below. The various features of GPP are described in
Appendix~\ref{gpp-man}.

XSB also allows the programmer to use preprocessors other than GPP.
However, the modules that come with XSB distribution require GPP.
This is explained below (see \verb|xpp_on/1| compiler option).

The following sections describe the various aspects of the compiler 
in more detail.


\subsection{Invoking the Compiler} \label{compiler_invoking}
\index{invoking the Compiler}\index{compiler!invoking}
%=====================================================

In addition to invoking the compiler through {\tt consult/[1,2]} and
other predicates, the compiler can be invoked directly at the
interpreter level (or in a program) through the Prolog predicates {\tt
  compile/[1,2]}.

\begin{description}
\repeatstandarditem{compile(+Files,+OptionList)}{compile/2}
\standarditem{compile(+Files)}{compile/1}
%
{\tt compile/2} compiles all files specified into SLG-WAM bytecode,
using the compiler options specified in {\tt OptionList} (see
Section~\ref{sec:CompilerOptions} below for the precise details.)
{\tt Files} is either an absolute or relative filename, or a ground
list of absolute or relative file names; and {\tt OptionList} is a
ground list of compiler options described in
Section~\ref{sec:CompilerOptions}.{\tt compile/1} is a convenience
predicate, defined as {\tt compile(Files,[])}.

For a given, {\tt File} to be compiled, the source file name
corresponding to {\tt File} is obtained by concatenating a directory
prefix and the extension {\tt .P}, {\tt .pl}, {\tt .prolog}, or other
filenames as discussed in Section~\ref{sec:filenames}.  If no absolute
path name is given, XSB uses the loader paths to find the file, as
described in Section~\ref{LibPath}).

{\bf Error Cases}
In the cases below, {\tt File} refers to an element of {\tt Files} if
{\tt Files} is a list and otherwise refers to {\tt Files} itself.
\bi
\item 	{\tt Files} is a variable, or a list containing a variable element.
\bi
\item 	{\tt instantiation\_error}.
\ei
\item  {\tt File} is a neither an atom nor a list of atoms.
\bi
\item 	{\tt type\_error(atom\_or\_list\_of\_atoms,File)}
\ei
\item  {\tt File} does not exist in the current set of
  library directories 
\bi
\item 	{\tt existence\_error(file,File)}
\ei
%
\item 	{\tt File} has an object code extension (e.g. {\tt .xwam})
  \bi
\item 	{\tt permission\_error(compile,file,File)}
  \ei
\item XSB does not have write permission on the directory where {\tt
  File} resides:
  \bi
\item {\tt permission\_error(write,file,ObjectFile)} where {\tt
  ObjectFile} is the basename of {\tt file} with the extension {\tt
  .xwam}.
\ei  
%\item {\tt File} has been loaded previously in the session {\em and}
%  there is more than one active thread.  
%\bi
%\item 	{\tt misc\_error}
%\ei
\item 	{\tt OptionList} is a partial list or contains an option that is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
\item 	{\tt OptionList} is neither a list nor a partial list
\bi
\item 	{\tt type\_error(list,OptionsList)}
\ei
\item {\tt OptionList} contains an option, {\tt Option} not described
  in Section~\ref{sec:CompilerOptions} 
\bi
\item 	{\tt domain\_error(xsb\_compiler\_option,Option)}
\ei
\ei
\end{description}

The predicates {\tt compile/[1.2]}, {\tt consult/[1,2]} and {\tt
  ensure\_loaded/[1-3]} resemble each other in their behavior.  {\tt
  compile/[1,2]} always compiles, but never loads.  {\tt
  consult/[1,2]} compiles only if needed, and always loads.  {\tt
  ensure\_loaded/[1-3]} compiles if needed, but loads only if needed,
either as static or dynamic code depending on the parameters it has
been given.  With these differences in mind, the actual process of
compilation as described in this and following sections is essentially
the same among these predicates.

For all of these predicates, the result of the compilation (an SLG-WAM
object code file) is stored in ($\langle filename \rangle$.xwam). This
object file is always written into the directory where the source file
resides: the user must therefore have write permission in that
directory to avoid a permission error.  These predicates can also be
used to compile foreign language modules.  In this case, the names of
the source files should have the extension {\tt .c} and a {\tt .P}
file must {\em not\/} exist.  Instead, a header file (with extension
{\tt .H}) {\em must} be present for a foreign language module (see
Chapter~\ref{foreign} for details).
 
If desired, when compiling a module (file), clauses and directives can be
transformed as they are read.  This is indeed the case for definite clause
grammar rules (see Chapter~\ref{DCGs}), but it can also be done for clauses
of any form by providing a definition for predicate {\tt term\_expansion/2}
(see Section~\ref{DCG_builtins}).

%The options in {\tt OptionsList} in {\tt compile/2} and {\tt
%  consult/2} are 

%The {  Since options can be set
%  globally via the predicate {\tt set\_global\_compiler\_options/1},
%  each option in {\tt OptionsList} can optionally be prefixed by
%  \verb|+| or \verb|-|, indicating that the option is to be turned on,
%  or off, respectively.  (The lack of any prefix turns the option on.)
%
%\demo{$|$ ?- compile(Files).} 
%
%\noindent
%is just a notational shorthand for the query:
%
%\demo{$|$ ?- compile(Files, []).}

%\comment{
%The standard predicates {\tt consult/[1,2]} call {\tt compile/1} (if
%necessary).  Error conditions for {\tt compile/[1,2]} are similar to
%those for {\tt consult/[1,2]}.
%
%The list of compiler options {\tt OptionList}, if specified, 
%should be a proper Prolog list, i.e.\ a term of the form:
%\begin{center}
%	{\tt [ $option_1$, $option_2$, $\ldots$, $option_n$ ].}
%\end{center}
%where $option_i$ is one of the options described in
%Section~\ref{sec:CompilerOptions}.
%}

%
%If {\tt File} contains no extension, an attempt is made to compile the
%file {\tt File.P}, {\tt File.pl}, {\tt File.prolog}, or other extensions 
%before trying compiling the file with name {\tt File}.

%We recommend use of the extension {\tt .P} for Prolog source file to
%avoid ambiguity.
%Optionally, users can also provide a header file for a module (denoted
%by the module name suffixed by {\tt .H}).  In such a case, the XSB
%compiler will first read the header file (if it exists), and then the
%source file.  Currently the compiler makes no special treatment of
%header files.  They are simply included in the beginning of the
%corresponding source files, and code can, in principle, be placed in
%either.
%\comment{ In future versions of XSB the header files may be
%  used to check interfaces across modules, hence it is a good
%  programming practice to restrict header files to declarations alone.
%f}

\subsection{Compiler Options}\label{sec:CompilerOptions}
\index{compiler!options}\index{options!compiler}
%=================================================

Compiler options can be set in three ways: from a directive in the
file to be compiled (see compiler directive {\tt
  compiler\_options/1}), from the compilation command ({\tt compile/2}
and {\tt consult/2}), or from a global list of options ({\tt
  set\_global\_compiler\_options/1})

\begin{description}
\standarditem{set\_global\_compiler\_options(+OptionsList)}{set\_global\_compiler\_options/1}
    {\tt OptionsList} is a list of compiler options (described below).
    Each can optionally be prefixed by \verb|+| or \verb|-|,
    indicating that the option is to be turned on, or off,
    respectively.  (No prefix turns the option on.)  This evaluable
    predicate sets the global compiler options in the way indicated.
    These options will be used in any subsequent compilation, unless
    they are 
    reset by another call to this predicate, overridden by options
    provided in the compile invocation, or overridden by options in
    the file to be compiled.
\end{description}

The following options are currently recognized by the compiler:
\begin{description}
\item[{\tt singleton\_warnings\_off}] Does not print out any warnings
  for singleton variables during compilation.  This option can be
  useful for compiling XSB programs that have been generated by some
  other program.
%
\item[{\tt optimize}]\index{compiler options!\texttt{optimize}} When
  specified, the compiler takes additional steps to optimize the
  object code.  In \version, this option reduces the overhead for
  predicate calls, among other features, so execution may be faster
  for recursive loops.  However, due to the nature of the
  optimizations, the user may not be able to trace all calls to
  predicates in the program.  As expected, the compilation phase will
  also be slightly longer.  For these reasons, the use of the {\tt
    optimize} option may not be suitable for the development phase,
  but can be helpful once the code has been debugged.
%
  \index{Unicode!character\_sets}
  \index{compiler options!\texttt{character\_set/1}} 
\item[{\tt character\_set/1}] The compiler option of {\tt
  character\_set(+CharSet)} causes the remainder of the file being
  compiled to be read using the character set indicated by {\tt
    CharSet}.  Valid character sets are (currently) {\tt cp1252}, {\tt
    utf\_8}, and {\tt latin\_1}.
%
  \index{modules!explicit filenames}
  \index{compiler options!\texttt{module/1}}
\item[{\tt module/1}] The compiler option of {\tt module(+ModName)}
  causes the compiler to generate a byte-code file for a module of the
  name {\tt ModName}.
%
\item[{\tt allow\_redefinition}] \index{standard predicates}
	By default the compiler refuses to compile a file that
	contains clauses that would redefine a standard predicate
	(unless the {\tt sysmod} option is in effect.)  By specifying
	this option, the user can direct the compiler to quietly allow
	redefinition of standard predicates.
%
\item[{\tt xpp\_on}]\index{compiler
  options!\texttt{xpp\_on}}\index{GPP} Filter the program through a
  preprocessor before sending it to the XSB compiler. By default (and
  for the XSB code itself), XSB uses GPP, a preprocessor developed by
  Denis Auroux (auroux@math.polytechnique.fr) that has high degree of
  compatibility with the C preprocessor, but is more suitable for
  Prolog syntax. In this case, the source code can include the usual C
  preprocessor directives, such as \verb|#define|, \verb|#ifdef|, and
  \verb|#include|. This option can be specified both as a parameter to
       {\tt compile/2} and as part of the {\tt compiler\_options/1}
       directive inside the source file. See Appendix~\ref{gpp-man}
       for more details on GPP.

  When an \verb|#include "file"| statement is encountered, XSB directs
  GPP to search for the files to include in the
  directories \verb|$XSB_DIR/emu| and
  \verb|$XSB_DIR/prolog_includes|. \index{GPP!\texttt{gpp\_include\_dir}}
  However, additional directories can be added to this search path by
  asserting into the predicate \verb|gpp_include_dir/1|, {\bf which
    must be imported from module} {\tt parse}~\footnote{For
    compatibility, XSB also supports the ISO predicate {\tt include/1}
    which also allows extra files to be included during compilation.}.
%  
  For example if you want additional directories to be searched, then
  the following statements must be executed:
%%
\begin{verbatim}
    :- import gpp_include_dir/1 from parse.
    :- assert(gpp_include_dir('some-other-dir')).
\end{verbatim}

  Note that when compiling XSB programs, GPP searches the current
  directory and the directory of the parent file that contains the
  include-directive \emph{last}. 
%%
  If you want GPP to search directories in a different order, {\tt
    gpp\_options/1} can be used (see below).

  Note: if you assert something into \texttt{gpp\_include\_dir/1} then you
  must also execute {\tt retractall(gpp\_include\_dir(\_))} later on or
  else subsequent Prolog compilations might not work correctly.

\index{compilation!conditional!gpp}
  XSB predefines the constant {\tt XSB\_PROLOG}, which can be used for
  conditional compilation. For instance, you can write portable program
  to run under XSB and and other prologs that support C-style
  preprocessing and use conditional compilation to account for the
  differences: 
  %%
  \begin{samepage}
  \begin{verbatim}
#ifdef XSB_PROLOG
    XSB-specific stuff
#else
    other Prolog's stuff
#endif
    common stuff
  \end{verbatim}
  \end{samepage}
  %%

\item[{\tt gpp\_options}] \index{GPP!\texttt{gpp\_options}} This
  dynamic predicate must be imported from module {\tt parse}.  If some
  atom is asserted into {\tt gpp\_options} then this atom is assumed
  to be the list of command line options to be used by the
  preprocessor (only the first asserted atom is ever considered). If
  this predicate is empty, then the default list of options is used
  (which is {\tt '-P -m -nostdinc -nocurinc'}, meaning: use Prolog
  mode and do not search the standard C directories or the directory
  of the parent file that contains the include-instruction).
  
  As mentioned earlier, when XSB invokes GPP, it uses the option {\tt
    -nocurinc} so that GPP will not search the directory of the parent
  file.  If a particular application requires that the parent file
  directory must be searched, then this can be accomplished by
  executing {\tt assert(gpp\_options('-P -m -nostdinc'))}.
  
  Note: if you assert options into \texttt{gpp\_options/1} then do not
  forget to
  also execute \texttt{retractall(gpp\_options(\_))} after that or else
  subsequent Prolog compilations might not work correctly.
  
\item[{\tt xpp\_dump}] \index{GPP!\texttt{xpp\_dump}}
  %%
  This causes XSB to dump the output from the GPP preprocessor into a file.
  If the file being compiled is named {\tt file.P} then the dump file is
  named {\tt file.P\_gpp}. This option can be included in the list of
  options in the {\tt compiler\_options/1} directive, but usually it is
  used for debugging, as part of the {\tt compile/2} predicate. If {\tt
    xpp\_dump} is specified directly in the file using {\tt
    compiler\_options/1} directive, then it should \emph{not} follow the
  {\tt gpp\_on} option in the list (or else it will be ignored).

  {\bf Note}: multiple occurrences of {\tt xpp\_on} and {\tt xpp\_dump}
  options are allowed, but only the \emph{first one} takes effect---all the
  rest are ignored!  


\item[{\tt xpp\_on/N} and {\tt xpp\_dump/N}]
  \index{GPP!\texttt{xpp\_on/N}}
  \index{GPP!\texttt{xpp\_dump/N}}
  %%
  ~\\
  XSB also allows one to filter program files through a pipeline of external
  preprocessors in addition to or instead of GPP.
  This can be specified with the N-ary versions of {\tt xpp\_on} and {\tt
    xpp\_dump}:
%% 
\begin{verbatim}
     xpp_on(spec1,...,specN)  
     xpp_dump(spec1,...,specN)  
\end{verbatim}
%%
  Each {\tt spec1}, ..., {\tt specN} is a preprocessor specification of
  the form {\tt preprocessor\_name} or {\tt preprocessor\_name(options)}.
  Each preprocessor is applied in a pipeline passing its output to the next
  preprocessor. The first preprocessor is applied to the file being
  compiled.
  The preprocessor name is an atom or a function symbol and {\tt options}
  must be an atom. If {\tt preprocessor\_name} is {\tt gpp}, then the GPP
  preprocessor will be invoked. Note that {\tt gpp} can appear anywhere in
  the aforesaid sequence of specs (or not appear at all), so it is possible to preprocess
  XSB files before and/or after (or instead of) GPP. Note that {\tt
    xpp\_on(gpp)}  and {\tt xpp\_dump(gpp)} are equivalent to the earlier
  0-ary compiler options {\tt xpp\_on}
  and {\tt xpp\_dump}, respectively. 

  To use a preprocessor other than GPP two things must be done:
  %% 
  \begin{itemize}
  \item A 4-ary Prolog predicate must be provided, which takes three input
    arguments and produces in its 4th argument
    a syntactically correct shell (Unix or Windows)
    command for invoking the preprocessor. The first preprocessor in the
    pipeline 
    must be taking its input 
    from a file, but the subsequent preprocessors must expect their input from
    the standard input. All preprocessors must
    send their results to the standard
    output. The arguments to the 4-ary predicate in question are:
    %% 
    \begin{itemize}
    \item   File: this is the XSB input file to be processed. Usually this
      argument is left unused (unbound), but might be useful for producing error
      messages or debugging.
    \item   Preprocessor name: this is the name under which the
      preprocessor is \emph{registered} (see below). It is the same as
      {\tt processor\_name} referred to above.  This name is  
      up to the programmer; it is
      to be used to refer to the preprocessor (it does not need to be
      related in any way to
      the shell-command-producing predicate or to the OS's pathname for the
      preprocessor).
    \item Options: these are the command-line options that the preprocessor
      might need. If the preprocessor spec mentioned above is {\tt
        foo(bar)} then the preprocessor name (argument 2) would be bound to
      {\tt foo} and options (argument 3) to {\tt bar}.
    \item Shell command: this is the only output argument. It is supposed
      to be the shell command to be used to invoke the preprocessor.
      The shell command must \emph{not} include the file name to be
      processed---that name is added automatically as the last option
      to the shell command.

      \paragraph{\it Special considerations for using XSB as a preprocessor.}
      XSB can be used as a preprocessor for XSB programs by
      constructing a shell command that invokes XSB. However, several
      conventions need to be observed. First, the file to be
      preprocessed is automatically attached as the last argument of
      the aforesaid shell command.  Therefore, the file name to be
      read and preprocessed by XSB must be passed to XSB by some other
      means such as using the \texttt{-e "\emph{command}"} or {\tt -B}
      command line options (Section~\ref{sec:EmuOptions}).  In
      addition, the last command line option for that XSB-based
      command must be \texttt{--ignore}, which will cause XSB to
      ignore the remaining options, including the aforesaid file name. 

      Also, if a preprocessor appears in the pipeline as the second
      preprocessor or later (i.e., after the first argument in
      \texttt{xpp\_dump}), that preprocessor's shell command line must
      expect to receive the output of the preceding preprocessor
      \emph{on the standard input}.  In this case, XSB must be invoked
      with the \texttt{-e "see(userin)."} option followed by a call to
      the predicate that would actually do the preprocessing.

      Here are a few examples. To invoke XSB as the first preprocessor in
      the pipeline, one could construct the following shell command (shown
      below as an atom of the kind that one needs to construct in the
      ``Shell command'' argument being discussed):
      %% 
\begin{alltt}
'.../xsb \textnormal{\emph{options}} -e "preprocessPred(''\textnormal{\emph{MyFile}}''),halt." --ignore'      
\end{alltt}
      %% 
Note that here the file to be preprocessed, \emph{MyFile}, needs to be
passed to the preprocessing predicate as an argument. To use XSB as the second and later
preprocessor in the pipeline, the appropriate command could be
      %% 
\begin{alltt}
'.../xsb \textnormal{\emph{options}} -e "see(userin),preprocessPred,halt."'
\end{alltt}
      %% Here the file to be preprocessed will come on the standard
input of XSB. There is no need for the \texttt{--ignore} option here
because no file names would be attached at the end of this command
(since the file is piped through the standard input).

      In both cases, the file passed to \texttt{preprocessPred/1} or
      \texttt{preprocessPred/0} could be processed using
      \texttt{read/1} and \texttt{write\_canonical/1}.  The typical
      options that one would want to pass in both cases (to replace
      the parameter \emph{options} above) are
      %% 
\begin{verbatim}
     --noprompt --quietload --nobanner --nofeedback      
\end{verbatim}
      %% 
      Note that other commands might need to be executed under the
      \texttt{-e} option in order to bootstrap the preprocessor (e.g.,
      additional XSB files might need to be loaded). 
    \end{itemize}
    %%
  \item The preprocessor must be \emph{registered} using the following query:
%% 
\begin{verbatim}
:- import register_xsb_preprocessor/2 from parse.
?- register_xsb_preprocessor(preproc_name,preproc_predicate(_,_,_,_)).
\end{verbatim}
%% 
    Here the argument \texttt{preproc\_name} is the user-given name for the
    preprocessor, while \texttt{preproc\_predicate} is the 4-ary
    shell-command-producing predicate described earlier.

    The registration query must be executed \emph{before} the start of the
    preprocessing of the input XSB file. Clearly, this implies that the
    shell-command-producing predicate must be in a different file than the
    one being preprocessed.

    Note: one \emph{cannot} register the same preprocessor twice. The
    second time the same name is used, it is ignored. However, it \emph{is}
    possible to register the same shell-command-producing predicate twice,
    if the user registers the these shell-command-producing predicates
    under different preprocessor names.
  \end{itemize}
  %% 

  The difference between {\tt xpp\_on/N} and {\tt xpp\_dump/N}  
  is that the latter also saves the output of each preprocessing stage in a
  separate file. For instance, if the XSB file to be preprocessed
  is {\tt abc.P} and the {\tt xpp\_dump/N} option has the form
  {\tt xpp\_dump(foo,gpp,bar)} then three files will be produced:
  {\tt abc.P\_foo}, {\tt abc.P\_gpp}, {\tt abc.P\_bar}, each containing the
  result of the respective stage in preprocessing.   

  Here is an example. Suppose that {\tt foobar.P} includes the definition of
  the following predicate
%% 
\begin{verbatim}
make_append_cmd(_File,_Name,Options,ResultingCmd) :-
       fmt_write_string(ResultingCmd, '"/bin/cat" "%s"', arg(Options)).
\end{verbatim}
%% 
  and also has the following registration query:
%% 
\begin{verbatim}
?- parse:register_xsb_preprocessor(appendfile,make_append_cmd(_,_,_,_)).  
\end{verbatim}
%% 
  Suppose that the file {\tt abc.P} includes the following compiler directive:
  %% 
\begin{verbatim}
:- compiler_options([xpp_on(appendfile('data.P'),gpp)]).  
\end{verbatim}
  %% 
  If the file {\tt foobar.P} is loaded before compiling {\tt abc.P} then  
  the file {\tt data.P} will be first appended to {\tt abc.P} and then
  the result will be processed by GPP. The final result will be parsed and
  compiled by XSB.

  Note that although the parameters {\tt \_File} and {\tt \_Name} are not
  used by {\tt make\_append\_cmd/4} in our example, when this predicate is
  called they will be bound to {\tt foobar.P} and {\tt appendfile},
  respectively, and could be used by the shell-command-producing predicates
  for various purposes.





\item[{\tt quit\_on\_error}] \index{GPP!\texttt{quit\_on\_error}} This
  causes XSB to exit if compilation of a program throws an error.
  This option is useful when running XSB from a makefile, when it is
  necessary to stop the build process after an error has been
  detected. For instance, XSB uses this option during its own build
  process.


%-------------------------------
\index{tabling!compiler options}
\index{tabling!automatic}
%-------------------------------
\item[{\tt auto\_table}]\index{declarations!\texttt{auto\_table}} When specified as a
  compiler option, the effect is as described in
  Section~\ref{tabling_directives}.  Briefly, a static analysis is made to
  determine which predicates may loop under Prolog's SLD evaluation.  These
  predicates are compiled as tabled predicates, and SLG evaluation is used
  instead.
\index{tabling!supplemental}
\item[{\tt suppl\_table}]\index{declarations!\texttt{suppl\_table}} The intention of this
  option is to direct the system to table for efficiency rather than
  termination.  When specified, the compiler uses tabling to ensure that no
  predicate will depend on more than three tables or EDB facts (as
  specified by the declaration {\tt edb} of
  Section~\ref{tabling_directives}).  The action of {\tt suppl\_table} is
  independent of that of {\tt auto\_table}, in that a predicate tabled by
  one will not necessarily be tabled by the other.  During compilation,
  {\tt suppl\_table} occurs after {\tt auto\_table}, and uses table
  declarations generated by it, if any.
%--------------------------------------
\index{specialization!compiler options}
%--------------------------------------
\item[{\tt spec\_repr}]\index{compiler options!\texttt{spec\_repr}}
  When specified, the compiler performs specialization of partially
  instantiated calls by replacing their selected clauses with the
  representative of these clauses, i.e. it performs {\em folding\/}
  whenever possible.  In general specialization with replacement is
  correct only under certain conditions.  XSB's compiler checks for
  sufficient conditions that guarantee correctness, and if these
  conditions are not met, specialization with replacement is not
  performed for the violating calls.  See Section~\ref{specialization}
  for details on XSB's specialization.
\item[{\tt spec\_off}]\index{compiler options!\texttt{spec\_off}} When
  specified, the compiler does not perform specialization of partially
  instantiated calls.
\item[{\tt unfold\_off}]\index{compiler options!\texttt{unfold\_off}}
  When specified, this disables unfolding through an aspect of
  specialization called singleton sets optimization.
  (Cf. Section~\ref{specialization}).
%
% TES: In spec.P it looks like the code avoids the tabling issue by a
% call Tabled =:= 0, which ensures it is only applied to non-tabled
% predicates.  This option is necessary in \version\ for the
% specialization of {\tt table} declarations that select only a single
% chain rule of the predicate.

\item[{\tt spec\_dump}]\index{compiler options!\texttt{spec\_dump}}
  Generates a {\tt module.spec} file, containing the result of
  specializing partially instantiated calls to predicates defined in
  the {\tt module} under compilation.  The result is in Prolog source
  code form.  This option is normally only used by developers.

%---------------------------------------------
%\index{unification factoring!compiler options}
 %---------------------------------------------
%\item[{\tt ti\_dump}]\index{compiler %options!\texttt{ti\_dump}}
%	Generates a {\tt module.ti} file containing the result of applying
%	unification factoring to predicates defined in the {\tt module}
%	under compilation.  The result is in Prolog source code form.
%	See page~\pageref{transformational_indexing} for more information
%	on unification factoring.
%\item[{\tt ti\_long\_names}]\index{compiler options!\texttt{ti\_long\_names}}
%	Used in conjunction with {\tt ti\_dump}, generates names for
%	predicates created by unification factoring that reflect the
%	clause head factoring done by the transformation.
\comment{
\item[{\tt init\_var\_off}]\index{compiler options!\texttt{init\_var\_off}}
	When specified, the compiler will give a warning (instead of an
	error) upon finding that a potentially uninitialized variable is
	being used.  {\em Potentially uninitialized variables\/} are
	variables that appear in only one branch of an {\sf or} or an
	{\sf if-then-else} goal in the body, and, furthermore, are used
	after that goal.
	In certain clauses, the variable may always be initialized after
	the {\sf or} or the {\sf if-then-else} goal, because the execution 
	cannot continue through the path of the branch that does not initialize
	the variable.  In these cases, the {\tt init\_var\_off} option can be
	useful, though the user is cautioned against careless use of this
	option.

	{\sc Warning:} The object-file generated by the compiler when this
		option is used may not execute correctly (or even cause
		XSB to core dump!) if the variable is indeed
		uninitialized when used.
}
%---------------------------------------------
\index{mode analysis!compiler options}
\index{static analysis!mode}
\index{modes!annotations}
%---------------------------------------------
\item[{\tt modeinfer}]\index{compiler options!\texttt{modeinfer}}
%
  This option turns on mode inference. When the option is on, for each
  file with base name {\tt my\_file} that is compiled, a mode analyzer
  creates a {\tt {\em my\_file}.D} file that contains all mode
  information that is inferred or declared, and the analyzer issues
  warnings when the inferred mode differs from a declared mode.

%  The mode analyzer checks whether predicates are called with correct
%  modes, i.e., that calling modes are consistent with their declared
  % modes.

  The allowed mode declarations are {\tt mode/1} which indicates the
  declared or inferred mode at a call to a predicate, and {\tt
    mode\_on\_success/1} which indicates the mode on success of the
  predicate.  The allowed mode designations for arguments are {\tt +}
  for {\em ground}, and {\tt ?}  for {\em nonground} (or {\em
    unknown}).  Consider an implementation of the well-known predicate
  {\tt append/3}, implemented in {\tt my\_mod}.  The declaration

\demo{:- mode append(+,?.?).}

   in {\tt my\_mod} indicates that {\tt append/3} must be called with
   the first argument as a ground term but the second and third
   arguments could any terms (including variables).  The mode analyzer
   does not keep track of groundedness of subterms of a given
   argument, only of the argument itself.  Continuing our example. in
   the goal {\tt append([a,X,b],[c],Out)}, the fact that {\tt X} is a
   variable does not affect execution of the goal, but violates the
   declaration that the first argument of {\tt append/3} must be
   ground.

   While the {\tt mode/1} declaration infers modes for {\em calls} to
   predicates, the expected modes on successful returns is indicated
   by

\demo{:- mode\_on\_success append(+,?,+)}.



%   The mode analyzer tries to determine whether any call to a
%   predicate may violate its declared modes, and reports a mode
%   warning if it is unable to prove that all calls conform to the
%   declared modes.  In addition, it writes out mode inferences to {\tt
%     my\_file.D}.

     Although mode inference can be performed on non-module files, it
     is more useful for modules.  For best results, modes for exported
     predicates (or predicates not in modules that will be called from
     the top-level or externally) should be declared appropriately.
     Non-exported predicates may also have modes declared for them.
     For imported predicates, the analyzer reads the {\tt .D} file of
     the module imported from.  It finds the location of the module by
     looking in directories on the loader's search path as specified
     in Section~\ref{LibPath}.

     Multiple modes may be declared for a given predicate, where
     multiple modes are treated as a disjunction of modes.  For
     example consider the problem of ensuring that all calls to {\tt
       append/3} will terminate in the sense that they have a finite
     number of solutions.  A sufficient but not necessary condition is
     that the first or third argument of a call to {\tt append/3} must
     be ground.~\footnote{This requirement is sufficient but not
       necessary because the first and third arguments must be lists
       with closed tails, although they may contain elements that are
       not instantiated.  For instance the goals {\tt
         append([a,A,B],X,Z)} and {\tt append(X,Z,[a,A,B])} both
       terminate.  However the goal {\tt append([a|B],X,Z)} in which
       the first argument has an open-tailed list, does not terminate.
       However as noted, XSB's mode analysis does not (currently)
       support this level of detail.}  This is expressed as:

\demo{:- mode append(+,?,?)}        

\demo{:- mode append(?,?,+)}        

        There are cases in which the inference is too weak to
        establish that all calls will be correctly moded, even though
        in any execution they will be.  This usually arises when a
        program uses a data structure that is partially ground and
        partially non-ground.  It may be the case that the programmer
        knows which subcomponents are ground and is careful to pass
        only those components to predicates requiring ground inputs.
        Because the mode analyzer does not keep track of the subterms
        of a given argument, it may signal a mode warning.  To avoid a
        mode warning in such cases, the programmer may add a redundant
        run-time check of groundedness (e.g., using {\tt atomic/1})
        before the wrongly inferred call.  Such an addition allows the
        analyzer to infer that the argument will indeed be ground.

        Although mode analysis has proven quite useful, we end by
        mentioning three limitations that are present in \version{}.

        First, the user should declare {\tt mode\_on\_success} modes
        for dynamic predicates to indicate the mode of terms that will
        be asserted.  This is often necessary to allow the analyzer to
        be able to correctly infer modes.  In the future, the analyzer
        may be improved to be able to infer these success modes
        automatically.

        Second, the mode analyzer does not handle explicit module
        qualifications in predicate calls (through the use of the ``:''
        operator).

        Finally, the analysis may occasionally take a long time.  The
        analysis times can be longer than the rest of the compilation
        time when the module contains numerous clauses with large
        bodies.  By refactoring these clauses to reduce the number of
        body literals, one may be able to reduce the time for mode
        analysis.  Note, also, if the analysis depends on knowing the
        modes of predicates from other modules, and the modes of those
        predicates are not known, then the time may again be long.  Of
        course if those modes are known -- as they are for any XSB
        system library that is used -- the analysis time may be
        shorter.
%        If mode analysis takes an unusually long time (say,
%        more than 4 times as long as the rest of the compilation) you
%        may want to abort and restart compilation without {\tt
%          modeinfer}.

\item[{\tt mi\_warn}]\index{compiler options!\texttt{mi\_warn}}
  (Active only if the {\tt modeinfer} option is also invoked.)  During
  mode analysis, the {\tt .D} files corresponding to the imported
  modules are read in. The option {\tt mi\_warn} is used to generate
  warning messages if these {\tt .D} files are outdated --- {\em
    i.e.}, older than the last modification time of the source files.
  In addition, if this option is on, a warning is given if a predicate
  is inferred to never exit successfully (i.e., it exits via failure
  or throwing an exception).  This may be a correct inference, or it
  may indicate a problem in the inferencing that might be fixed by
  more mode declarations.

%\item[{\tt mi\_foreign}] (Obsolete) This option is used {\em only\/}
%  when mode analysis is performed on XSB system modules. This option
%  is needed when analyzing {\tt standard} and {\tt machine} in {\tt
%    syslib}.

\item[{\tt sysmod}] \index{standard predicates} 
%
Mainly used by developers when compiling system modules to enable
boot-strapping. If specified, standard predicates (see the Appendix
{\em Index of Standard XSB Predicates}) are automatically available
for use only if they are inline predicates (see
Section~\ref{inline_predicates}).  When compiling with {\tt sysmod}
non-inline standard predicates must be explicitly imported from the
appropriate system module.  Also standard predicates are permitted to
be defined.
%
\item[{\tt profile}] This option is usually used when modifying the
  XSB compiler.  When specified, the compiler prints out information
  about the time spent in certain phases of the compilation process.
%
\item[{\tt asm\_dump, compile\_off}] Generates a textual representation of 
	the SLG-WAM assembly code and writes it into the file {\tt file.A}
	where {\tt file} is the base name of the file being compiled.  
	
	{\sc Warning:} This option was created for compiler debugging and is
		not intended for general use.  There might be cases where
		compiling a module with these options may cause generation
		of an incorrect {\tt .A} and {\tt .xwam} file.  In such cases,
		the user can see the SLG-WAM instructions that are
		generated for a module by compiling the module as usual and
		then using the {\tt -d module.xwam} command-line
		option of the 
		XSB emulator (see Section~\ref{sec:EmuOptions}).

\item[{\tt verbo}] Compiles the files (modules) specified in
  ``verbose'' mode, printing out information about the progress of the
  compilation of each predicate.  This option is generally not needed
  by non-developers.
%
\item[{\tt index\_off}] When specified, the compiler does not generate
  any indices for the predicates compiled.  This option is generally
  not needed by non-developers.
\end{description}


\subsection{Specialization}\label{specialization}
\index{compiler!specialization}\index{specialization!Compiler}
%=============================================================

The XSB compiler automatically performs specialization of partially
instantiated calls.  Specialization can be thought as a source-level
program transformation in which partially instantiated calls to
predicates in the original program are replaced with calls to
specialized versions of these predicates.  The expectation from this
process is that the calls in the transformed program can be executed
more efficiently that their non-specialized counterparts.  This
expectation is justified mainly because of the following two basic
properties of the specialization algorithm:
\begin{description}
\item[Compile-time Clause Selection] Suppose that at compile time, a
  goal $G_P$ of a predicate $P$ can be determined to unify with only a
  subset of rules for $P$.  The transformed program can then
  specialize the call $G_P$ so that it only selects rules that can
  unify with it.  In so doing, unnecessary choice points can be
  reduced and the need for the call to use an index may be avoided.
\item[Factoring of Common Subterms] Non-variable subterms of partially
  instantiated calls that also occur in the heads of the selected
  clauses are factored out during the specialization process.  As a
  result, some virtual machine instructions that would be needed by
  the original program, such as head unification ({\tt get\_*} or {\tt
    unify\_*}) along with some argument register instructions ({\tt
    put\_*}) become unnecessary.  These instructions are eliminated
  from the specialized calls as well as the from specialized versions
  of the clause heads.
\end{description}
The following example shows the specialization of a predicate {\tt
  ordered/1} that checks if a list of HiLog terms is ordered:
\begin{center}
\tt
\begin{tabular}{ccc}
\begin{tabular}{l}
ordered([]). \\
ordered([X]). \\
ordered([X,Y|Z]) :- \\
\ \ \ \ X @=< Y, ordered([Y|Z]). 
\end{tabular}
& $\longrightarrow$ &
\begin{tabular}{l}
ordered([]). \\
ordered([X]). \\
ordered([X,Y|Z]) :- \\
\ \ \ \ X @=< Y, \_\$ordered(Y, Z). \\
\\
:- index \_\$ordered/2-2. \\
\_\$ordered(X, []). \\
\_\$ordered(X, [Y|Z]) :- \\
\ \ \ \ X @=< Y, \_\$ordered(Y, Z).
\end{tabular}
\end{tabular}
\end{center}
The transformation (driven by the partially instantiated call
{\tt ordered([Y|Z])}) effectively allows predicate {\tt ordered/2}
to be completely deterministic (when used with a proper list as its
argument), and to not use any unnecessary heap-space for its
execution.  We note that appropriate {\tt :- index} directives are
automatically generated by the XSB compiler for all specialized
versions of predicates.

The default specialization of partially instantiated calls does not
perform folding of clauses that the calls select.  Using the {\tt
  spec\_repr} compiler option (see Section~\ref{sec:CompilerOptions})
specialization with replacement of the selected clauses with the
representative of these clauses is performed.  Using this compiler
option, predicate {\tt ordered/1} above would be specialized as
follows:
%%
\begin{center}
\begin{minipage}{4.1in}
\begin{verbatim}
ordered([]).
ordered([X|Y]) :- _$ordered(X, Y).

:- index _$ordered/2-2.
_$ordered(X, []).
_$ordered(X, [Y|Z]) :- X @=< Y, _$ordered(Y, Z).
\end{verbatim}
\end{minipage}
\end{center}
%%$
%%
We note that in the presence of cuts or side-effects, the code
replacement operation might not be sound, i.e.  there are cases when
the original and the residual program are not semantically equivalent.
To address this, the compiler checks for sufficient (but not
necessary) conditions that guarantee semantic equivalence, and does
not perform specialization is the conditions are not met.

The XSB compiler prints out messages whenever it specialises
calls to some predicate.  For example, while compiling a file
containing predicate {\tt ordered/1} above, the compiler would print
out the following message:
\begin{center}
{\tt	\% Specialising partially instantiated calls to ordered/1}
\end{center}
The user may examine the result of the specialization transformation
by using the {\tt spec\_dump} compiler option
(see Section~\ref{sec:CompilerOptions}).

Finally, we have to mention that for technical reasons beyond the scope of
this document, specialization cannot be transparent to the user; predicates
created by the transformation do appear during tracing.


\subsection{Compiler Directives}\label{compiler_directives}
\index{compiler!directives}\index{directives!Compiler}
%=====================================================

Consider a directive
\begin{verbatim}
:- foo(a).
\end{verbatim}
that occurs in a file that is to be compiled.  The directive {\tt
  foo/1} may belong to one of two classes:
\begin{enumerate}
\item {\em Executable directives}: In this case, {\tt foo(a)} will be
  executed upon loading the file;
%
\item {\em Compiler directives}: In this case, {\tt foo(a)} provides
  information to be used by the compiler
\end{enumerate}

Directives are considered executable directives by default {\em
  except} in the case of the compiler directives listed in this
section.  Some compiler directives, such as the {\tt mode/1}
directive, have no meaning as a executable directive, while others,
such as {\tt import/2} do.  In fact as an executable directive {\tt
  import/2} imports predicates into {\tt usermod}.

A directive that could either be a compiler or an executable directive
can be disambiguated.  A statement beginning with {\tt ?-}, such as
\begin{verbatim}
?- import foo/1 from myfile.
\end{verbatim}
indicates that {\tt import/1} is an executable directive that should
be executed upon loading the file (and should have no meaning to the
compiler).  On the other hand, the statement
\begin{verbatim}
:- import foo/1 from myfile.
\end{verbatim}
indicates that {\tt foo/1} is a compiler directive, and that terms in
the file to be compiled are to be understood as {\tt myfile:foo/1}.
For executable directives the use of {\tt ?-} has the same meaning as
{\tt :-} --- in both cases the directive is executed upon loading the
file.

The following compiler directives are recognized in \version\ of XSB
%\footnote{Any parallelisation directives ({\tt parallel}) are simply
%ignored by the compiler, but do not result in syntax errors to enhance
%compatibility with various other earlier versions of PSB-Prolog.}.

\subsubsection{Including Files in a Compilation}

\begin{description}

\isoitem{include(+FileName)}{include/1}

The ISO directive 

\demo{:- include(FileName)} 

\noindent
causes the compiler to act as if the code from {\tt FileName} were
contained at the position where the directive was encountered.  XSB's
preprocessor (Section~\ref{sec:CompilerOptions}) can perform the same
function via the command \verb|#include FileName| as well as more
sophisticated substitutions, but {\tt include/1} should be used if
code portability is desired.

\end{description}
\index{compilation!conditional!Prolog directives}

\subsubsection{Conditional Compilation}
%
Section~\ref{sec:CompilerOptions} described a way of performing
conditional compilation using XSB's interaction with GPP.  Conditional
compilation can also be done through XSB's compiler, using the
directives {\tt \mif{} if(+Condition)}, {\tt \mif{} elif(+Condition)},
{\tt \mif{} else}, and {\tt \mif{} endif}.  For instance the fragment

\begin{verbatim}
:- if(current_prolog_flag(dialect,xsb)).
:- include('xsb_file.P').
:- elif(current_prolog_flag(dialect,swi)).
:- include('swi_file.P').
:- endif.
\end{verbatim}
\noindent
allows different Prolog code to be included for XSB and for
SWI.~\footnote{As an aside, both XSB and SWI try to support each
  other's idioms, but such support is never perfect.}  This framework
is very general: for instance, as long as {\tt if...elif...endif}
blocks are not nested, any Prolog code can be used in the consequents
of the (else)if.  The condition of {\tt if/1} or {\tt elif/1} can be
any Prolog goal, although care should be used in selecting {\tt
  Condition}.  For instance, the goal

\begin{verbatim}
:- if(file_exists('file1.P')).
\end{verbatim}
\noindent
might be true during compilation, but if the object file produced by
the compilation is moved, the condition might no longer be true.  To
summarize:

\begin{description}
\repeatstandarditem{if(?Condition)}{if/1}
\repeatstandarditem{elif(?Condition)}{elif/1}
\repeatstandarditem{else}{else/0}
\standarditem{endif}{endif/0}
%
Directives to invoke conditional compilation as described above.  If
{\tt Condition} is a ``changeable'' goal such as {\tt file\_exists/1},
a warning will be issued but no error will be raised.
\end{description}


\subsection{Mode Directives}\label{mode_declarations}
\index{mode analysis!mode indicators}
\index{static analysis!mode}
\index{modes!directives}\index{directives!modes}
\index{modes!indicators}
\index{modes!annotations}
%-----------------------------------------------------

The XSB compiler accepts {\tt mode} declarations of the form:

\demo{:- mode $ModeAnnot_1, \ldots, ModeAnnot_n$.}

and

\demo{:- mode\_on\_success $ModeAnnot_1, \ldots, ModeAnnot_n$.}

\noindent
where each $ModeAnnot_i$ is a {\em mode annotation\/}.  Arguments of a
mode annotation are {\em mode\_indicators} and are elements of the set
{\tt $\{$+,-,\#,?$\}$}).

{\tt mode} directives are used by the compiler in two ways.  First,
they are used for mode inferencing via the {\tt modeinfer} compiler
option (Section~\ref{sec:CompilerOptions}).  As noted below, the mode
analyzer treats mode annotations in a somewhat simplified manner.
Secomd, mode annotations are used for the tabling directives {\tt
  auto\_table} and {\tt suppl\_table}.  (See
Section~\ref{tabling_directives} for detailed examples.)  In addition
to their use in the compiler, mode annotations constitute a part of
this manual's description of each predicate.

Mode indicators have the following forms.
\begin{description}
\item[{\tt +}] The argument is an input to the predicate.  In every
  invocation of the predicate, the argument position must contain a
  non-variable term.  The argument may not necessarily be ground, but the
  call is guaranteed not to alter this argument.  Examples:

  \demo{:- mode see(+), assert(+).}

  The compiler's mode analyzer treats the {\tt +} mode indicator as if
  it were ground.
\item[{\tt -}] The argument is an output of the predicate.  In every
  invocation of the predicate the argument position {\em will always
    be a variable\/} (as opposed to the {\tt \#} annotation below).
  This variable is unified with the value returned by the predicate.
  We note that Prolog does not enforce the requirement that output
  arguments should be variables; however, output unification is not
  very common in practice.

	\demo{:- mode cputime(-).}

        In the mode analyzer, the mode indicator {\tt -} is treated in
        the same way as {\tt ?}.
\item[{\tt \#}]
	This argument is either:
	\begin{itemize}
	\item	An output argument of the predicate for which a non-variable
		value may be supplied for this argument position.  If such a
		value is supplied, the result in this position is unified with
		the supplied supplied value.  The predicate fails if this
		unification fails.  If a variable term is supplied, the
		predicate succeeds, and the output variable is unified with
		the return value.

		\demo{:- mode '='(\#,\#).}
	\item	An input/output argument position of a predicate that has
		only side-effects (usually by further instantiating that
		argument).  The {\tt \#} symbol is used to denote the $\pm$
		symbol that cannot be entered from the keyboard.
	\end{itemize}
        In the mode analyzer, the mode indicator {\tt -} is treated in
        the same way as {\tt -}.
\item[{\tt ?}]
	This argument does not fall into any of the above categories. 
        Typical cases would be the following:
	\begin{itemize}
	\item	An argument that can be used both as input and as output
		(but usually not with both uses at the same time).

 \demo{:- mode functor(?,?,?).}
	\item	An input argument where the term supplied can be a variable
		(so that the argument cannot be annotated as {\tt +}), or is
		instantiated to a term which itself contains uninstantiated
		variables, but the predicate is guaranteed {\em not\/} to
		bind any of these variables.

		\demo{:- mode var(?), write(?).}
	\end{itemize}
\end{description}
We try to follow these mode annotation conventions throughout this manual.

%Finally, we warn the user that {\tt mode} declarations can be error-prone,
%and since errors in mode declarations do not show up while running the
%predicates interactively, unexpected behavior may be witnessed in compiled
%code, optimized to take modes into account (currently not performed by
%XSB)\@.  However, despite this danger, {\tt mode} annotations can be
%a good source of documentation, since they express the programmer's
%intention of data flow in the program.
%

\subsubsection{Tabling Directives}\label{tabling_directives}
\index{tabling!directives}\index{directives!tabling}
\index{static analysis!auto\_table}
\index{static analysis!suppl\_table}
%-----------------------------------------------------
\index{declarations!\texttt{auto\_table}} Tabling is often necessary
to ensure that programs terminate, and can be useful as an
optimization strategy as well.  The underlying engine of XSB is based
on SLG, a form of resolution that maintains a table of calls and their
answers for each predicate declared as {\em tabled}.  Predicates that
are not declared as tabled execute as in Prolog, eliminating the
expense of tabling when it is unnecessary.

\paragraph{Automatic Tabling for Termination: {\tt auto\_table}}
The simplest way to use tabling is to include the directive

\demo{:- auto\_table.}

\noindent
anywhere in the source file.  {\tt auto\_table} declares enough of the
predicates tabled so that the program will terminate as long as it has
a finite number of subgoals and answers.  Programs that have no
function symbols have this property, as do some programs with function
symbols -- as long as the functions have a limited depth in an
evaluation.  Vanilla SLG resolution ensures that any query to such
programs will terminate, and in the rest of this section, we restrict
consideration to such programs. As an aside, XSB can be made to terminate
  soundly on {\em any} program if both call abstraction and answer
  abstraction are used \cite{GroS13,RigS14}.  However, these features
  are not yet included in {\tt auto\_table}.
  
Obviously, not all predicates will need to be tabled for a program to
terminate.  The {\tt auto\_table} compiler directive tables only those
predicates of a module that appear to static analysis to contain an
infinite loop, or that are called directly through {\tt tnot/1}.  It
is perhaps more illuminating to demonstrate these conditions through
an example.  For instance, in the program.

%tls commented out minipage because latex was formatting badly,
\begin{center}
%\begin{minipage}{3in}
\begin{verbatim}
:- auto_table. 

p(a) :- s(f(a)). 

s(X) :- p(f(a)).

r(X) :- q(X,W),r(Y).

m(X) :- tnot(f(X)).

:- mode ap1(-,-,+).
ap1([H|T],L,[H|L1]) :- ap1(T,L,L1).

:- mode ap(+,+,-).
ap([],F,F).
ap([H|T],L,[H|L1]) :- ap(T,L,L1).

mem(H,[H|T]).
mem(H,[_|T]) :- mem(H,T).
\end{verbatim}
%\end{minipage}
\end{center}

\noindent
The compiler prints out the messages
\begin{verbatim}
% Compiling predicate s/1 as a tabled predicate
% Compiling predicate r/1 as a tabled predicate
% Compiling predicate m/1 as a tabled predicate
% Compiling predicate mem/2 as a tabled predicate
\end{verbatim}

\index{termination}
Terminating conditions were detected for {\tt ap1/3} and {\tt ap/3}, but
not for any of the other predicates.

The minimal set of tabled predicates needed to ensure termination for
a given program is undecidable.  However, {\tt auto\_table} gives an
approximation of tabled programs which we hope will be useful for most
programs.  \comment{ Practically, refining the set of tabled
  predicates deduced by {\tt auto\_table} is still an open research
  problem.  } It should be noted that the presence of meta-predicates
such as {\tt call/1} makes any static analysis useless, so that the
{\tt auto\_table} directive should not be used in such cases.

Predicates can be explicitly declared to be tabled as well. The {\tt
  table/1} declaration (Section~\ref{sec:TablingPredicates}) provides
many powerful options for controlling the behavior of program
execution through tabling.

\index{static analysis!suppl\_table}
\index{declarations!\texttt{suppl\_table}}
\paragraph{Automatic Tabling for Efficiency: {\tt suppl\_table}}
Another use of tabling is to filter out redundant solutions for
efficiency rather than termination.  In this case, suppose that the
directive {\tt edb/1} were used to indicate that certain predicates were
likely to have a large number of clauses.  Then the action of the declaration
{\tt :- suppl\_table} in the program:
\begin{verbatim}
:- edb(r1/2).
:- edb(r2/2).
:- edb(r3/2).

:- suppl_table.

join(X,Z):- r1(X,X1),r2(X1,X2),r3(X2,Z).
\end{verbatim}
would be to table {\tt join/2}.  The {\tt suppl\_table} directive is
the XSB analogue to the deductive database optimization, {\em
supplementary magic templates} \cite{BeRa91}.  {\tt suppl\_table/0} is
shorthand for {\tt suppl\_table(2)} which tables all predicates
containing clauses with two or more {\tt edb} facts or tabled
predicates.  By specifying {\tt suppl\_table(3)} for instance, only
predicates containing clauses with three or more {\tt edb} facts or
tabled predicates would be tabled.  This flexibility can prove useful
for certain data-intensive applications.


\subsubsection{Indexing Directives}\label{indexing_directives}
\index{indexing!directives}\index{directives!indexing}
\index{dynamic code!indexing}
%-------------------------------------------------------------

The XSB compiler by default generates an index on the principal
functor of the first argument of a predicate.  However, XSB offers
other options for indexing, the details of which depend on whether the
predicate to be indexed is dynamic or static. 

\paragraph{Indexing of Dynamic Code}
XSB's indexing of dynamic code is extremely powerful, and is explained
in detail in Section~\ref{sec:assert}.  Here, we only offer a brief
overview.  Dynamic code may have hash-based indexing on any set of
arguments, on any set of combinations of of arguments.  For instance,
when converted to Prolog, RDF triples may be accessed in a variety of
different ways, and the indexing needs to reflect this.  One way to
index such triples is:

\demo{:- index(rdf\_triple/3,[1+2+3,2+3,1+2,1+3,1,3,2]).}

\noindent
This statement has different indexes on {\tt rdf\_triple/3} depending
on whether it is called with all three arguments bound, the second and
third arguments bound, the first and second arguments bound, the first
and third, or simply the first, the second, or the third.  When loaded
using a version of {\tt load\_dyn\_gen/2} that uses XSB's canonical
reader and does not preserve order, about 200,000 such triples can be
loaded and indexed per second on a server from 2019.  The indexing
above has supported knowledge graphs of many tens of millions of
edges.

XSB also allows indexing {\em within} arguments in similar
combinations.  For instance, while standard RDF triples like the ones
described above do not allow function symbols, a processed version of
a knowledge graph might make heavy use of Prolog functions.  In one
application, edges of a processed knowledge graph were indexed as:

\begin{verbatim}
:-index(proc_rdf/6,[*(3)+*(4)+*(5),*(3)+*(5),*(3)+*(4),*(4)+*(5),*(3),*(5),*(4)]).
\end{verbatim}
\noindent
which indicates that {\tt proc\_rdf/6} uses different indexes
depending on whether arguments 3,4 and 5 are bound, in which case it
indexes within the term of each argument to a maximum depth of 4, then
on whether arguments 4 and 5 are bound, and so on.  Although {\tt
  rdf\_proc/6} is bigger than {\tt rdf\_triple/3} and has more
sophisticated indexing it loads only slightly slower.  As with {\tt
  rdf\_triple/3}, knowledge graphs of many tens of millions of edges
are represented using {\tt rdf\_proc/6}, and heavily used.

\paragraph{Static Code}
Indexing on static code in XSB is currently much simpler than that for
dynamic code.  Predicates that have over say, 10,000 clauses do not
compile quickly in XSB.  Furthermore, predicates with a large number
of clauses are usually facts or at most simple rules; and as noted in
Section~\ref{sec:dynamic-code} such clauses are ``compiled'' into
essentially the same byte code whether they are static or dynamic.
For these reasons, elaborate indexes of static code have not (yet)
been implemented in XSB.

With that said, in many cases the first argument of a static predicate
may not be the most appropriate argument for indexing and changing the
order of arguments may seem unnatural.  In these cases, the user may
generate an index on any other argument by means of an indexing
directive.  This is a directive of the form:

\demo{:- index Functor/Arity-IndexArg.}

\noindent
indicating that an index should be created for predicate 
{\tt Functor}/{\tt Arity} on its ${\tt IndexArg}^{\rm th}$ argument.

% TES: obsolete
%One may also use the form:
%
%\demo{:- index(Functor/Arity, IndexArg, HashTableSize).}
%
%\index{declarations!\texttt{index/2}}
%\noindent
%which allows further specification of the size of the hash table to
%use for indexing this predicate if it is a {\em dynamic} predicate.
%For predicates that are dynamically loaded, this directive can be used
%to specify indexing on more than one argument, or indexing on a
%combination of arguments (see its description on
%page~\pageref{index_dynamic}).  For a compiled predicate the size of
%the hash table is computed automatically, so {\tt HashTableSize} is
%ignored.

%All of the values {\tt Functor}, {\tt Arity}, {\tt IndexArg}
%(and possibly{\tt HashTableSize})
%should be ground in the directive.  More specifically, {\tt Functor}
%should be an atom, {\tt Arity} an integer in the range 0..255, and
%{\tt IndexArg} an integer between 0 and {\tt Arity}.  If {\tt
%  IndexArg} is equal to~0, then no index is created for that
%predicate. An {\tt index} directive may be placed anywhere in the file
%containing the predicate it refers to.

As an example, if we wished to create an index on the third argument 
of predicate {\tt foo/5}, the compiler directive would be:

\demo{:- index foo/5-3.}

% TES: Snif :-( Took out unification factoring for Version 4.0, since it hasn't
% been maintained so it probably doesn't work, and if it does I doubt
% it would give us a great speedup.  If I am wrong about this, I will
% joyfylly put it back in.

%\subsubsection{Unification Factoring}\label{transformational_indexing}
%\index{indexing!transformational}
%When the clause heads of a predicate have portions of arguments common
%to several clauses, indexing on the principal functor of one argument
%may not be sufficient.  Indexing may be improved in such cases by the
%use of unification factoring.  Unification Factoring is a program
%transformation that ``factors out'' common parts of clause heads,
%allowing differing parts to be used for indexing, as illustrated by
%the following example:
%\begin{center}
%\tt
%\begin{tabular}{ccc}
%\begin{tabular}{l}
%p(f(a),X) :- q(X). \\
%p(f(b),X) :- r(X).
%\end{tabular}
%& $\longrightarrow$ &
%\begin{tabular}{l}
%p(f(X),Y) :- \_\$p(X,Y). \\
%\_\$p(a,X) :- q(X). \\
%\_\$p(b,X) :- r(X).
%\end{tabular}
%\end{tabular}
%\end{center}
%The transformation thus effectively allows $p/2$ to be indexed
%on atoms $a/0$ and $b/0$.  Unification Factoring is transparent
%to the user; predicates created by the transformation are internal
%to the system and do not appear during tracing.
%
%The following compiler directives control the use of unification
%factoring \footnote{Unification factoring was once called
%transformational indexing, hence the abbreviation {\tt ti} in the
%compiler directives}:
%\begin{description}
%\item[{\tt :- ti(F/A).}] Specifies that predicate $F/A$ should be
%%	compiled with unification factoring enabled.
%\item[{\tt :- ti\_off(F/A).}] Specifies that predicate $F/A$ should be
%	compiled with unification factoring disabled.
%\item[{\tt :- ti\_all.}] Specifies that all predicates defined in the
%	file should be compiled with unification factoring enabled.
%\item[{\tt :- ti\_off\_all.}] Specifies that all predicates defined in
%	the file should be compiled with unification factoring disabled.
%\end{description}
%By default, higher-order predicates (more precisely, predicates named
%{\it apply\/} with arity greater than 1) are compiled with unification
%factoring enabled.  It can be disabled using the {\tt ti\_off}
%directive.  For all other predicates, unification factoring must be
%enabled explicitly via the {\tt ti} or {\tt ti\_all} directive.  If
%both {\tt :- ti(F/A).} ({\tt :- ti\_all.}) and {\tt :- ti\_off(F/A).}
%({\tt :- ti\_off\_all.}) are specified, {\tt :- ti\_off(F/A).} ({\tt
%:- ti\_off\_all.}) takes precedence.  Note that unification factoring
%may have no effect when a predicate is well indexed to begin
%with.  For example, unification factoring has no effect on the
%following program:
%\begin{center}
%\tt
%\begin{tabular}{l}
%p(a,c,X) :- q(X). \\
%p(b,c,X) :- r(X).
%\end{tabular}
%\end{center}
%even though the two clauses have $c/0$ in common.  The user may
%examine the results of the transformation by using the {\tt ti\_dump}
%compiler option (see Section~\ref{sec:CompilerOptions}).

\subsubsection{Other Directives} \label{other-directives}
%==============================================

XSB has other directives that might not be found in other Prolog systems.

\index{Unicode}
\begin{description}
  \standarditem{\mif encoding(+Charset)}{encoding/1}
%
All source code files are initially assumed to use the UTF-8 encoding
on Linux and the Mac, and CP1252 on Windows.  When the {\tt
  encoding/1} directive is encountered the remainder of the source
file will be read using the character set indicated by {\tt Charset}.
(See \ref{sec-charsets} for a description of character sets.)  Thus,
{\tt encoding/1} can indicate that a file is to be read using
$Charset$ or that multiple character sets are used within a given
file.

%
\desc{:- hilog $atom_1, \ldots, atom_n$.}
%
Declares symbols $atom_1$ through $atom_n$ as HiLog symbols.  The {\tt
  hilog} declaration should appear {\em before} any use of the
symbols.  See Chapter~\ref{Syntax} for the a full description of this
directive and how it is used.
%
\desc{:- ldoption($Options$).}
%
This directive is only recognized in the header file ({\tt .H} file)
of a foreign module. See the chapter {\it Foreign Language Interface}
(Section~\ref{foreign}) for details.
%
\desc{:- compiler\_options($OptionsList$).}  Indicates that the
compiler options in the list $OptionsList$ should be used to compile
this file.  This must appear at the beginning of the file.  These
options will override any others, including those given in the
compilation command.  See Section~\ref{sec:CompilerOptions} for full
details.

\end{description}

\subsection{Inline Predicates}\label{inline_predicates}
\index{compiler!inlines}\index{inlines!compiler}
%======================================================

{\em Inline predicates} represent optimized operations in the SLG=WAM.
Calls to inline predicates are compiled into a sequence of WAM
instructions in-line, i.e. without actually making a call to the
predicate.  Thus, for example, relational predicates (like {\tt >/2},
{\tt >=/2}, etc.)  compile essentially to a subtraction followed by a
conditional branch.  As a result, calls to inline predicates will not
be trapped by the debugger, and their evaluation will not be visible
during a trace of program execution.  Inline predicates are expanded
specially by the compiler and thus {\em cannot be redefined by the
  user without changing the compiler}.

There are two kinds of inline predicates: ``primitive'' and
``non-primitive''.  Primitive predicates never need to be imported,
even when compiling with the {\tt sysmod} option
(Section~\ref{sec:CompilerOptions}).  Table~\ref{inlinepredicatetable}
lists these primitive inline predicates of XSB \version.  Those
predicates that start with \verb|_$| are internal predicates that are
also expanded in-line during compilation.

\begin{table}[htbp]\centering{\tt
\begin{tabular}{lllll}
\verb|'='/2|    &\verb|'<'/2|	&\verb|'=<'/2|  &\verb|'>='/2| &\verb|'>'/2| \\
\verb|'=:='/2|  &\verb|'=\='/2|	&is/2           &\verb|'@<'/2| &\verb|'@=<'/2|\\
\verb|'@>'/2|	&\verb|'@>='/2|	&\verb|'=='/2|	&\verb|'\=='/2|&fail/0  \\
true/0		&var/1		&nonvar/1	&halt/0	       &'!'/0 \\
min/2           &max/2          &\verb|'><'|/2  &\verb|**|/2   &sign/1 \\
'\_\$cutto'/1	&'\_\$savecp'/1	&'\_\$builtin'/1
\end{tabular}}
\caption{The Inline Predicates of XSB}\label{inlinepredicatetable}
\end{table}

We warn the user to be cautious when defining predicates whose functor
starts with {\tt \_\$} since the names of these predicates may
interfere with some of XSB's internal predicates.  The situation may
be particularly severe for predicates like {\tt '\_\$builtin'/1} that
are treated specially by the XSB compiler.

Non-primitive predicates are also inlined if the {\tt optimize}
compiler option is used.  They are usually standard predicates that do
not have to be imported unless the {\tt sysmod} compiler option is
used.  These predicates are generally common predicates that have been
written in C in XSB such as {\tt arg/3}, {\tt atom\_codes/3} and other
ocmmonly used predicates.

\section{A Note on ISO Compatibility} \label{sec:iso}
\index{ISO Compatibility}

In \version, an effort has been made to ensure compatibility with the
core Prolog ISO standard~\cite{ISO-Prolog}.  In this section, we
summarize the differences with the ISO standard.  XSB implements
almost all ISO built-ins and evaluable functions, although there are
semantic differences between XSB's implementation and that of the ISO
standard in certain cases.

The main difference of XSB from the ISO semantics is that XSB does not
support the logical update semantics for assert and retract, but
instead supports an immediate semantics.  XSB does, however support
the logical update semantics for incremental tables.

%Despite the patholical examples that can be devised using
%the immediate semantics, the logical semantics for assert is not often
%critical for single-threaded applications.  It is however, critical
%for multi-threaded applications, and XSB will support this in the
%future.

In terms of syntax, \version{} of XSB mostly supports ISO syntax for
Prolog, and XSB's I/O system can be set to use as character encodings
UTF-8 which includes ASCII as a subset (default on Linux and the Mac);
CP-1252 (default on Windows); or Latin-1.  Beyond XSB's support for
Hilog which is non-ISO, most differences are fairly minor.  However,
as XSB supports only for UTF-8, those ISO predicates relating to
different character sets, such as {\tt char\_conversion/2}, {\tt
  current\_char\_conversion/2} and othersd.

A somewhat more minor difference involves XSB's implementation of ISO
streams.  XSB can create streams from several first-class objects,
including urls, pipes, atoms, and consoles in addition to files.
However by default, XSB opens streams in binary mode, rather than text
mode in opposition to the ISO standard, which opens streams in text
mode.  This makes no difference in UNIX or LINUX, for which text and
binary streams are identical, but does make a difference in Windows,
where text files are processed differently than binary files.

As a final point, XSB currently throws an {\em error/3} term in its
error ball, rather than an {\em error/2} term. 

% TLS: how about floats?
% public/private

Most other differences with the core standard are mentioned under
portability notes for the various predicates.  

\comment{
% We're halfway ok on this by now.
However, we do not
always note when there are deviations in the types of errors reported
by predicates.  While XSB throws errors whenever the standard throws
errors, and vice-versa sometimes XSB may throw a different error than
specified by the standard.  This is often due to an effort in XSB to
minimize the amount of error checking performed, and should rarely if
ever cause a problem for applciations.
}

XSB supports most new features mentioned in the revisions to the core
standard~\cite{ISO-Revision}, including {\tt call\_cleanup/2} and
various library predicates such as {\tt subsumes/2}, {\tt
  numbervars/3} and so on.
%XSB also has strong support for the working multi-threading Prolog
%standard~\cite{Prolog-MT-ISO}, and XSB has been one of the first
%Prologs to support this standard.
However, because XSB has an atom-based module system it does {\em not}
support the ISO standard for Prolog modules.

%%% Local Variables: 
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "manual1"
%%% End: 
