\chapter[Standard and General Predicates]{Standard Predicates and Predicates of General Use} \label{standard}
%=============================================

This chapter mainly describes {\em standard} predicates, which are
always available to the Prolog interpreter, and do not need to be
imported or loaded explicitly as do other Prolog predicates.  By
default, it is a compiler error to redefine standard predicates.

\comment{This behavior can be overridden by allowing explicit
  redefinition of standard predicates (see Section~\ref{}); or
  alternatively the set of standard predicates can be easily
  reconfigured (Section~\ref{}).}

In the description below, certain standard predicates depend on HiLog
semantics; the description of such predicates have the token {\sf
HiLog} at the right of the page.  Similarly predicates that depend on
SLG evaluation are marked as {\sf Tabling}, and predicates whose
semantics is defined by the ISO standard (or whose implementation is
reasonably close to that definition) are marked as {\tt ISO}.
Occasionally, however, we include in this section predicates that are
not standard.  In such cases we denote their module in {\tt text} font
towards the middle of the page.

\comment{
\paragraph*{A Note on Types} \label{sec:types}

Numerous proposals have been made concerning typing systems for Prolog
for the purposes of program analysis, correctness checking, etc.
Analysis-based typing systems are typically lattice-based, following
from their need to compare types to understand whether one type
includes another, or from the need to determine the most specific type
that is more general than two types.  In addition the ISO standard
specifies various types of allowable input or output arguments for
various predicates.

\version{} of XSB has the following approach to program typing.
Typing in an XSB program is done through a {\em type lattice},
generated by {\em primitive type elements}.  How a primitive type is
defined is somewhat separate from how it is used by a type lattice.
For our purposes we assume that each 1-ary type element is defined by
a predicate of arity 1 that is written in a pure enough style so that
its success or failure does not depend on the state of XSB or of any
external state.  Whether these types are recursive or not has no
bearing on the type lattice.  For instance, {\tt integer} or {\tt
listOfAtoms} are primitive type elements.  Similarly, {\tt variable},
{\tt ground} are also type elements.  We say that a given term {\tt
Term} satisfies a primitive type element {\tt t} if {\tt t(Term)}
succeeds.  Given primitive type elements, complex type elements can be
formed using the boolean operations, {\tt and}, {\tt or} and {\tt
not}.  As an example, {\tt integer or not(listOfAtoms)} is a
non-primitive type element.  There is also a product operation ({\tt
,}) on type elements, so that {\tt variable, integer or
not(listOfAtoms)} is a product of the above two types.  
Satisfiability is extended to complex type elements in the obvious
manner, and an n-ary tuple of terms satisfies a n-ary product type if
each argument in the tuple satisfies the corresponding argument of the
product type.

The above description is not yet suitable for a type system as it
could not determine, for instance, that {\tt integer} is a subtype of
{\tt number}.  To determine this, an explicit {\em inclusion
statement} can be made indicating that one type is included in
another.  Thus given two elements in a type lattice with inclusion
statements, determining whether one element is more specific than
another can be done using techniques for propositional satisfiability
or stable model generation.

From an implementational level, types can be defined using the Cold
Dead Fish (CDF) package and inclusion can be detected using the CDF
theorem prover or XSB's Smodels interface.  However, for the
purposes in this section we use type elements to define inputs and
outputs of predicates, via {\tt usage statements}.  A usage statement
for an n-ary predicate {\tt p/n} consists of an n-ary product of
primitive types that should be satisfied on a call to {\tt p/n} along
with a n-ary product of primitive types that should hold on success of
{\tt p/n} given the types that hold at call.  If both the the product
types hold, the usage statement is satisfied.  Each successful call to
{\tt p/n} should satisfy one of the usage statements.

As defined, usage statements are very general: they can check not only
traditional Prolog types ({\tt atom}, {\tt integer}, etc), but also
non-Prolog types, such as the fact that the input to a given argument
should be a positive integer, and even instantiation patterns.  For
the various predicates defined in this section, we use the following
conventions for usages and error reporting.  {\bf domain}, {\bf type}
and {\bf instantiation} errors arise from the failure of an argument
of a predicate to satisfy the corresponding type element in the input
term of the usage statements.  All of these could be called type
errors given the system described above.  However to (partially)
conform to the ISO standard, we reserve the {\bf instantiation error}
to mean failure that occurs when an argument does not satisfy a type
in a boolean lattice generated by {\tt var} and {\tt ground}.  A {\bf
  type error} occurs when an argument does not satisfy a type in a
boolean lattice generated by other ISO types, such as {\tt integer},
{\tt atom}, etc.  A {\bf domain error} arises from other such errors.
We note that in certain cases, our designation of an error type may
differ from the ISO standard.
}

%--------------------------------------------------------------------------------------------------
\section{Input and Output}
\index{streams}

\subsection{I/O Streams in XSB}
XSB's I/O is based on ISO-style streams, although it also supports
older DEC-10 style file handling.  The use of streams provides a
unified interface to a number of different classes of sources and
sinks.  Currently these classes include textual and binary files,
console input and output, pipes, and atoms; in the future sockets and
urls may be handled under the stream interface.  When streams are
opened, certain actions may occur depending on the class of the source
or sink and on the wishes of the user.  For instance when a file {\tt
F} is opened for output mode, an existing file {\tt F} may be
truncated (in write mode) or not (in append mode).  In addition,
various operations may or may not be valid depending on the class of
stream.  For instance, repositioning is valid for an atom or file but
not a pipe or console.

XSB provides several default I/O streams, which make it easier for a
user to embed XSB in other applications.  These streams include the
default input and output streams.  They also include the standard
error stream, to which XSB writes all error messages.  By default the
standard error stream is the same as the standard output stream, but
it can be redirected either by UNIX shell-style I/O redirection or by
the predicates {\tt file\_reopen/4} and {\tt file\_clone/3}.
Similarly there is the standard warning stream (to which all system
warnings are written), the standard message stream, the standard
debugging stream (to which debugging information is written), and the
standard feedback stream (for interpreter prompts, yes/no answers,
etc).  All of these streams are aliased by default to standard output,
and can be redirected by the predicates {\tt file\_reopen/4} and {\tt
  file\_clone/3}.  Such redirection can be useful for logging, or
other purposes.

\index{aliases!streams}
\index{aliases!streams!user\_input}
\index{aliases!streams!user\_output}
\index{aliases!streams!user\_error}
\index{aliases!streams!user\_warning}
\index{aliases!streams!user\_message}

Streams may also be aliased: the default input and output streams are
denoted by {\tt user\_input} and {\tt user\_output} and they refer to
the standard input and standard output streams of the
process \footnote{For backwards compatibility, the default input
  stream can also be aliased by {\tt user} or {\tt userin}, and the
  default output stream by {\tt user} or {\tt userout}.}.  Similarly,
XSB's error, warning and message streams uses the aliases {\tt
  user\_error}, {\tt user\_warning} and {\tt user\_message}
respectively.

Streams are distinguished by their {\tt class} -- whether they are
file or atom, etc.; as well as by various properties.  These
properties include whether a stream is positionable or not and whether
a (file) stream is textual or binary.

\bi
\item {\tt Console}: The default streams mentioned above are
console streams, which are textual and not repositionable.
%
\item {\tt File}:  A file stream corresponds to an operating system
file and is repositionable.  On Windows, binary files and textual
files differ, while on UNIX they are the same.  
%
\item {\tt Atom}: XSB can read from an atom, just as it can from a file.
Atoms are considered to be textual and repositionable.  Writing to
atoms via streams is not currently available in XSB, although 
the predicate {\tt term\_to\_atom/[2,3]} contains much of the
functionality that such streams would provide.

\item {\tt Pipe}: XSB can also open pipes either directly, or as part
of its ability to spawn processes.  When made into streams, pipes are
textual and not repositionable.
\ei

%------------------------------------------------------------------------------------------------
\subsubsection{I/O Stream Implementation} \label{sec:IO-streams}

A user may notice that XSB's I/O streams are small integers, but they
should not be confused with the file descriptors used by the OS.  The
OS file descriptors are objects returned by the C {\tt open} function;
XSB I/O streams indices into the internal XSB table of open files and
associated information. The OS does not know about XSB I/O streams,
while XSB (obviously) does know about the OS file descriptors. An OS
file descriptor may be returned by certain predicates (e.g.  {\tt
  pipe\_open/2} or user-defined I/O).  In the former case, a file
descriptor can be promoted to XSB stream by {\tt open/\{3,4\}} and in
the latter by using the predicate {\tt fd2iostream/2}.

When it starts, XSB opens a number of standard I/O streams that it
uses to print results, errors, debugging info, etc. The descriptors
are described in the file {\tt prolog\_includes/standard.h}. This file
provides the following symbolic definitions:
%%
\index{streams!system}
\index{streams!STDDBG}
\index{streams!STDERR}
\index{streams!STDFDBK}
\index{streams!STDIN}
\index{streams!STDOUT}
\index{streams!STDWARN}
\index{streams!STDMSG}
\index{streams!system}
\begin{verbatim}
    #define STDIN            0
    #define STDOUT           1
    #define STDERR           2
    #define STDWARN          3    /* output stream for xsb warnings  */
    #define STDMSG           4    /* output for regular xsb messages */
    #define STDDBG           5    /* output for debugging info       */
    #define STDFDBK          6    /* output for XSB feedback
                                     (prompt/yes/no/Aborting/answers) */

    #define AF_INET     0     /* XSB-side socket request for Internet domain */
    #define AF_UNIX     1     /* XSB-side socket request for UNIX domain */
\end{verbatim}
%%
%------------------------------------------------------------------------------------------
\comment{
In addition, the file \verb|emu/file_modes_xsb.h| provides the definitions
for the file opening modes:
%%
\begin{verbatim}
    #define OREAD          0    /* open for read           */
    #define OWRITE         1    /* open for write          */
    #define OAPPEND        2    /* open for append         */
    #define OSTRINGR       3    /* open string for reading */
    #define OSTRINGW       4    /* open string for writing (not implemented) */
\end{verbatim}
%%
}
%------------------------------------------------------------------------------------------
These definitions can be used in user programs, if the following is
provided at the top of the source file:
%%
\begin{verbatim}
    compiler_options([xpp_on]).
    #include "standard.h"
\end{verbatim}
%%
If this header is used, the various streams can be used as any other output stream -- e.g. 
{\tt ?- write(STDWARN,'watch it!')}.
%
(Note: the XSB preprocessor is not invoked on clauses typed into an
interactive XSB session, so the above applies only to programs loaded
from a file using {\tt consult} and such.)

\subsection{Character Sets in XSB}\label{sec-charsets}
%
\index{Unicode!UTF-8}
\index{character sets}
\index{CP1252}
\index{LATIN-1}
Beginning in Version 3.5 of XSB, alternate character sets are supported.  
%
\begin{itemize}
\item {\em UTF-8} which on input automatically interprets the sequence
of bytes as UTF-8 byte sequences and decodes them to obtain the
unicode code points; and on output converts from the unicode code
points to UTF-8 byte sequences.
%
\item {\em LATIN-1} which performs no transformation on byte sequences 
(i.e. treats each byte directly as a unicode code point.)
%
\item {\em CP1252} which implements Windows code page 1252 encoding, the 
default for most Windows systems.
\end{itemize}

Other character sets, in particular UTF-16, may be supported in the
future.

In the current version of XSB, UTF-8 is the default character set when
XSB is configured on UNIX-style systems such as Linux and Mac OSX.
CP1252 is the default character set on Windows-style systems.  The
character set may be changed at any time via the Prolog flag {\tt
  character\_set}, whose value must be one of {\tt utf\_8}, {\tt
  cp1252}, or {\tt latin\_1}.  The character set that is in effect at
the time of opening a stream is the character set that will be used to
read (or write) the stream.  When XSB source code files are read by
the compiler (or by {\tt load\_dyn\_gen/2}), their encoding is assumed
to {\tt utf\_8} for all operating systems.  Note, however, that the
{\tt encoding/1} directive (\ref{other-directives}) can be placed in a
source file to change the encoding used by the compiler to read the
(remainder of the) file.


\subsection{Predicates for ISO Streams}

\begin{description}

\isoitem{open(+SourceSink,+Mode,-Stream)}{open/3}
%
{\tt open/1} creates a stream for the source or sink designated in
{\tt SourceSink}, and binds {\tt Stream} to a structure representing
that stream.  
%
\bi
\item If {\tt SourceSink} is an atom, or the term {\tt file(File)}
where {\tt File} is an atom, the stream is a file stream.  In this
case {\tt Mode} can be 
\bi
\item {\tt read} to create an input stream.  In Windows, whether the
file is textual or binary is determined by the file's properties.
%
\item {\tt write} to create an output stream.  Any previous file with
a similar path is removed and a (textual) file is created which becomes
a record of the output stream.  
%
\item {\tt write\_binary} to create an output stream.  Any previous file with
a similar path is removed and a file is created which becomes
a record of the output stream.  The file created is binary in Windows,
while in UNIX {\tt write\_binary} has the same effect as {\tt write}.
%
\item {\tt append} to create an output stream.  In this case the
output stream is appended to the contents of the file, if it exists,
and otherwise a new file is created for (textual) output
%
\item {\tt append\_binary} to create an output stream.  In this case the
output stream is appended to the contents of the file, if it exists,
and otherwise a new file is created for (binary) output
\ei
\item If {\tt SourceSink} is the term {\tt atom(Atom)} where {\tt
Atom} is an atom, the stream is an atom stream.  In this case {\tt
Mode} currently can only be {\tt read}.  This stream class, which
reads from interned atoms, is analogous to C's {\tt sscanf()}
function.
%
\item If {\tt SourceSink} is the term {\tt pipe(FileDescriptor)}
where {\tt FileDescriptor} is an integer, then a pipe stream is opened
in the mode for {\tt FileDescriptor}.
\ei

\compatibility This predicate extends the ISO definition of {\tt
open/3} to include strings and pipes as well as the file modes {\tt
write\_binary} and {\tt append\_binary}.

{\bf Error Cases}
\bi
\item 	{\tt SourceSink} or {\tt Mode} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Mode} is not a valid I/O mode
\bi
\item 	{\tt domain\_error(io\_mode,Mode)}
\ei
%
\item {\tt SourceSink} is a file and cannot be opened, or opened in
  the desired mode, does not exist, etc.
\bi
\item 	{\tt permission\_error(open,file,SourceSink)}
\ei
\ei

\isoitem{open(+File,+Mode,-Stream,+Options)}{open/4}
%
{\tt open/4} behaves as does {\tt open/3}, but allows a list of
options to be given.  The current options are a subset of ISO options
and are:
\bi
\item {\tt alias(A)} allows the stream to be aliased to an atom {\tt
  A}.
%
\item {\tt type(T)} has no effect on file streams in UNIX, which are
  always textual, but in Windows if {\tt T} is {\tt binary} a binary
  file is opened.
\ei
%
{\bf Error Cases}  Error cases are the same as {\tt open/3} but with
the addition: 
\bi
\item {\tt Option\_list} contains an option {\tt O} that is not a
  (currently implemented) stream option.  
\bi
\item {\tt domain\_error(stream\_option,O)}
\ei
\item An element of {\tt OptionsList} is alias(A) and A is already
  associated with an existing
  %thread,
  queue, mutex or stream 
\bi
\item {\tt permission\_error(create,alias, A)}
\ei
\item An element of {\tt OptionsList} is alias(A) and A is not an atom
\bi
\item {\tt type\_error(atom,A)}
\ei
\ei
%
\compatibility 
%
The ISO option {\tt reposition(Boolean)} currently has no effect on
streams, because whether or not the stream is repositionable or not
depends on the stream class.  The ISO option {\tt eof\_action(Action)}
currently has no effect on file streams.  If these options are
encountered in {\tt Options}, a warning is issued to {\tt STDWARN}.

\isoitem{close(+Stream\_or\_alias,+OptionsList)}{close/2}
%
{\tt close/2} closes the stream or alias {\tt Stream\_or\_alias}.
{\tt OptionsList} allows the user to declare whether a permission
error will be raised in XSB upon a resource or system error from the
closing function (e.g. {\tt fclose()} or other system function).  If
{\tt OptionsList} is non-empty and contains only terms unifying with
{\tt force(true)} then such an error will be ignored (possibly leading
to unacknowledged loss of data).  Otherwise, a permission error is
thrown if {\tt fclose()} or other system function returns an error
condition.  If the stream class of {\tt Stream\_or\_alias} is an atom,
then the only action taken is to close the stream itself -- the
interned atom itself is not affected.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Stream\_or\_alias} is neither a variable, nor a stream term
  nor an alias.  
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item {\tt OptionList} contains an option {\tt O} that is not a closing
option.
\bi
\item {\tt domain\_error(close\_option,O)}
\ei
\item {\tt OptionList} contains conflicting options
\bi
\item {\tt domain\_error(close\_option,OptionList)}
\ei
\item 	Closing the stream produces an error (and {\tt OptionsList} is
	a non-empty list containing terms of the form {\tt force(true)}).
\bi
\item 	{\tt permission\_error(close,file,Stream\_or\_alias)}
\ei
\ei

\isoitem{close(+Stream\_or\_alias)}{close/1}
%
{\tt close/1} closes the stream or alias {\tt Stream\_or\_alias}.\\
Behaves as {\tt close(Stream\_or\_alias,[force(false)])}.

\isoitem{set\_input(+Stream\_or\_alias)}{set\_input/1}
    Makes file {\tt Stream\_or\_alias} the current input stream. 

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Stream\_or\_alias} is neither a variable, nor a a stream
  term nor an alias.  
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\isoitem{set\_output(+Stream\_or\_alias)}{set\_output/1}
    Makes file {\tt Stream\_or\_alias} the current output stream. 

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Stream\_or\_alias} is neither a variable, nor a a stream
  term nor an alias.  
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open output stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\isoitem{stream\_property(?Stream,?Property)}{stream\_property/2}
%
This predicate backtracks through the various stream properties that
unify with {\tt Property} for the stream {\tt Stream}.  Currently,
the following properties are defined.

\bi
\item {\tt stream\_class(C)} gives the stream class for a file:
i.e. {\tt file}, {\tt atom}, {\tt console} or {\tt pipe}.

\item {\tt file\_name(F)} is a property of {\tt Stream}, if
{\tt Stream} is a file stream and {\tt F} is the file name
associate with {\tt Stream}.  The full operating system
path is used.
%
\item {\tt type(T)} is a property of {\tt Stream}, if
{\tt Stream} is a file stream and {\tt T} is the file type
of {\tt Stream}: {\tt text} or {\tt binary}.
%
\item {\tt mode(M)} is a property of {\tt Stream}, if {\tt
M} represents the I/O mode with which {\tt Stream} was
opened: i.e. {\tt read}, {\tt write}, {\tt append}, {\tt
write\_binary}, etc., as appropriate for the class of {\tt
Stream}.
%
\item {\tt alias(A)}  is a property of {\tt Stream}, if
{\tt Stream} was opened with alias {\tt A}.
%
\item {\tt input}  is a property of {\tt Stream}, if {\tt
Stream} was opened in the I/O mode: {\tt read}.
% 
\item {\tt output}  is a property of {\tt Stream}, if {\tt
Stream} was opened in the I/O mode: {\tt write}, {\tt
append}, {\tt write\_binary}, or {\tt append\_binary}.
%
\item {\tt reposition(Bool)} is true, if {\tt Stream} is
repositionable, and false otherwise. 
%
\item {\tt end\_of\_stream(E)} returns {\tt at} if the end of stream
condition for {\tt Stream} is true, and {\tt not} otherwise.
%
\item {\tt position(Pos)} returns the current position of the stream
as determined by {\tt fseek{}} or the byte-offset of the current
stream within an atom.  In either case, if an end-of-stream condition
occurs, the token {\tt end\_of\_file} is returned.
%

%
\item {\tt eof\_action(Action)} is {\tt reposition} if the stream class
is {\tt console}, {\tt eof\_code} if the stream class is {\tt file},
and {\tt error} is the stream class is {\tt pipe} or {\tt atom}.
\end{itemize}

\isoitem{flush\_output(+Stream\_or\_alias)}{flush\_output/1}
%
Any buffered data in {\tt Stream\_or\_alias}  gets flushed.  If
{\tt Stream} is not buffered (i.e. if it is of class {\tt
atom}), no action is taken.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Stream\_or\_alias} is neither a variable, nor a a stream
  term nor an alias.  
\bi
\item 	{\tt domain\_error(Stream\_or\_alias,Stream)}
\ei
\item 	{\tt Stream} is not associated with an open output stream 
\bi
\item 	{\tt existence\_error(Stream\_or\_alias,Stream)}
\ei
\item 	Flushing (i.e. {\tt fflush()}) returns an error.
\bi
\item 	{\tt permission\_error(flush,stream,Stream)}
\ei
\ei

\isoitem{flush\_output}{flush\_output/0}
%
Any buffered data in the current output stream gets flushed.

\isoitem{set\_stream\_position(+Stream\_or\_alias,+Position)}{set\_stream\_position/2}
%
If the stream associated with {\tt Stream\_or\_alias} is
repositionable (i.e. is a file or atom), sets the stream position
indicator for the next input or output operation. Position is a
positive integer, taken to be the number of bytes the stream is to be
placed from the origin.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Stream\_or\_alias} is neither a variable, nor a a stream
  term nor an alias.  
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Position} is not instantiated to a positive integer.
\bi
\item 	{\tt domain\_error(stream\_position,Position)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not repositionable, or
	repositioning returns an error. 
\bi
\item 	{\tt permission\_error(resposition,stream,Stream\_or\_alias)}
\ei
\ei



\isoitem{at\_end\_of\_stream(+Stream\_or\_alias)}{at\_end\_of\_stream/1}
%
Succeeds if {\tt Stream\_or\_alias} has position at or past the end of
stream.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Stream\_or\_alias} is neither a variable, nor a a stream
  term nor an alias.  
\bi
\item 	{\tt domain\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei
%

\isoitem{at\_end\_of\_stream}{at\_end\_of\_stream/0}
%
Acts as {\tt at\_end\_of\_stream/1} but using the current input
stream.

\end{description}

\subsubsection{Other Predicates using ISO Streams}

\begin{description}

\standarditem{file\_reopen(+FileName,+Mode,+Stream,-RetCode)}{file\_reopen/3}
%
    Takes an existing I/O stream, closes it, then opens it and
    attaches it to a file. This can be used to redirect I/O from any of the
    standard streams to a file. For instance, 
%%
\begin{verbatim}
    | ?- file_reopen('/dev/null', w, 3, Error).
\end{verbatim}
%%
    redirects all warnings to the Unix black hole. 

    On success, {\tt RetCode} is 0; on error, the return code is negative.

%-----------------------------------------------------------------------------

\standarditem{file\_clone(+SrcStream,?DestStream,-RetCode)}{file\_clone/3}
%
This is yet another way to redirect I/O. It is a Prolog interface to
the C {\tt dup} and {\tt dup2} system calls. If {\tt DestStream} is a
variable, then this call creates a new XSB I/O stream that is a clone
of {\tt SrcStream}. This means that I/O sent to either stream goes
to the same place. If {\tt DestStream} is not a variable, then it must
be a number corresponding to a valid I/O stream. In this case, XSB
closes {\tt DestStream} and makes it into a clone of {\tt
SrcStream}. 

For instance, suppose that 10 is a I/O Stream that is currently open
for writing to file {\tt foo.bar}.  Then 
%%
\begin{verbatim} 
| ?- file_clone(10,3,_).  
\end{verbatim} 
%% 
causes all messages sent to XSB standard warnings stream to go to file
{\tt foo.bar}. While this could be also done with {\tt file\_reopen},
there are things that only {\tt file\_clone} can do: 
%%
\begin{verbatim} 
| ?- file_clone(1,10,_). 
\end{verbatim} 
%% 
This means that I/O stream 10 now becomes clone of standard
output. So, all subsequent I/O will now go to standard output instead
of {\tt foo.bar}.

On success, {\tt RetCode} is 0; on error, the return code is negative.

%-----------------------------------------------------------------------------

\ourmoditem{file\_truncate(+Stream, +Length, -Return)}{file\_truncate/3}{file\_io}
    The regular file  referenced by the Stream{\tt Stream}
    is chopped to have the size of {\tt Length} bytes. Upon successful
    completion {\tt Return} is set to zero.

\portability Under Windows (including Cygwin) {\tt file\_truncate/2}
is implemented using {\tt \_chsize()}, while on Unix {\tt ftruncate()}
is used.  There are minor semantic differences between these two
system calls, which are reflected by the behavior of {\tt
file\_truncate/2} on different platforms.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Stream\_or\_alias} is neither a variable, nor a a stream
  term nor an alias.  
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item {\tt Length} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Length} is neither a variable nor an integer
\bi
\item 	{\tt type\_error(integer,Length)}
\ei
\ei
\comment{Not checking for uninstantiated Return or for negative Length}

\standarditem{tmpfile\_open(-Stream)}{tmpfile\_open/1}
    Opens a temporary file with a unique filename. The file is deleted
    when it is closed or when the program terminates.

\ourmoditem{flush\_all\_output\_streams}{flush\_all\_output\_streams/0}{error\_handler}
\index{streams!system} 
%
Flushes output streams, both user and system {\tt STDOUT}, {\tt
  STDERR}, etc.  This convenience predicate is written as
%
\begin{verbatim}
flush_all_open_streams:- 
        stream_property(S,mode(X)),(X = append ; X = write),flush_output(S),fail.
flush_all_open_streams.
\end{verbatim}

\end{description}

\subsection{DEC-IO Style File Handling}

\begin{description}
\standarditem{see(+File\_or\_stream)}{see/1}
%
Makes {\tt File\_or\_stream} the current input stream. 
%
\begin{itemize}
\item If there is an open input stream associated with the file that
  has {\tt File\_or\_stream} as its file name, and that stream was
  opened previously, then it is made the current input stream.
%
\item Otherwise, the specified file is opened for input and made the
  current input stream. If the file does not exist, {\tt see/1} throws
  a permission error.
\end{itemize}
%
Note that {\tt see/1} is incompatible with ISO aliases -- calling {\tt
  see(Alias)} with an ISO alias will try to open a file named {\tt
  Alias} rather than using the alias.  Also note that different file
names (that is, names which do not unify) represent different input
streams (even if these different file names correspond to the same
file).

{\bf Error Cases}
\bi
\item  {\tt File\_or\_stream} is  a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt File\_or\_stream} is neither a variable nor an atomic file identifier nor
  a stream identifier.
\bi
\item {\tt domain\_error(stream\_or\_path,F)}
\ei
\item File {\tt File\_or\_stream} is directory or file is not readable. 
\bi
\item {\tt permission\_error(open,file,F)}
\ei
\item File {\tt File\_or\_stream} does not exist. 
\bi
\item {\tt existence\_error(stream\_or\_path,F)}
\ei
\ei

\standarditem{seeing(?F)}{seeing/1}
    {\tt F} is unified with the name of the current input stream.
    This is exactly the same with predicate {\tt current\_input/1}
    described in Section~\ref{State}, and it is only provided for
    upwards compatibility reasons.

\standarditem{seen}{seen/0}
    Closes the current input stream. 
    Current input reverts to {\tt ``userin''} (the standard input stream).

\standarditem{tell(+F)}{tell/1}
    Makes file {\tt F} the current output stream. 
    \begin{itemize}
    \item If there is an open output stream associated with {\em F}  
          and that was opened previously 
          by {\tt tell/1}, then that stream is made the current output 
	  stream. 
    \item Otherwise, the specified file is opened for output and made the
          current output stream. If the file does not exist, it is created.
    \end{itemize}

    Also note that different file names (that is, names which do not unify) 
    represent different output streams (even if these different file names 
    correspond to the same file).

    The implementation of the ISO predicate {\tt set\_output/1}, is
    essentially that of {\tt tell/1}.

{\bf Error Cases}
\bi
\item  {\tt File\_or\_stream} is  a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt File\_or\_stream} is neither a variable nor an atomic file identifier nor
  a stream identifier.
\bi
\item {\tt domain\_error(stream\_or\_path,F)}
\ei
\item File {\tt File\_or\_stream} is directory or file is not readable. 
\bi
\item {\tt permission\_error(open,file,F)}
\ei
\item File {\tt File\_or\_stream} does not exist. 
\bi
\item {\tt existence\_error(stream\_or\_path,F)}
\ei
\ei

\standarditem{telling(?F)}{telling/1}
    {\tt F} is unified with the name of the current output stream.
    This predicate is exactly the same with predicate {\tt current\_output/1}
    described in Section~\ref{State}, and it is only provided for
    upwards compatibility reasons.

\standarditem{told}{told/0}
    Closes the current output stream. 
    Current output stream reverts to ``userout'' (the standard output stream).

\standarditem{file\_exists(+F)}{file\_exists/1}
    Succeeds if file {\tt F} exists. {\tt F} must be instantiated to
    an atom at the time of the call, or an error message is displayed on
    the standard error stream and the predicate aborts.

{\bf Error Cases}
    \begin {description}
    \item[{\tt instantiation\_error}]
	{\tt F} is uninstantiated.
    \end{description}

\standarditem{url\_encode(+Filename,-EncodedFilename)}{url\_encode/2}
   This predicate is useful when one needs to create a file whose name
   contains forbidden characters, such as \texttt{>}, \texttt{<}, and the
   like. It takes a string and encodes any forbidden character
   using an appropriate \%-sequence of characters that is acceptable as a
   file name in any OS: Unix, Windows, or Mac.
   For instance, 
   %% 
\begin{verbatim}
   | ?- url_encode('http://foo''>$',X).

   X = http%3a%2f%2ffoo%27%3e%24
\end{verbatim}
   %% 

\standarditem{url\_decode(+Filename,-EncodedFilename)}{url\_decode/2}
   This predicate performs the inverse operation with respect to 
   \texttt{url\_encode/2}. For instance, 
   %% 
\begin{verbatim}
   | ?- url_decode('http%3a%2f%2ffoo%27%3e%24',X).

   X = http://foo'>$
\end{verbatim}
   %% 

\end{description}

\index{Unicode!UTF-8}
\subsection{Character I/O}
Beginning with \version{}, XSB supports Unicode in the form of UTF-8
characters.  Due to this change, we recommend using ISO-compliant
character I/O predicates, rather than older predicates such as {\tt
  get/1}, {\tt get0/1}, {\tt put/1} and so on.  As the use of these
older predicates may sometimes give unexpected answers when used with
non-ASCII characters, they are deprecated, although they are still
available for backward compatibility.

\begin{description}
%-----------------------------
% Gets

\isoitem{get\_char(+Stream\_or\_alias,?Char)}{get\_char/2} Unifies
        {\tt Char} with the next UTF-8 character from {\tt
          Stream\_or\_alias}, advancing the position of the stream.
        {\tt Char} is unified with the atom {\tt end\_of\_file} if an
        end of file condition is detected.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Char} is not a variable or character.
\bi
\item 	{\tt domain\_error(character\_or\_variable,Char)}
\ei
\ei

\isoitem{get\_char(?Char)}{get\_char/1}
%
Behaves as {\tt get\_char/2}, but reads from the current input stream.

{\bf Error Cases}
\bi
\item 	{\tt Char} is not a variable or character.
\bi
\item 	{\tt domain\_error(character\_or\_variable,Char)}
\ei
\ei

\isoitem{get\_code(+Stream\_or\_alias,?Code)}{get\_code/2}
%
   {\tt Code} unifies with the UTF-8 code of the next character from
   {\tt Stream\_or\_alias}.  The position of the stream is advanced.
   {\tt Char} is unified with -1 if an end of file condition is
   detected.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Code} is not a variable or character code
\bi
\item 	{\tt domain\_error(character\_code\_or\_variable,Code)}
\ei
\ei

\isoitem{get\_code(?Code)}{get\_code/1}
%
Behaves as {\tt get\_code/2}, but reads from the current input
stream~\footnote{The obsolescent predicate {\tt get0/1} is defined as
  {\tt get\_code/1}.}.

{\bf Error Cases}
\bi
\item 	{\tt Code} is not a variable or character code
\bi
\item 	{\tt domain\_error(character\_code\_or\_variable,Code)}
\ei
\ei

\isoitem{get\_byte(+Stream\_or\_alias,?Byte)}{get\_byte/2}
%
   {\tt Byte} unifies with the value of the the next byte from {\tt
     Stream\_or\_alias}.  The position of the stream is advanced.
   {\tt Char} is unified with -1 if an end of file condition is
   detected.  If reading from ASCII text, {\tt get\_byte/2} will have
   the same behavior as {\tt get\_code/2}, but in general {\tt
     get\_code/2} may return multi-byte characters

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Code} is not a variable or character code
\bi
\item 	{\tt domain\_error(character\_code\_or\_variable,Code)}
\ei
\ei

\isoitem{get\_byte/1}{get\_byte/1} Behaves as {\tt get\_byte/2}, but
reads from the current input stream~\footnote{The obsolescent
  predicate {\tt get0/1} is defined using {\tt get\_byte/1}, but
  returns the next byte that does not match an ASCII whitespace
  character.}.v

{\bf Error Cases}
\bi
\item 	{\tt Code} is not a variable or {\tt Code} is not a proper value for a byte
\bi
\item 	{\tt domain\_error(byte\_code\_or\_variable,Code)}
\ei
\ei

%\standarditem{get0(?N)}{get0/1}
%
%{\tt N} is the ASCII code of the next character read from the current
%input stream (regarded as a text stream). If the current input stream
%reaches its end of file, a {\tt -1} is returned.  This predicate does
%not check for errors, so that it is faster (and potentially less safe)
%than, e.g. {\tt get\_code/1}.

%\standarditem{get(?N)}{get/1}
%    {\tt N} is the ASCII code of the next non-blank printable
%    character from the current input stream (regarded as a text
%    stream).  If the current input stream reaches its end of file, a
%    {\tt -1} is returned.

%------------------------------------
% Peeks

\isoitem{peek\_char(+Stream\_or\_alias,?Char)}{peek\_char/2}
%
Unifies {\tt Char} with the next UTF-8 character from {\tt
  Stream\_or\_alias}.  The position in {\tt Stream\_or\_alias} is
unchanged.  {\tt Char} is unified with the atom {\tt end\_of\_file} if
an end of file condition is detected.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Char} is not a variable or character.
\bi
\item 	{\tt domain\_error(character\_or\_variable,Char)}
\ei
\ei

\isoitem{peek\_char(?Char)}{peek\_char/1}
%
Behaves as {\tt peek\_char/2}, but the current input stream is used.

{\bf Error Cases}
\bi
\item 	{\tt Char} is not a variable or character.
\bi
\item 	{\tt domain\_error(character\_or\_variable,Char)}
\ei
\ei

\isoitem{peek\_code(+Stream\_or\_alias,?Code)}{peek\_code/2}
%
Unifies {\tt Code} with the next UTF-8 code from {\tt Stream\_or\_alias}.
The position in {\tt Stream\_or\_alias} is unchanged.  {\tt Code} is
unified with -1 if an end of file condition is detected.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Code} is not a variable or character.
\bi
\item 	{\tt domain\_error(character\_code\_or\_variable,Code)}
\ei
\ei

\isoitem{peek\_code(?Code)}{peek\_code/1}
%
Behaves as {\tt peek\_code/2}, but the current input stream is used.

{\bf Error Cases}
\bi
\item 	{\tt Char} is not a variable or character.
\bi
\item 	{\tt domain\_error(character\_code\_or\_variable,Code)}
\ei
\ei

\isoitem{peek\_byte(?Byte)}{peek\_byte/1} 
%
Unifies {\tt Byte} with the next byte from {\tt Stream\_or\_alias}.
The position in {\tt Stream\_or\_alias} is unchanged.  {\tt Code} is
unified with -1 if an end of file condition is detected.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Code} is not a variable or character.
\bi
\item 	{\tt domain\_error(byte\_code\_or\_variable,Code)}
\ei
\ei


\isoitem{peek\_byte(?Byte)}{peek\_byte/1}
Behaves as {\tt peek\_byte/2}, but the current input stream is used.

{\bf Error Cases}
\bi
\item 	{\tt Char} is not a variable or character.
\bi
\item 	{\tt domain\_error(byte\_code\_or\_variable,Code)}
\ei
\ei
%----------------------------------------------
% Puts
%----------------------------------------------

\isoitem{put\_char(+Stream\_or\_alias,+Char)}{put\_char/2}
%
Writes a UTF-8 character {\tt Char} to {\tt Stream\_or\_alias}.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Char} is a not a character
\bi
\item 	{\tt type\_error(character,Char)}
\ei
\ei

\isoitem{put\_char(+Char)}{put\_char/1}
%
Puts a UTF-8 character {\tt Char} to the current output stream.

{\bf Error Cases}
\bi
\item 	{\tt Code} is a not a character.
\bi
\item 	{\tt type\_error(character,Char)}
\ei
\ei

\isoitem{put\_code(+Stream,+Code)}{put\_code/2}
%
Puts the character for the UTF-8 code {\tt Code} to {\tt
  Stream\_or\_alias}.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Code} is a not a character code
\bi
\item 	{\tt type\_error(character\_code,Code)}
\ei
\ei


\isoitem{put\_code(+Code)}{put\_code/1}
%
Puts the character for the UTF-8 code {\tt Code} to the current output
stream~\footnote{The obsolescent predicate {\tt put/1} is defined as
  {\tt put\_code/1}.}.

{\bf Error Cases} \bi
\item 	{\tt Code} is a not a character code.
\bi
\item 	{\tt type\_error(character\_code,Code)}
\ei
\ei

%\standarditem{put(+Code)}{put/1}
%    Puts the ASCII character code {\tt N} to the current output stream.
%
%{\bf Error Cases}
%\bi
%\item 	{\tt Code} is a not a character code.
%\bi
%\item 	{\tt type\_error(character\_code,Code)}
%\ei
%\ei

\isoitem{nl}{nl/0}
A new line character is sent to the current output stream.

\isoitem{nl(+Stream\_or\_alias)}{nl/1}
A new line character is sent to the designated output stream.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\repeatstandarditem{tab(+Stream,+N)}{tab/2}
\standarditem{tab(+N)}{tab/1}
    Puts {\tt N} spaces to the designated output stream / current output stream. 

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt N} is a not a positiveInteger
\bi
\item 	{\tt domain\_error(positiveInteger,N)}
\ei
\ei

%%\isorepeatitem{put\_byte/1}{peek\_byte/1}
%\isorepeatitem{put\_byte/2}{peek\_byte/2}
%\isorepeatitem{put\_byte/1}{put\_byte/1}
%\isoitem{put\_byte/2}{put\_byte/2}
%%
%In XSB, these predicates are simply aliases for the associated {\tt
%  xxx\_code} predicates and behave accordingly.  This is safe to do
%since the reader for \version{} of XSB supports only ASCII character
%codes, which are themselves single bytes.  
%
\end{description}

%---------------------------------------------------------------------------------------------------------
\index{Unicode!UTF-8}
\subsection{Term I/O}
Beginning with \version{}, XSB automatically supports Unicode in the
form of UTF-8 characters for reading and writing.

\begin{description}
\isoitem{read(?Term)}{read/1} 
HiLog term is read from the current or
designated input stream, and unified with {\tt Term} according to the
operator declarations in force.  (See Section~\ref{TermSyntax} for the
definition and syntax of HiLog terms). The term must be delimited by a
full stop (i.e. a ``.'' followed by a carriage-return, space or tab).
Predicate {\tt read/1} does not return until a valid HiLog term is
successfully read; that is, in the presence of syntax errors {\tt
  read/1} does not fail but continues reading terms until a term with
no syntax errors is encountered.  If a call to {\tt read(Term)} causes
the end of the current input stream to be reached, variable {\tt Term}
is unified with the term {\tt end\_of\_file}.  In that case, further
calls to {\tt read/1} for the same input stream will cause an error
failure.

%TLS: This doesn't actually seem to be the behavior.  Exceptions:
% \begin{description} 
% \item[{\tt existence\_error}] {\tt end\_of\_file}
%  is reached before the current term is read.  
%\end{description} 
%
In \version, {\tt read/[1,2]} are non ISO-compliant in how they
handle syntax errors or their behavior when encountering an end of
file indicator.

%--------

\isoitem{read(+Stream\_or\_alias, ?Term)}{read/2}
	{\tt read/2} has the same behavior as {\tt read/1} but the
	input stream is explicitly designated by {\tt
	Stream\_or\_alias}.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

%--------
\index{canonical format}
\standarditem{read\_canonical(-Term)}{read\_canonical/1}
Reads a term that is in canonical format from the current input stream
and returns it in {\tt Term}. On end-of-file, it returns the atom {\tt
end\_of\_file}.  If it encounters an error, it prints an error message
on STDERR and returns the atom {\tt read\_canonical\_error}. This is
significantly faster than {\tt read/1}, but requires the input to be
in canonical form.

%In \version, {\tt read\_canonical/[1,2]} are non ISO-compliant in how they
%handle syntax errors or their behavior when encountering an end of
%file indicator.

\standarditem{read\_canonical(+Stream\_or\_alias),-Term)}{read\_canonical/2}
Behaves as {\tt read\_canonical/1}, but reads from {\tt Stream\_or\_alias}.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

%--------
\isoitem{read\_term(?Term,?OptionsList)}{read\_term/2}
%
A term is read from the current input stream as in {\tt read/1}; but
{\tt OptionsList} is a (possibly empty) list of {\em read options}
that specifies additional behavior.  The read options include
\begin{itemize}
\item {\tt variables(Vars)}: once a term has been read, {\tt Vars} is a
list of the variables in the term, in left-to-right order. 
\item {\tt variable\_names(VN\_List)}: once a term has been read {\tt
VN\_List} is a list of non-anonymous variables in the term.  The
elements of the list have the form {\tt A = V} where {\tt V} is a
non-anonymous variable of the term, and {\tt A} is the string used to
denote the variable in the input stream.
\item {\tt singletons(VS\_List)}: once a term has been read {\tt
VN\_List} is a list of the non-anonymous {\tt singleton} variables in
the term.  The elements of the list have the form {\tt A = V} where
{\tt V} is a non-anonymous variable of the term, and {\tt A} is the
string used to denote the variable in the input stream.
\item {\tt variables\_as\_atoms}: reads variables as atoms, i.e., a
  variable name is returned as an atom.  Of course, this means any
  term read with this option will be a ground term.  So the above
  variable list, if requested, will be empty.
\item {\tt double\_quoted\_as\_atoms}: reads double-quoted strings as
  atoms.
\end{itemize}

{\bf Error Cases}
\bi
\item 	{\tt OptionsList} is a variable, or is a list containing a
	variable element. 
\bi 
\item instantiation\_error
\ei
\item     {\tt OptionsList} contains a non-variable element {\tt O} that is not
	a read option.
\bi
\item 	{\tt domain\_error(read\_option,O)}
\ei
\ei

%--------

\isoitem{read\_term(+Stream\_or\_alias, ?Term,?OptionsList)}{read\_term/3}
%
{\tt read\_term/3} has the same behavior as {\tt read\_term/2} but
the input stream is explicitly designated using the first argument.

{\bf Error Cases} are the same as {\tt read\_term/2}, but with the
additional errors that may arise in stream checking.
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\isoitem{write\_term(?Term,+Options)}{write\_term/2}
%
Outputs {\tt +Term} to the current output stream according to the list
of write options, {\tt Options}.  The current set of write options
which form a superset of the ISO-standard write options, are as
follows:
%
\begin{itemize}
%
\item {\tt quoted(+Bool)}.  If {\tt Bool = true}, then atoms and
  functors that can't be read back by {\tt read/1} are quoted;[ if {\tt
    Bool = false}, each atom and functor is written as its unquoted
  name. Default value is {\tt false}.
%
\item {\tt ignore\_ops(+Bool)}. If {\tt Bool = true} each compound
  term is output in functional notation, regardless of what operators
  have been declared.  For instance, curly braces are written as a
  prefix {\tt \{\}(...)} and list brackets are written using dot
  notation.  If {\tt Bool = false}, output takes account of infix and
  other operators.  Default value is {\tt false}.
%
 \item {\tt numbervars(+Bool)}.  If {\tt Bool = true}, a term of the
   form {\tt '\$VAR'(N)} where {\tt N} is an integer, is output as a
   variable name consisting of a capital letter possibly followed by
   an integer.  A term of the form {\tt '\$VAR'(Atom)} where {\tt
     Atom} is an atom, is output as itself (without quotes).  Finally,
   a term of the form {\tt '\$VAR'(String)} where {\tt String} is a
   character string, is output as that character string.  If {\tt
     bool} is {\tt false} terms of the form {\tt '\$VAR'(N)} are not
   treated in any special way.  Default value is {\tt false}.
%
% TLS: need predicate portray attribute, if we don't have it.
%
\comment{
\item {\tt portrayed(+Bool)}. If {\tt Bool = true}, then a call is made
to the predicate @pred{portray/1}, to
provide the user handlers for pretty printing some terms.  {\tt
portray_attribute/1} is called whenever an attributed variable is to
be printed, {\tt portray/1} is called whenever a non-variable term is
to be printed.  If either call succeeds, then it is assumed that the
term has been output, else it is printed as usual.  If {\tt bool} is
{\tt false}, these predicates are not called. Default value is {\tt
false}.  This option is set by the top-level when writing the final
values of variables, and by the debugging package when writing the
goals in the tracing messages.  Thus you can vary the forms of these
messages if you wish.
}
\item {\tt max\_depth(+Depth)}. {\tt Depth} is a positive integer or
zero. If positive, it denotes the depth limit on printing compound
terms. If {\tt Depth} is zero, there is no limit. Default value is
{\tt 0} (no limit).
%
\item {\tt priority(+Prio)} {\tt Prio} is an integer between 1 and
1200.  If the term to be printed has higher priority than {\tt Prio},
it will be printed parenthesized.  Default value is 1200 (no term
parenthesized).
%
\item {\tt float\_precision(+Prec)}.  {\tt Prec} must be an integer
  between 1 and 17, and this number determines the precision with
  which a floating point number is displayed, (excluding trailing
  zeros).  The default value is 15.
%
\item {\tt float\_width(+Width)}.  {\tt Width} must be an integer
  between 1 and 17, and this number determines the minimum width
  precision with which a floating point number is displayed.  For
  instance, a width of 2 ensures that a floating point number is
  always displayed with a decimal value.  The default value is 2.
%
\item {\tt float\_specifier(+Spec)}.  Floats in XSB are printed using
  underlying C routines.  In C a floating point specifier of {\tt f}
  or {\tt F} means that a floating point number is always printed with
  a certain precision, while a specifier of {\tt g} or {\tt G}
  truncates trailing zeros.  The allowed values are {\tt g},{\tt
    G},{\tt f} and {\tt F}.  The default value if {\tt g}.
%
\item {\tt radix(+Radix)}. Ensures that integers are printed with
  radix {\tt Radix}.  {\tt Radix} can be {\tt decimal}, {\tt hex} or
  {\tt octal}.  The default is {\tt decimal}.
%
\end{itemize}

From the following examples it can be seen that {\tt
write\_term/[2,3]} can duplicate the behavior of a number of other
I/O predicates such as {\tt write/[1,2]}, {\tt writeq/[1,2]}, {\tt
write\_canonical/[1,2]}, etc.
{\small
\begin{verbatim}

| ?- write_term(f(1+2,'A',"string",'$VAR'(3),'$VAR'('Temp'),(multifile foo)),[]).
f(1 + 2,A,"string",$VAR(3),$VAR(Temp),(multifile foo))
yes

| ?- write_term(f(1+2,'A',"string",'$VAR'(3),'$VAR'('Temp'),(multifile foo)),
                [quoted(true)]).
f(1 + 2,'A',"string",'$VAR'(3),'$VAR'('Temp'),(multifile foo))
yes

| ?- write_term(f(1+2,'A',"string",'$VAR'(3),'$VAR'('Temp'),(multifile foo)),
                [quoted(true),ignore_ops(true),numbervars(true)]).
f(+(1,2),'A','.'(115,'.'(116,'.'(114,'.'(105,'.'(110,'.'(103,[])))))),D,Temp,(multifile foo))
yes

| ?- write_term(f(1+2,'A',"string",'$VAR'(3),'$VAR'('Temp'),(multifile foo)),
                [quoted(true),ignore_ops(true),numbervars(true),priority(1000)]).
f(+(1,2),'A','.'(115,'.'(116,'.'(114,'.'(105,'.'(110,'.'(103,[])))))),D,Temp,multifile(foo))
yes

| ?- _X is pi, write_term(_X,[]).
3.141592653589793

yes
| ?- _X is pi, write_term(_X,[float_display_precision(4)]).
3.142

yes
\end{verbatim}
}

{\bf Error Cases} 
\bi
\item 	{\tt Options} is a variable
\bi
\item    {\tt instantiation\_error}
\ei
\item 	{\tt Options} neither a variable nor a list
\bi
\item    {\tt type\_error(list,Options)}
\ei
\item 	{\tt Options} contains a variable element, {\tt O}
\bi
\item    {\tt instantiation\_error}
\ei
\item 	{\tt Options} contains an element {\tt O} that is neither a variable
nor a write option.
\bi
\item    {\tt domain\_error(write\_option,O)}
\ei
\ei

\compatibility In \version{}, {\tt write\_term/[2,3]} do not always
properly handle operators.

\isoitem{write\_term(+Stream\_or\_alias,?Term,+Options)}{write\_term/3}
% 
Behaves as {\tt write\_term/2}, but writes to {\tt Stream\_or\_alias}.

{\bf Error Cases} are the same as {\tt write\_term/2} but with these
additions.
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open output stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\index{attributed variables}
\index{Prolog flags!{\tt write\_attributes}}
\isoitem{write(?Term)}{write/1}
% 
Semantically, {\tt write/1} behaves as if {\tt write\_term/1} were
invoked using {\tt quoted(false)}, {\tt ignore\_ops(false)}, and {\tt
  numbervars(false)}.  Attributed variables are written according to
the value of the Prolog flag {\tt write\_attributes} (cf. {\tt
  current\_prolog\_flag/2}).

The HiLog term {\tt Term} is written to the current output stream,
according to the operator declarations in force.  Any uninstantiated
subterm of term {\tt Term} is written as an anonymous variable (an
underscore followed by a token).  

All {\em proper HiLog terms} (HiLog terms which are not also Prolog
terms) are not written in their internal Prolog representation.  {\tt
  write/1} always succeeds without producing an error.

HiLog (or Prolog) terms that are output by {\tt write/1} cannot in
general be read back using {\tt read/1}.  This happens for two
reasons:
    \begin{itemize}
    \item The atoms appearing in term {\tt Term} are not quoted. In that case 
          the user must use {\tt writeq/1} or 
          {\tt write\_canonical/1} described below, which quote around atoms 
          whenever necessary.
    \item The output of {\tt write/1} is not terminated by a full-stop;
          therefore, if the user wants the term to be accepted as input to
          {\tt read/1}, the terminating full-stop must be explicitly sent 
          to the current output stream. 
    \end{itemize}

{\tt write/1} treats terms of the form \verb|'$VAR'(N)|, which may be
generated by {\tt numbervars/[1,3]} specially: it writes {\tt 'A'} if
{\tt N}=0, {\tt 'B'} if {\tt N}=1, $\ldots$, {\tt 'Z'} if {\tt N}=25,
{\tt 'A1'} if {\tt N}=26, etc.  \verb|'$VAR'(-1)| is written as the
anonymous variable \verb|'_'|.

\isoitem{write(+Stream\_or\_alias, ?Term)}{write/2}
	{\tt write/2} has the same behavior as {\tt write/1} but the
	output stream is explicitly designated using the first argument.

{\bf Error Cases} are the same as {\tt read\_term/2}, but with the
additional errors that may arise in stream checking.
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open output stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\isoitem{writeq(?Term)}{writeq/1}
%
Acts as {\tt write\_term/1} when defined with the options {\tt
  quoted(true)}, {\tt numbervars(true)}, and {\tt ignore\_ops(false)}.
In other words, atoms and functors are quoted whenever necessary to
make the result acceptable as input to {\tt read/1} {\tt writeq/1}
also treats terms of the form \verb|'\VAR'(N)| specially, writing {\tt
  A} if {\tt N}= 0, etc., and output is in accordance with current
operator definitions.  {\tt writeq/1} always succeeds without
producing an error.

\isoitem{writeq(+Stream\_or\_alias, ?Term)}{writeq/2}
%
	{\tt writeq/2} has the same behavior as {\tt writeq/1} but the
	output stream is explicitly designated using the first argument.

{\bf Error Cases} 
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open output stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\index{canonical format}
\isoitem{write\_canonical(?Term)}{write\_canonical/1}
%
This predicate is provided so that the HiLog term {\tt Term}, if
written to a file, can be read back using {\tt read\_canonical/[1,2]}
or {\tt read/[1,2]} regardless of special characters appearing in {\tt
  Term} or prevailing operator declarations. Like {\tt
  write\_prolog/1}, {\tt write\_canonical/1} writes all proper HiLog
terms to the current output stream using the standard Prolog syntax
(see Section~\ref{TermSyntax} on the standard syntax of HiLog
terms). {\tt write\_canonical/1} also quotes atoms and functors as
{\tt writeq/1} does, to make them acceptable as input of {\tt
  read/1}\@.  Except for list-notation ({\tt []}) and infix comma-list
notation, operator declarations are not taken into consideration, so
that apart from these exceptions compound terms are written in the
form:
%
		\[ \langle predicate\ name \rangle
			(\langle arg_1 \rangle, \ldots,
			 \langle arg_n \rangle) \]
%
Unlike {\tt writeq/1}, {\tt write\_canonical/1} does not treat terms
of the form \verb|'$VAR'(N)| specially. It writes square bracket lists  % $
using {\tt '.'/2} and {\tt []} (that is, {\tt [foo, bar]} is written
as \verb|'.'(foo,'.'(bar,[]))|).

Finally, {\tt write canonical/2} writes attributed variables as simple
variables.
\index{attributed variables}

\compatibility
%
In XSB, list notation and infix comma-list notation are considered
canonical both for reading and writing.  We find that this improves
readability, and that these operators are so standard that there is
little likelihood that they will not be in effect by any Prolog
reader.  We therefore deviate from the ISO standard definition of
canonical in these cases.

\isoitem{write\_canonical(+Stream\_or\_alias, ?Term)}{write\_canonical/2}
%
{\tt write\_canonical/2} has the same behavior as {\tt
write\_canonical/1} but the output stream is explicitly designated
using the first argument.

{\bf Error Cases} 
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open output stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\standarditem{writeln(?Term)}{writeln/1}
    {\tt writeln(Term)} can be defined as {\tt write(Term), nl}.

\standarditem{writeln(+Stream,?Term)}{writeln/2}
    {\tt writeln(Term)} can be defined as {\tt write(Stream,Term),
    nl(Stream)}.

\comment{
TLS I don't think we still need this -- console_write seems better for that.
\standarditem{display(?Term)}{display/1}
    The HiLog term {\tt Term} is displayed on the terminal (standard output 
    stream), according to the operator declarations in force. In other words,
    {\tt display/1} is similar to {\tt write/1} but the result is always
    written on {\tt ``userout''}\@.  Like {\tt write/1}, {\tt display/1} 
    always succeeds without producing an error. After returning from a call 
    to this predicate, the current output stream remains unchanged.
}

\ourrepeatstandarditem{write\_prolog(?Term)}{write\_prolog/1}{HiLog}
\ourstandarditem{write\_prolog(+Stream\_or\_alias,?Term)}{write\_prolog/1}{HiLog}
%
   {\tt write\_prolog/1} acts as {\tt write/1} except that any proper
   HiLog term {\tt Term} is written using Prolog syntax -- i.e. as a
   term whose outer functor is apply.  {\tt write\_prolog/1} outputs
   {\tt Term} according to the operator declarations in force.
   Because of this, it differs from {\tt write\_canonical/1} described
   above, despite the fact that both predicates write HiLog terms as
   Prolog terms.

   {\tt write\_prolog/2} has the same behavior as {\tt
     write\_prolog/1} but the output stream is explicitly designated
   using the first argument.  Error Cases for {\tt write\_prolog/2}
   are the same as for {\tt write/2}.

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- write_prolog(X(a,1+2)).
                apply(_h120,a,1 + 2)

                yes
                | ?- write(X(a,1+2)).
                _h120(a,1 + 2)

                yes
                | ?- write_canonical(X(a,1+2)).
                apply(_h120,a,+(1,2))

                yes
     \end{verbatim}}


\ourmoditem{numbervars(+Term, +FirstN,?LastN,+Options)}{numbervars/4}{num\_vars} 
%
This predicate provides a mechanism for grounding a (HiLog) term so
that it may be analyzed.  Each variable in the (HiLog) term {\tt Term}
is instantiated to a term of the form \verb|'$VAR'(N)|, where {\tt N}
is an integer starting from {\tt FirstN}.  {\tt FirstN} is used as the
value of {\tt N} for the first variable in {\tt Term} (starting from
the left). The second distinct variable in {\tt Term} is given a value
of {\tt N} satisfying {\tt "N is FirstN + 1"} and so on.  The last
variable in {\tt Term} has the value {\tt LastN-1}.

\index{attributed variables}
In {\tt numbervars/4}, {\tt Options} can be used to indicate the
action to take upon encountering an attributed variable.  Currently,
{\tt Options} must be either be the empty list, or the list {\tt
  [attvar(Action)]} or the term {\tt attvar(Action)}, where {\tt
  Action} is 
\bi
\item {\tt error} Throw a type error if an attributed variable is
  encountered.
\item {\tt bind} Bind attributed variables by unifying them with terms
  of the form \verb|'$VAR'(N)|.
\item {\tt skip} Skip over attributed variables, performing no action
  on these variables.
\ei
{\bf Error Cases}
\bi
\item 	{\tt Options} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Options} is not an empty list, the list {\tt
  [attvar(Action)]} or the term {\tt attvar(Action)} where {\tt
  Action} is one of {\tt bind}, {\tt error} or {\tt skip}:
 \bi
\item 	{\tt domain\_error}
\ei
\ei

\ourmoditem{numbervars(+Term, +FirstN, ?LastN)}{numbervars/3}{num\_vars}
%
Acts as {\tt numbervars(+Term, +FirstN, ?LastN,attvar(error))}.

\ourmoditem{numbervars(+Term)}{numbervars/1}{num\_vars}
    This predicate is defined as: {\tt numbervars(Term, 0, \_)}.  It
    is included solely for convenience.

\ourmoditem{unnumbervars(+Term, +FirstN, ?Copy)}{unnumbervars/3}{num\_vars}
    This predicate is a partial inverse of predicate {\tt
    numbervars/3}.  It creates a copy of Term in which all subterms of
    the form \verb|'$VAR'(<int>)| where \verb|<int>| is not less than
    {\tt FirstN} are uniformly replaced by variables.  \verb|'$VAR''|
    subterms with the same integer are replaced by the same variable.
    Also a version {\tt unnumbervars/2} is provided which calls {\tt
    unnumbervars/3} with the second parameter set to 0.

\end{description}

\subsubsection{Term Writing to Designated I/O Streams}
%
\index{streams!STDOUT}
While XSB has standard I/O streams for errors, warnings, messages, and
feedback (cf. Section~\ref{sec:IO-streams}), the predicates above
write to {\tt STDOUT} which is the standard output for the process.
Most of the time there is no issue with this as these streams are
aliased to {\tt STDOUT}.  However in a number of circumstances, {\tt
  STDOUT} may be redirected: a user may have invoked {\tt tell/1}, XSB
may be invoked through C or interprolog, etc.  In such cases, it may
be useful to ensure that output goes to one of the other I/O streams.  

\begin{description}

\index{streams!STDERR}
\ourrepeatmoditem{error\_write(?Message)}{error\_write/1}{standard}
\ourmoditem{error\_writeln(?Message)}{error\_writeln/1}{standard}
%
These predicates output {\tt Message} to XSB's {\tt STDERR} stream,
rather than to XSB's {\tt STDOUT} stream, as does {\tt write/1} and
{\tt writeln/1}.  In addition, if {\tt Message} is a list or comma
list, the elements in the comma list are output as if they were
concatenated together.  Each of these predicates must be imported from
the module {\tt standard}.

\index{streams!STDFDBK}
\ourrepeatmoditem{console\_write(?Message)}{console\_write/1}{standard}
\ourmoditem{console\_writeln(?Message)}{console\_writeln/1}{standard}
%
As above, but writes to {\tt STDFDBK}, the console feedback stream.

\index{streams!STDWARN}
\index{Prolog flags!{\tt warning\_action}}
\ourmoditem{warning(?Message)}{warning/1}{standard}
%\ourmoditem{warningln(?Message)}{warningln/1}{standard}
%
By default, this predicate outputs {\tt Message} to XSB's {\tt
  STDWARN} stream, rather than to XSB's {\tt STDOUT} stream, as does
{\tt write/1} and {\tt writeln/1}.  In addition, if {\tt Message} is a
list or comma list, the elements in the comma list are output as if
they were concatenated together.  Each of these predicates must be
imported from the module {\tt standard}.

The default behavior for warnings can be altered by setting the value
of the Prolog flag {\tt warning\_action} to either {\tt silent\_warning}
which performs no action when {\tt warning/1} is called. or {\tt
  error\_warning} which throws a miscellaneous exception when {\tt
  warning/1} is called (WARNING: this includes compiler warnings).
The default behavior can be restored by setting {\tt warning\_action}
to {\tt print\_warning}.

\index{streams!STDMSG}
\ourrepeatmoditem{message(?Message)}{message/1}{standard}
\ourmoditem{messageln(?Message)}{messageln/1}{standard}
%
As above, but writes to {\tt STDMSG} the standard stream for messages.

\end{description}

\subsection{Special I/O}

\begin{description}
\standarditem{fmt\_read(+Fmt,-Term,-Ret)}{fmt\_read/3}
\vspace{-7mm}
\standarditem{fmt\_read(+Stream,+Fmt,-Term,-Ret)}{fmt\_read/4}
%
    These predicates provides a routine for reading data from the
    current input file (which must have been already opened by using
    {\tt see/1}) according to a C format, as used in the C function
    {\tt scanf}. {\tt Fmt} must be a string of characters (enclosed in
    ") representing the format that will be passed to the C call to
    {\tt scanf}.  See the C documentation for {\tt scanf} for the
    meaning of this string.  The usual alphabetical C escape
    characters ({\it e.g.}, $\backslash n$) are recognized, but not
    the octal or the hexadecimal ones.  Another difference with C is
    that, unlike most C compilers, XSB insists that a single {\tt \%}
    in the format string signifies format conversion
    specification. (Some C compilers might output {\tt \%} if it is
    not followed by a valid type conversion spec.) So, to output {\tt
    \%} you must type {\tt \%\%}.  Format can also be an atom enclosed
    in single quotes. However, in that case, escape sequences are not
    recognized and are printed as is.

    {\tt Term} is a term ({\it e.g.}, {\tt args(X,Y,Z)})  whose arguments
    will be unified with the field values read in.  (The functor symbol of {\tt
    Term} is ignored.)  Special syntactic sugar is provided for the case
    when the format string contains only one format specifier: If {\tt
    Term} is a variable, {\tt X}, then the predicate behaves as if {\tt
    Term} were {\tt arg(X)}.

  If the number of arguments exceeds the number of format specifiers, a
  warning is produced and the extra arguments remain uninstantiated.
  If the number of format specifiers exceeds the number of arguments, then
  the remainder of the format string (after the last matching specifier) is
  ignored.
  
  Note that floats do not unify with anything.  {\tt Ret} must be a
  variable and it will be assigned a return value by the predicate: a
  negative integer if end-of-file is encountered; otherwise the number of
  fields read (as returned by {\tt scanf}.)
  
  {\tt fmt\_read} cannot read strings (that correspond to the {\tt \%s}
  format specifier) that are longer than 16K. Attempting to read longer
  strings will cause buffer overflow. It is therefore recommended that one
  should use size modifiers in format strings ({\it e.g.}, {\tt \%2000s}),
  if such long strings might occur in the input.

% Maybe some other error cases, who knows?
{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open output stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

If the number of arguments in {\tt Term} is greater than the number of
conversion specifiers in {\tt Fmt} no error is thrown, but a warning
is issued.

\standarditem{fmt\_write(+Fmt,+Term)}{fmt\_write/2}
\vspace{-7mm}
\standarditem{fmt\_write(+Stream\_or\_alias,+Fmt,+Term)}{fmt\_write/3} 
%
These predicates provide routines for writing formatted data to a
given output stream ({\tt fmt\_write/3}) or the current output stream
({\tt fmt\_write/2}).

{\tt Fmt} should be a Prolog character list (string) or atom.  A
Prolog character list is preferred, as space can be more easily
reclaimed for character lists than for atoms.  {\tt Term} is a Prolog
term ({\it e.g.}, {\tt args(X,Y,Z)}) whose arguments will be
output. The number of arguments in {\tt Term} should equal the number
of conversion specifiers in {\tt Fmt}.  The functor symbol of {\tt
  Term} is ignored~\footnote{In the case where {\tt Fmt} contains only
  a single conversion specifier, {\tt Term} may be a string, integer
  or a float, and is considered to be equivalent to specifying {\tt
    arg(Term)}.}.
    
Allowable syntaxes for {\tt Fmt} reflect the syntax of the C function
{\tt printf()} on a given platform, with the following exceptions
%
\bi
\item The usual alphabetical C escape characters ({\it e.g.},
  $\backslash n$) are recognized, but not the octal or the hexadecimal
  ones.
\item {\tt \%S} is supported, in addition to the usual C conversion
  specifiers.  The corresponding argument can be any Prolog term. This
  provides an easy way to print the values of Prolog variables, etc.
\item {\tt \%!} is supported and indicates that the corresponding
  argument is to be ignored and will generate nothing in the output.
\item A single {\tt \%} in the format string must be followed by a
  conversion operator (e.g. {\tt d}, {\tt s}, etc.). (Some C compilers
  output {\tt \%} if the percentage character is not followed by a
  valid type conversion spec.)  However, to output {\tt \%}, {\tt
    fmt\_write} must contain {\tt \%\%}.
\ei    
%
{\bf Example}
{\small
\begin{verbatim}
| ?- fmt_write("%d %f %s %S \n",args(1,3.14159,ready,hello(world))).
1 3.141590 ready hello(world)

yes
\end{verbatim}
}
%
XSB also offers an alternate version of formatted output in the {\tt
  format} library described in volume 2.  While not as efficient as
{\tt fmt\_write/[2,3]}, the {\tt format} library is more compatible
with the formatted output found in other Prologs.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open output stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item {\tt Fmt} is uninstantiated or not a character string or atom
\bi
\item   {\tt type\_error('character string or atom',Fmt)}
\ei
\item A format specifier in {\tt Fmt} and its corresponding argument
  in {\tt Term} are of incompatible types.
\bi
\item   {\tt misc\_error}
\ei
\item {\tt Term} contains fewer arguments than {\tt Fmt} has format
  specifiers or {\tt Term} is uninstantiated
\bi
\item   {\tt misc\_error}
\ei
\ei

If the number of arguments in {\tt Term} is greater than the number of
conversion specifiers in {\tt Fmt} no error is thrown, but a warning
is issued.

{\bf Caution for 64-bit Platforms}
%
As discussed, {\tt fmt\_write/[2,3]} calls {\tt printf()} and inherits
the flexibility of that function, but also its ``features''.  One of
these features is that in most 64-bit platforms, large integers that
behave perfectly well otherwise are not printed out properly by {\tt
  printf()} with the {\tt \%d} format -- rather another format string
needs to be used (such as {\tt \%ld} on Linux).  {\tt
  fmt\_write/[1,2]} recognizes the {\tt \%ld} option and passes it
onto {\tt fprintf()}, but the proper format string for 64-bit integers
may be different on other platforms.

\standarditem{fmt\_write\_string(-String,+Fmt,+Term)}{fmt\_write\_string/3}
    This predicate works like the C function {\tt sprintf}. It takes the
    format string and substitutes the values from the arguments of {\tt
      Term} ({\it e.g.}, {\tt args(X,Y,Z)}) for the formatting instructions
    \%s, \%d, etc. Additional syntactic sugar, as in \verb|fmt_write|, is
    recognized. The result is available in {\tt String}. {\tt Fmt} is a
    string or an atom that represents the format, as in
    {\tt fmt\_write}.
    
    If the number of format specifiers is greater than the number of
    arguments to be printed, an error is issued. If the number of arguments
    is greater, then a warning is issued.

    {\tt fmt\_write\_string} requires that the printed size of each
    argument ({\it e.g.}, X,Y,and Z above) must be less than 16K. Longer
    arguments are cut to that size, so some loss of information is possible.
    However, there is no limit on the total size of the output (apart from
    the maximum atom size imposed by XSB).

\standarditem{file\_read\_line\_list(-String)}{file\_read\_line\_list/1}
A line read from the current input stream is converted into a list of
character codes.  This predicate 
%is \emph{much} more efficient than
%{{\tt fget\_line/3}} (see below), and 
avoids interning an atom as does {\tt file\_read\_line\_atom/3}, and so is
recommended when speed is important.  This predicate fails on reaching
the end of file.

\standarditem{file\_read\_line\_list(Stream\_or\_alias,-CharList)}{file\_read\_line\_list/2}
Acts as does {\tt file\_read\_line\_list}, but uses {\tt Stream\_or\_atom}.

{\bf Error Cases} 
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\standarditem{file\_read\_line\_atom(-Atom)}{file\_read\_line\_atom/1}
%
Reads a line from the current (textual) input stream, returning it as
{\tt Atom}.  This predicate fails on reaching the end of file.

\standarditem{file\_read\_line\_atom(+Stream\_or\_alias,-Atom)}{file\_read\_line\_atom/2}
Like {\tt file\_read\_line\_atom/1} but reads from {\tt Stream\_or\_alias}.
%
{\bf Error Cases} 
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\ourrepeatmoditem{file\_write\_line(+String, +Offset)}{file\_write\_line/2}{file\_io}
\ourmoditem{file\_write\_line(+Stream\_or\_alias, +String, +Offset)}{file\_write\_line/3}{file\_io}
%
These predicates write {\tt String} beginning with character {\tt
  Offset} to the current output stream. {\tt String} can be an atom or
a list of UTF-8 character codes. This does \emph{not} put the newline
character at the end of the string (unless {\tt String} already had
this character). Note that escape sequences, like \verb|\n|, are
recognized if {\tt String} is a character list, but are output as is
if {\tt String} is an atom.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item {\tt String} is neither a Prolog character list not an atom
\bi
\item {\tt misc\_error}
\ei
\ei

%----------------------------------------------------------------------------------------------

\ourmoditem{file\_getbuf\_list(+Stream\_or\_alias, +BytesRequested, -CharList, -BytesRead)}{file\_getbuf\_list/4}{file\_io} 
Read {\tt BytesRequested} bytes from file represented by {\tt
Stream\_or\_alias} (which must already be open for reading) into
variable {\tt String} as a list of character codes. This is analogous
to {\tt fread} in C.  This predicate always succeeds. It does not
distinguish between a file error and end of file.  You can determine
if either of these conditions has happened by verifying that $\tt
BytesRead < BytesRequested$.

\ourmoditem{file\_getbuf\_list(+BytesRequested, -String, -BytesRead)}{file\_getbuf\_list/3}{file\_io}
%
Like \verb|file_getbuf_list/3|, but reads from the currently open input stream
({\it i.e.}, with {\tt see/1}).


\ourmoditem{file\_getbuf\_atom(+Stream\_or\_alias, +BytesRequested, -String, -BytesRead)}{file\_file\_getbuf\_atom/4}{file\_io}

Read {\tt BytesRequested} bytes from file represented by {\tt
Stream\_or\_alias} (which must already be open for reading) into
variable {\tt String}. This is analogous to {\tt fread} in C.  This
predicate always succeeds. It does not distinguish between a file
error and end of file.  You can determine if either of these
conditions has happened by verifying that $\tt BytesRead <
BytesRequested$.

Note: although XSB has an atom table garbage collector, this predicate
is inefficient to read large files.  It is usually best to use {\tt
  read\_getbuf\_list} or another predicate in such a case.

{\bf Error Cases} 
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\ourmoditem{file\_getbuf\_atom(+BytesRequested, -String, -BytesRead)}{file\_getbuf\_atom/3}{file\_io}
%
Like \verb|file_getbuf_atom/4|, but reads from the currently open input stream.

\ourmoditem{file\_putbuf(+Stream\_or\_alias, +BytesRequested, +String, +Offset, -BytesWritten)}{file\_putbuf/5}{file\_io}

Write {\tt BytesRequested} bytes into file represented by I/O port
{\tt Stream\_or\_alias} (which must already be open for writing) from
variable {\tt String} at position {\tt Offset}. This is analogous to C
{\tt fwrite}.  The value of {\tt String} can be an atom or a list of
UTF-8 characters.

{\bf Error Cases} 
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\ourmoditem{file\_putbuf(+BytesRequested, +String, +Offset, -BytesWritten)}{file\_putbuf/4}{file\_io}
%
Like \verb|file_putbuf/3|, but output goes to the currently open output stream.


\end{description}

%-------------------------------------------------------------------
\comment{
\standarditem{fmt\_read(+Format, types(+T1,+T2,...), args(-A1,-A2,...), -RetCode)}\index{\texttt{fmt\_read/4}} 
 This predicate implements C-style formatted input. It reads the current
 input according to the {\tt Format} string.  {\tt Format} has the
 same syntax as the input format in C. The term {\tt types(...)} lists the
 types of the arguments; they must match the types specified in {\tt
 Format}. Here, 1 means string, 2 means integer, and 3 means float.
 The term {\tt args()} specifies the variables for the input. {\tt RetCode}
 specifies the return code: 0 -- ok; -1 -- end of file.

\standarditem{read\_line(-Line, -Status)}\index{\texttt{read\_line/2}} 
 Reads the next line from the current input and puts it in {\tt Line}.
 If the line is larger than the available buffer, then {\tt Status} is 0.
 If the line was read in full, up to and including the newline character,
 then {\tt Status} is 1. 

\standarditem{fmt\_write(+Format, args(-A1,-A2,...))}\index{\texttt{fmt\_write/2}} 
 Similar to formatted write in C. The semantics of the arguments is the
 same as for {\tt fmt\_read/4}.

\standarditem{fmt\_write\_string(-String, +Format, args(-A1,-A2,...))}\index{\texttt{fmt\_write/2}} 
 Like {\tt fmt\_write/2}, but the output string is placed in {\tt String}.
}

%--------------------------------------------------------------------------------------------------

\section{Interactions with the Operating System}

XSB provides a number of facilities for interacting with the UNIX and
Windows operating systems.  This section describes basic facilities
for invoking shell commands and file manipulation.  Chapter 1 of
Volume 2 discusses more advanced commands for process spawning and
control, along with interprocess communication.

\begin{description}

\standarditem{shell(+SystemCall)}{shell/1} 
%
Calls the operating system with the atom {\tt SystemCall} as argument,
using the {\tt libc} function {\tt system()}.  The predicate succeeds
if {\tt SystemCall} is executed successfully; otherwise it fails.  As
a convenience, the user can also supply {\tt SystemCall} either as an
atom or as a list of atoms.  If a list of atoms is used, elements of
the list will be concatenated together to form the system call.

    For example, the call:

    \demo{{\tt $|$ ?- shell('echo \$HOME').}}

    \noindent
    will output in the current output stream of XSB the name of the
    user's home directory; while the call:

    \demo{{\tt $|$ ?- File = 'test.c', shell(['cc -c ', File]).}}

    \noindent
    will call the C compiler to compile the file {\tt test.c}.

    Note that in UNIX systems, since {\tt system()} (and {\tt
      shell/1}) executes by forking off a shell process.  Thus it
    cannot be used, for example, to change the working directory of
    the program.  For that reason the standard predicate {\tt cd/1}
    described below should be used.

{\bf Error Cases}
\bi
\item  {\tt SystemCall} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt SystemCall} is neither an atom nor a list
\bi
\item {\tt type\_error(atom\_or\_list,SystemCall)}
\ei
\item {\tt SystemCall} is longer than the maximum command length
  allowed by {\tt shell/1}
\bi
\item {\tt resource\_error(memory)}
\ei
\ei

\standarditem{shell(+SystemCall, -Result)}{shell/2}
%
As with {\tt shell/1}, this predicate calls the operating system with
the atom {\tt SystemCall} as argument, using the {\tt libc} function
{\tt system()} using the same forms of input.  {\tt shell/2} always
succeeds instantiating {\tt Result} to the exit code of {\tt
  system()}.  Thus {\tt Result} will be 0 if {\t SystemCall} executed
properly, and non-0 otherwise: the specific return values of {\tt
  system()} may be platform-dependent.

{\bf Error Cases}
\bi
\item  {\tt SystemCall} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt SystemCall} is neither an atom nor a list
\bi
\item {\tt type\_error(atom\_or\_list,SystemCall)}
\ei
\item {\tt Result} is not a variable
\bi
\item {\tt type\_error(variable,Result)}
\ei
\item {\tt SystemCall} is longer than the maximum command length
  allowed by {\tt shell/2}
\bi
\item {\tt resource\_error(memory)}
\ei
\ei


\repeatstandarditem{shell\_to\_list(+SystemCall,-StdOut,-ErrOut,-Result)}{shell\_to\_list/4}
\standarditem{shell\_to\_list(+SystemCall,-StdOut,-Result)}{shell\_to\_list/3}
%
Behaves as {\tt shell/2} in its 1st and 4th arguments, and like {\tt
  shell/2} always succeeds.  Both {\tt StdOut} and {\tt ErrOut} are
lists of lists: each element of the outer list corresponds to a line
of output from {\tt SystemCall}, while each element of an inner list
corresponds to a token in that line.  {\tt shell\_to\_list/3} is thus
a sort of Prolog analog of the shell command designated by \verb|SystemCall|.

Examples (from OSx):
\begin{verbatim}
  ?- shell_to_list(sw_vers,Stdout,Ret).

  Stdout = [[ProductName:,Mac,OS,X],[ProductVersion:,10.4.9],[BuildVersion:,8P2137]]
  Ret = 0

  ?- shell_to_lists('gcc -c nofile.c',StdOut,StdErr,Ret).

  Stdout = []
  StdErr = [[i686-apple-darwin8-gcc-4.0.1:,nofile.c:,No,such,file,or,directory]]
  Ret = 256
\end{verbatim}

Error cases are as with {\tt shell/2}

\ourmoditem{datime(?Date)}{datime/1}{standard}
%
Unifies {\tt Date} to the current UTC date, returned as a Prolog term,
suitable for term comparison.  Note that {\tt datime/1} must be
explicitly imported from the module {\tt standard}.

Example:
{\footnotesize
\begin{verbatim}
                > date
                Mon Aug  9 16:19:44 EDT 2004
                > xsb
                XSB Version 2.6 (Duff) of June 24, 2003
                [i686-pc-cygwin; mode: optimal; engine: slg-wam; gc: indirection; scheduling: local]

                | ?- import datime/1 from standard

                yes
                | ?- datime(F).
                F = datime(2004,8,9,20,20,23)

               yes
\end{verbatim}}

\ourmoditem{local\_datime(?Date)}{local\_datime/1}{standard}
%
Acts as {\tt datime/1}, but returns the local, rather than the UTC date.

\ourrepeatmoditem{epoch\_seconds(-Seconds)}{epoch\_seconds/1}{machine} 
\ourmoditem{epoch\_milliseconds(-Seconds,-Milliseconds)}{epoch\_milliseconds/2}{machine} 
%
Returns the number of seconds since the beginning of the POSIX/UNIX
epoch (January 1, 1970)~\footnote{Uses the Posix call {\tt time(0)},
  so the number of seconds will be returned on non-Unix platforms,
  such as Microsoft.}.  May cause overflow on 32-bit platforms.
\texttt{epoch\_milliseconds/2} returns both the number of seconds and
the number of additional milliseconds since the last whole second.

\ourmoditem{sleep(+Seconds)}{sleep/1}{shell}
\noindent
Put XSB to sleep for a given number of seconds.  

{\bf Error Cases}
\bi
\item 	{\tt Seconds} is a variable
\bi
\item 	{\tt instantiation\_error}.
\ei
\item 	{\tt Seconds} is not an integer
\bi
\item 	{\tt type\_error(integer, Seconds)}.
\ei
\ei

\standarditem{cd(+Dir)}{cd/1}
    Under UNIX and Windows, this predicate changes the interpreter's
    working directory to {\tt Dir}.  If the directory specified does
    not exist or is not a directory, or the user does not have execute
    permission for that directory, predicate {\tt cd/1} simply fails
    raising a permission error.

{\bf Error Cases}
    \begin{description}
    \item[{\tt instantiation\_error}]
        {\tt Dir} is not instantiated at the time of call.
    \item[{\tt type\_error}]
        {\tt Dir} is not an atom.
    \end{description}

\ourmoditem{getenv(+VarName,-VarVal)}{getenv/2}{machine} 
\noindent
Unifies {\tt VarVal} with the value of {\tt VarName} in the current
shell.  If {\tt VarName} is not an environment variable, the predicate
fails.

{\em Example:}
\begin{verbatim}
:- import getenv/2 from machine.

yes
| ?- getenv('HOSTTYPE',F).

F = intel-pc
\end{verbatim}

\ourmoditem{putenv(+String)}{putenv/2}{machine} 
\noindent
If {\tt String} is of the form {\tt VarName=Value}, inserts or resets
the environment variable {\tt VarName}.  If {\tt VarName} does not
exist, it is inserted with {\tt VarVal}.  If the {\tt VarName} does
exist, it is reset to {\tt VarVal}.  {\tt putenv/2} always succeeds.

Exceptions:
    \begin{description}
    \item[{\tt instantiation\_error}] {\tt String} is
      not instantiated at the time of call.
    \item[{\tt type\_error}]
        {\tt VarName} or {\tt VarVal} is not an atom or a list of atoms.
    \end{description}

\end{description}

\subsection{The {\tt path\_sysop/2} interface}
%
In addition, XSB provides the following unified interface to the
operations on files. All these calls succeed iff the corresponding
system call succeeds.  These calls work on both Windows and Unixes
unless otherwise noted.
%%
\begin{description}
  \standarditem{path\_sysop(isplain, +Path)}{path\_sysop/2}
  Succeeds, if {\tt Path} is a plain file.
  \standarditem{path\_sysop(isdir, +Path)}{path\_sysop/2}
  Succeeds, if {\tt Path} is a directory.
  \standarditem{path\_sysop(rename, +OldPath, +NewPath)}{path\_sysop/3}
  Renames {\tt OldPath} into {\tt NewPath}.
  \standarditem{path\_sysop(copy, +FromPath, +ToPath)}{path\_sysop/3}
  Copies {\tt FromPath} into {\tt ToPath}.
  \standarditem{path\_sysop(rm, +Path)}{path\_sysop/2}  Removes the plain file {\tt Path}.
  \standarditem{path\_sysop(rmdir, +Path)}{path\_sysop/2}  Deletes the directory {\tt Path}, succeeding only if the directory is empty.
  \standarditem{path\_sysop(rmdir\_rec, +Path)}{path\_sysop/3}
  Deletes the directory {\tt Path} along with any of its contents.
%  \standarditem{path\_sysop(unlink, +Path)}
%  Same as {\tt rm}.
  \standarditem{path\_sysop(link, +SrsPath, +DestPath)}{path\_sysop/3}
  Creates a hard link from {\tt SrsPath} to {\tt DestPath}. UNIX only.
  \standarditem{path\_sysop(cwd, -Path)}{path\_sysop/2}
  Binds {\tt Path} to the current working directory.
  \standarditem{path\_sysop(chdir, +Path)}{path\_sysop/2}
  Changes the current working directory to {\tt Path}.
  \standarditem{path\_sysop(mkdir, +Path)}{path\_sysop/2}
  Creates a new directory, {\tt Path}.
  \standarditem{path\_sysop(exists, +Path)}{path\_sysop/2}
  Succeeds if the file {\tt Path} exists.
  \standarditem{path\_sysop(readable, +Path)}{path\_sysop/2}
  Succeeds if {\tt Path} is a readable file.
  \standarditem{path\_sysop(writable, +Path)}{path\_sysop/2}
  Succeeds if {\tt Path} is a writable file.
  \standarditem{path\_sysop(executable, +Path)}{path\_sysop/2}
  Succeeds if {\tt Path} is an executable file.
  \standarditem{path\_sysop(modtime, +Path, -Time)}{path\_sysop/3}
  Returns a list that represents the last modification time of the file.
  Succeeds if file exists. In this case, {\tt Time} is bound to a list
  {\tt [high,low]} where {\tt low} is the least significant 24 bits of the
  modification time and {\tt high} is the most significant bits (25th) and up.
  {\tt Time} represents the last modification time of the file.
  The actual value is thus $\tt high*2^{24} + low$, which represents the
  number of seconds elapsed since 00:00:00 on
       January 1, 1970, Coordinated Universal Time (UTC).
  \standarditem{path\_sysop(newerthan, +Path1, +Path2)}{path\_sysop/3}
  Succeeds is the last modification time of {\tt Path1} is higher than that
  of {\tt Path2}. Also succeeds if {\tt Path1} exists but {\tt Path2} does
  not.
  \standarditem{path\_sysop(size, +Path, -Size)}{path\_sysop/3}
  Returns the byte size of {\tt Path}.
  Succeeds if the file exists.
  \standarditem{path\_sysop(tmpfilename, -Name)}{path\_sysop/2}
  Returns the name of a new temporary file. This is useful when the
  application needs to open a completely new temporary file.
  \standarditem{path\_sysop(extension, +Name, -Ext)}{path\_sysop/3}
  Returns file name extension.
  \standarditem{path\_sysop(basename, +Name, -Base)}{path\_sysop/3}
  Returns the base name of the file name ({\it i.e.}, the name sans the
  directory and the extension).
  \standarditem{path\_sysop(dirname, +Name, -Dir)}{path\_sysop/3}
  Returns the directory portion of the filename. The directory is slash or
  backslash terminated.
  \standarditem{path\_sysop(isabsolute, +Name)}{path\_sysop/2}
  Succeeds if {\tt Name} is an absolute path name. File does not need to exist.
  \standarditem{path\_sysop(expand, +Name, -ExpandedName)}{path\_sysop/3}
  Binds {\tt ExpandedName} to the expanded absolute path name of {\tt Name}.
  The file does not need to exist. Duplicate slashes, references to the
  current and parent directories are factored out.
\end{description}
%%

%-----------------------------------------------------------------
\section{Evaluating Arithmetic Expressions through {\tt is/2}}
\label{Arithmetic} 

\comment{
As do most Prologs, XSB supports evaluation of arithmetic expressions
in two ways.  First, ground arithmetic expressions can be evaluated
through the {\tt is/2} operator.  Solving non-ground arithmetic
expressions is provided through XSB's port of the CLPQR constraint
handling interface.  In this section we describe how arithmetic
expressions can be evaluated through {\tt is/2}, while the CLPQR
interface is described in Volume 2 of this manual.
}

Before describing {\tt is/2} and the expressions that it can evaluate,
we note that in \version{} of XSB, integers in XSB are represented
using a single word of 32 or 64 bits, depending on the machine
architecture. Floating point values are, by default, stored as
word-sized references to double precision values, regardless of the
target machine. Direct (non-referenced, tagged) single precision
floats can be activated for speed purposes by passing the option
--enable-fast-floats to the configure script at configuration time.
This option is not recommended when any sort of precision is desired,
as there may be as little as 28 bits available to represent a given
number value under a tagged architecture.  

All of the evaluable functors described below throw an instantiation
error if one of their evaluated inputs is a variable, and an {\tt
  evaluation(undefined)} error if one of their evaluated inputs is
instantiated but non-numeric.  With this in mind, we describe below
only their behavior on correctly typed input.

\compatibility
In addition, evaluation of arithmetic expressions through {\tt is/2}
does not check for overflow or underflow.  As a result, XSB's floating
point operations do not conform to IEEE floating point standards, and
deviates in this regard from the ISO Prolog standard (see
\cite{ISO-Prolog} Section 9)~ We hope to fix these problems in a
future release \footnote{We also note that the ISO Prolog evaluable
  functors{\tt float\_integer\_part/1} (which can be obtained via {\tt
    truncate/1}), {\tt float\_fractional\_part/1} (which can be
  obtained via {\tt X - truncate(X)}), and bitwise complement (which
  is implementation dependent in the ISO standard) are not implemented
  in \version .}.

\begin{description}
\index{Prolog flags!{\tt exception\_action}}
\isoitem{is(?Result,+Expression)}{is/2}
{\tt is(Result,Expression)} is true iff the result of evaluating {\tt
Expression} as a sequence of evaluable functors unifies with {\tt
Result}.  As mentioned in Section~\ref{inline_predicates}, {\tt is/2}
is an inline predicate, so calls to {\tt is/2} within compiled code
will not be visible during a trace of program execution.

{\bf Error Cases}
    \begin{description}
    \item[{\tt instantiation\_error}]
	{\tt Expression} contains an uninstantiated value
    \item[{\tt domain\_error($<function>,<value>$}] {\tt Expression}
      contains a $function$ applied to $value$, but $value$ is not
      part of the domain of $function$.
    \end{description}

For {\tt is/2} the action for the above error cases can be altered so
that the {\tt is/2} literal is treated as having a truth value of {\em
  undefined} in the well-founded semantics.  This is done via the
Prolog flag {\tt exception\_action}.

\end{description}

\subsection{Evaluable Functors for Arithmetic Expressions} \label{sec:arith-eval}

\begin{description}
\ourstandarditem{+(+Expr1,+Expr2)}{+/2}{Evaluable Functor (ISO)}
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2} evaluates
to {\tt Number2}, returns {\tt Number1 + Number2}, performing any
necessary type conversions.

\ourstandarditem{-(+Expr1,+Expr2)}{-/2}{Evaluable Functor (ISO)}
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2} evaluates
to {\tt Number2}, returns {\tt Number1 - Number2}, performing any
necessary type conversions.

\ourstandarditem{*(+Expr1,+Expr2)}{*/2}{Evaluable Functor (ISO)}
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2} evaluates
to {\tt Number2}, returns {\tt Number1 * Number2} (i.e. multiplies
them), performing any necessary type conversions.

\ourstandarditem{/(+Expr1,Expr2)}{'/'/2}{Evaluable Functor (ISO)}
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2} evaluates
to {\tt Number2}, returns {\tt Number1 / Number2} (i.e. divides
them), performing any necessary type conversions.

\isorepeatitem{div(+Expr1,Expr2)}{div/2}
\ourstandarditem{//(+Expr1,Expr2)}{'//'/2}{Evaluable Functor}
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2} evaluates
to {\tt Number2}, returns {\tt Number1 // Number2} (i.e. integer
division), performing any necessary type conversions, and rounding to
0 if necessary.  

    Example:
    {\footnotesize
     \begin{verbatim}
                | ?- X is 3/2.

                X = 1.5000

                yes
                | ?- X is 3 // 2.

                X = 1

                yes
                | ?- X is -3 // 2.

                X = -1

                yes
  \end{verbatim}}

\ourstandarditem{-(+Expr1)}{-/1}{Evaluable Functor (ISO)}
%
 If {\tt +Expr} evaluates to {\tt Number}, returns {\tt -Number1},
 performing any necessary type conversions.

\ourstandarditem{'$\wedge$'(+Expr1,+Expr2)}{'$\wedge$'/2}{Evaluable Functor (ISO)}
%
 If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2}
evaluates to {\tt Number2}, returns the bitwise conjunction of {\tt
Number1} and {\tt Number2}.

\ourstandarditem{'$\vee$'(+Expr1,+Expr2)}{'$\vee$'/2}{Evaluable Functor (ISO)}

%
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2} evaluates
to {\tt Number2}, returns the bitwise disjunction {\tt Number1} and
{\tt Number2}.

\ourstandarditem{'>>'(+Expr1,+Expr2)}{'>>'/2}{Evaluable Functor (ISO)}
%
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2} evaluates
to {\tt Number2}, returns the logical shift right of {\tt Number1},
{\tt Number2} places.

\ourstandarditem{'<<'(+Expr1,+Expr2)}{'<<'/2}{Evaluable Functor (ISO)}
%
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2}
evaluates to {\tt Number2}, returns the logical shift left of 
{\tt Number1}, {\tt Number2} places.

\isorepeatitem{xor(+Expr1,+Expr2)}{xor/2}
\ourstandarditem{'><'(+Expr1,+Expr2)}{'><'/2}{Evaluable Functor}
%
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2}
evaluates to {\tt Number2}, returns the bitwise exclusive or of 
{\tt Number1} and {\tt Number2}.

\ourstandarditem{min(+Expr1,+Expr2)}{min/2}{Evaluable Functor (ISO)}
%
If {\tt +Expr1} evaluates to {\tt Number1}, and
{\tt Expr2} evaluates to {\tt Number2}, returns the minimum of the
two.

\ourstandarditem{max(+Expr1,+Expr2)}{max/2}{Evaluable Functor (ISO)}
%
If {\tt +Expr1} evaluates to {\tt Number1}, and
{\tt Expr2} evaluates to {\tt Number2}, returns the maximum of the
two.

\ourstandarditem{ceiling(+Expr)}{ceiling/1}{Evaluable Functor (ISO)}
%
If {\tt +Expr} evaluates to {\tt Number}, {\tt ceiling(Number)}
returns the integer ceiling of {\tt Number} if {\tt Number} is a
float, and {\tt Number} itself if {\tt Number} is an integer.

\ourstandarditem{float(+Expr)}{float/1}{Evaluable Functor (ISO)}
%
If {\tt +Expr} evaluates to {\tt Number}, {\tt float(Number)} converts
{\tt Number} to a float if {\tt Number} is an integer, and returns
{\tt Number} itself if {\tt Number} is a float.

\ourstandarditem{floor(+Expr)}{floor/1}{Evaluable Functor (ISO)}
%
If {\tt +Expr} evaluates to {\tt Number}, {\tt floor(Number)} returns
the integer floor of {\tt Number} if {\tt Number} is a float, and {\tt
  Number} itself if {\tt Number} is an integer.

\ourstandarditem{mod(+Expr1,+Expr2)}{mod/2}{Evaluable Functor (ISO)}
%
If {\tt +Expr1} evaluates to {\tt Number1} and {\tt Expr2} evaluates
to {\tt Number2} where {\tt Number2} is not 0, {\tt
mod(Number1,Number2)} returns
\[
	Number1 - (\lfloor (Number1 / Number2) \rfloor) \times Number2)
\]

\ourstandarditem{rem(+Expr1,+Expr2)}{rem/2}{Evaluable Functor (ISO)}
%
If {\tt +Expr1} evaluates to {\tt Number1} and {\tt Expr2} evaluates
to {\tt Number2} where {\tt Number2} is not 0, {\tt
rem(Number1,Number2)} returns
\[
	Number1 - ({Number1} // {Number2}) \times Number2)
\]

    Example:
    {\footnotesize
     \begin{verbatim}
                | ?- X is 5 mod 2.

                X = 1

                yes
                | ?- X is 5 rem 2.

                X = 1

                yes
                | ?- X is 5 mod -2.

                X = -1

                yes
                | ?- X is 5 rem -2.

                X = 1

                yes
  \end{verbatim}}

\ourstandarditem{round(+Expr)}{round/1}{Evaluable Functor (ISO)}
%
If {\tt +Expr} evaluates to {\tt Number}, {\tt round(Number)} returns
the nearest integer to {\tt Number} if {\tt Number} is a float, and
{\tt Number} itself if {\tt Number} is an integer.

%\newcommand{\ourstandarditem}[3]{\item[{\mbox{\tt #1}}  ] \index[pred]{\texttt{#2}} \index{\texttt{#2}} \hspace*{\fill}{\mbox{\sf #3}}\ \\}
%\ourstandarditem{\mbox{ \verb|^| }(+Expr1,+Expr2)}{\verb|^|/2}{Evaluable Functor (ISO)}

\item \verb|^/2| \index[pred]{\^\ /2} \index{\^\ /2} \hspace*{\fill}{\mbox{\sf Evaluable Functor (ISO)}} \\
%
If {\tt Expr1} and {\tt Expr2} both evaluate to numbers, the infix
function \verb|^/2| raises {\tt Expr1} to the {\tt Expr2} power.  If
{\tt Expr1} and {\tt Expr2} both evaluate to integers, an integer is
returned; otherwise a float is returned.

\ourstandarditem{'**'(+Expr1,+Expr2)}{**/2}{Evaluable Functor (ISO)}
%
If {\tt Expr1} and {\tt Expr2} both evaluate to numbers, the infix
function {\tt **/2} raises {\tt Expr1} to the {\tt Expr2} power.  A
floating-point number is always returned.

\ourstandarditem{sqrt(+Expr)}{sqrt/1}{Evaluable Functor (ISO)}
%
If {\tt +Expr} evaluates to {\tt Number}, {\tt sqrt(Number)}
returns the square root of {\tt Number}.

\ourstandarditem{truncate(+Expr)}{truncate/1}{Evaluable Functor (ISO)}
%
If {\tt +Expr} evaluates to {\tt Number}, {\tt truncate(Number)}
truncates {\tt Number} if {\tt Number} is a float, and returns {\tt
  Number} itself if {\tt Number} is an integer.

\ourstandarditem{sign(+Expr)}{sign/1}{Evaluable Functor (ISO)}
%
If {\tt +Expr} evaluates to {\tt Number}, {\tt sign(Number)} returns
{\tt 1} if {\tt Number} is greater than 0, {\tt 0} if {\tt Number} is
equal to 0, and {\tt -1} if {\tt Number} is less than 0.

\ourstandarditem{pi}{pi/0}{Evaluable Functor (ISO)}
% 
Evaluates to $\pi$ within an arithmetic expression.

\ourstandarditem{e}{e/0}{Evaluable Functor}
% 
Evaluates to $e$, the base of the natural logarithm, within an
arithmetic expression.  (Use exp(1) for ISO compatibility.)

\ourstandarditem{epsilon}{epsilon/0}{Evaluable Functor}
% 
Evaluates to $epsilon$, the difference between the float 1.0 and 
the first larger floating point number.

\end{description}

\subsubsection{Mathematical Functions from {\tt math.h}}
\stdrefindex{cos/1} \stdrefindex{sin/1} \stdrefindex{tan/1}
\stdrefindex{acos/1} \stdrefindex{asin/1} \stdrefindex{atan/1}
\stdrefindex{log/1} \stdrefindex{log10/1} \stdrefindex{atan/2}
 \stdrefindex{atan2/2}

XSB also allows as evaluable functors, many of the functions from the
C library {\tt math.h}.  Functions included in XSB \version{} are {\tt
  cos/1} (ISO), {\tt sin/1} (ISO), {\tt tan/1} (ISO), {\tt acos/1} (ISO), {\tt asin/1} (ISO), {\tt
  atan/1} (ISO), {\tt log/1} (natural logarithm) (ISO), {\tt log10/1}, and 
  {\tt atan/2} (ISO) (also available as {\tt atan2/2}).  For
  their semantics, see documentation to {\tt math.h}.

\section{Convenience} \label{Convenience}
These predicates are standard and often self-explanatory, so they are 
described only briefly.
\begin{description}

\isoitem{true}{true/0}
    Always succeeds.

\standarditem{otherwise}{otherwise/0}
%\predindex{otherwise/0~(B)}
    Same as {\tt true/0}.

\isoitem{fail}{fail/0}
%\predindex{fail/0~(I)}
    Always fails.

\isoitem{false}{false/0}
%\predindex{false/0~(B)}
    Same as {\tt fail/0}.

\end{description}

%-----------------------------------------------------------------------------------------
\section{Negation and Control}\label{sec:control}
\index{control}

\begin{description}
\isoitem{\cut}{"!/0}  \index{cut} 
    Cut (discard) all choice points made since the parent goal
    started execution.
    Cuts across tabled predicates are not valid.  The compiler checks for
    such cuts, although whether the scope of a cut includes a tabled 
    predicate is undecidable in the presence of meta-predicates like
    {\tt call/1}.
    Further discussion of conditions allowing cuts and of their actions 
    can be found in Section~\ref{tabling_env}.

%\isoitem{$\backslash$+ +P}{\verb|\+/2|}
\ournewitem{$\backslash$+ +P}{ISO}\index{$\backslash$\texttt{+/1}}\index[pred]{$\backslash$\texttt{+/1}} 
%
If the goal {\tt P} has a solution, fails, otherwise it succeeds.
Equivalently, it is true iff {\tt call(P)} (see
Section~\ref{meta_predicates}) is false. Argument {\tt P} must be
ground for sound negation as failure, although no runtime checks are
made.

{\bf Error Cases}
    \begin{description}
    \item[{\tt instantiation\_error}]
	{\tt P} is not instantiated.
    \item[{\tt type\_error(callable,P)}]
	{\tt P} is not callable.
    \end{description}

\repeatstandarditem{fail\_if(+P)}{fail\_if/1}
\standarditem{not +P}{not/1}
%
Like {\tt $\backslash$+/1} and provided for compatibility with legacy
code.  Compilation of {\tt $\backslash$+/1} and {\tt fail\_if/1} is
optimized by XSB's compiler, while that of {\tt not/1} is not --
therefore the first two syntactical forms are preferred in terms of
efficiency, while {\tt $\backslash$+/1} is preferred in terms of
portability.

All error cases are the same as {\tt call/1} (see
Section~\ref{meta_predicates}).

\ourstandarditem{tnot(+P)}{tnot/1}{Tabling} \label{tnot/1}
    The semantics of {\tt tnot/1} allows for correct execution of
    programs with according to the well-founded semantics.  {\tt P}
    must be a tabled predicate, 
% tls: need to provide an example.
%and the actions of {\tt tnot/1} are
%presented in Figure~\ref{fig:tnot}. 
%
%\input{tnot} 
%
    For a detailed description of the actions of tabled negation for
    in XSB \version\ see~\cite{SaSw98, SaSW96}.
    Chapter~\ref{chap:TablingOverview} contains further discussion of the
    functionality of {\tt tnot/1}.

{\bf Error Cases}
\begin{itemize}
\item	{\tt P} is not ground (floundering occurs)
\bi
    \item {\tt instantiation\_error}
\ei
\item	{\tt P} is not callable
\bi
     \item {\tt type\_error(callable,P)}
\ei
\item {\tt P} is not a call to a tabled predicate
\bi
     \item{\tt table\_error}
\ei
\end{itemize}

%---------------------------------------------------------------------------------------
\index{floundering}
\ourstandarditem{not\_exists(+P)}{not\_exists/1}{Tabling} 
%% 
If {\tt +P} is a tabled predicate, {\tt not\_exists/1} acts as {\tt
  tnot/1} but permits variables in its subgoal argument
%~\footnote{{\tt
%    not\_exists/1} replaces the {\tt 't not'/1} predicate of earlier XSB
%  versions whose implementation and semantics were dubious.}. 
The semantics in the case of unbound variables is as follows:
%% 
\begin{quote} 
\tt ... :- ...,~not\_exists(p(X)),~...  \end{quote} 
%% 
is equivalent to 
%%
\begin{quote}
 \tt ... :- ..., tnot(pp),~...\\ pp :- p(X).
\end{quote} 
%% 
where {\tt pp} is a new proposition. Thus, the unbound variable $X$ is
treated as $\tt tnot(\exists X (p(X)))$.  {\tt not\_exists/1} also
preserves the incrementality of the tabled goal it calls.

If {\tt +P} is a non-tabled predicate {\tt not\_exists/1} ensures that
{\tt +P} is ground and called via a tabled predicate so that {\tt
  not\_exists/1} can be used with non-tabled predicates as well,
regardless of whether {\tt +P} is ground or not~\footnote{In previous
  versions of XSB, {\tt not\_exists/1} was called {\tt sk\_not/1}.}.

{\tt not\_exists/1} uses auxiliary tabled predicates, {\tt
  tabled\_call/1} and {\tt incr\_tabled\_call/1} in its execution.
The appropriate tables for these auxiliary predicates are abolished
whenever the subgoal {\tt P} or the predicate for {\tt P} are
abolished,

{\bf Error Cases}
\begin{itemize}
\item	{\tt P} is not instantiated
\bi
    \item {\tt instantiation\_error}
\ei
\item	{\tt P} is not callable
\bi
     \item {\tt type\_error(callable,P)}
\ei
\end{itemize}

%---------------------------------------------------------------------------------------
\index{floundering}
\ourmoditem{u\_not(+P)}{u\_not/1}{tables} 
%% 
If {\tt P} is ground (or cyclic), {\tt u\_not(P)} is equivalent to
{\tt tnot(P)}; but {\tt u\_not/1} provides a different semantics than
{\tt tnot/1} or {\tt not\_exists/1} if {\tt P} is non-ground.  In this
latter case, {\tt u\_not(P)} applies SLG delay to the goal {\tt P},
explicitly indicating that the default negation of {\tt P} is
floundered.  This action is safe because any answer that relies on
{\em not P} will be undefined, rather than true or false.  A current
limitation of {\tt u\_not/1} is that while floundering correctly
causes a literal to be delayed, no simplification is ever performed if
the delayed literal ever becomes ground (see the example below).  {\tt
  u\_not/1} thus provides an informationally sound but incomplete
semantics for floundering.

Thus, the use of {\tt tnot/1}, {\tt not\_exists/1}, or {\tt u\_not/1}
depends on two conditions.  {\tt not\_exists/1} is the only one of these
predicates that allows {\tt P} to be a non-tabled predicate.  However
as mentioned, their main difference is in handling non-ground negative
subgoals.  If an error should be thrown for a non-ground negative
subgoal, {\tt tnot/1} should be used; if it is semantically correct to
skolemize if {\tt P} is not ground, {\tt not\_exists/1} should be used; if
it is semantically correct to treat the truth value of the negative
subgoal as undefined, {\tt u\_not/1} should be used.  From the
perspective of performance, {\tt tnot/1} is fastest followed by {\tt
  u\_not/1} and then {\tt not\_exists/1}.

The following examples should clarify the behavior of {\tt u\_not/1}.
For the program fragment:
\begin{verbatim}
:- table p/1,q/1.
p(1):- u_not(q(X)).
q(1).
\end{verbatim}
the goal {\tt p(V)} returns 
\begin{verbatim}
V = 1 undefined
\end{verbatim}
Examining this answer shows the following:
\begin{verbatim}
| ?- get_residual(p(1),Res).

Res = [floundered(q(_h258))].
\end{verbatim}
The program fragment
\begin{verbatim}
:- table r/1,q/1.
r(1):- u_not(q(X)),s(X).
q(1).
s(1).
\end{verbatim}
shows a limitation in the current implementation of {\tt u\_not/1}.
The goal {\tt r(V)} returns
\begin{verbatim}
V = 1 undefined
\end{verbatim}
as before.  However, examining the answer shows
\begin{verbatim}
| ?- get_residual(r(1),Res

Res = [floundered(q(1))]
\end{verbatim}
Note that the binding {\em X=1} is propagated to the delayed literal
after the resolution of {\tt s(X)}.  However, the call {\tt
  tnot(q(1))} is not made once X is bound, so that the delayed literal
does not fail.

{\bf Error Cases} are the same as for {\tt tnot/1}.

%-----------------------------

\isoitem{P -> Q ; R}{->/2}
    Analogous to if {\tt P} then {\tt Q} else {\tt R}, i.e.\ defined as 
    if by
	\begin{center}
	\begin{minipage}{2.10in}
	\begin{verbatim}
	(P -> Q ; R) :- P, !, Q.
	(P -> Q ; R) :- R.
	\end{verbatim}
	\end{minipage}
	\end{center}

\isoitem{P -> Q}{->/2} 
    When occurring other than as one of the alternatives of a disjunction,
    is equivalent to:
	\begin{center}
	{\tt P -> Q ; fail.}
	\end{center}

\standarditem{repeat}{repeat/0}
    Generates an infinite sequence of choice points (in other words it 
    provides a very convenient way of executing a loop). It is defined 
    by the clauses:
    \begin{center}
    \begin{minipage}{1.5in}
    \begin{verbatim}
	repeat.
	repeat :- repeat.
    \end{verbatim}
    \end{minipage}
    \end{center}

\ourmoditem{between(+L,+U,B)}{between/3}{basics}
%
For {\tt L} and {\tt U} integers, with {\tt L} less than or equal to
{\tt U}, successive calls to {\tt between/3} unify {\tt B} with all
integers between {\tt L} and {\tt U} inclusively.  If {\tt L} is less
than {\tt U} the predicate fails.

{\bf Error Cases:}
\bi
\item 	{\tt L} (or {\tt U}) is a not an integer
\bi
\item 	{\tt type\_error(integer,L)}
\ei
\ei

\standarditem{(do\_all +Goal)}{do\_all/1}
Defines a failure driven loop, as if defined by:
	\begin{center}
	\begin{minipage}{2.10in}
	\begin{verbatim}
	(do_all Goal) :- (Goal, fail ; true).
	\end{verbatim}
	\end{minipage}
	\end{center}
The control operator, {\tt do\_all/1} is defined as a prefix operator
with precedence 1150.

\standarditem{(+CGoal do\_all +Goal)}{do\_all/2}
Defines a failure driven loop, as if defined by:
	\begin{center}
	\begin{minipage}{2.10in}
	\begin{verbatim}
	  (CGoal do_all Goal) :-
               common_vars(CGoal,Goal,CommonVars),
               findall(CommonVars,CGoal,Vals),
               sort(Vals,UniqueVals),
               (basics:member(CommonVars,UniqueVals),
                call(Goal),
                fail
                ;
                true
               ).
	\end{verbatim}
	\end{minipage}
	\end{center}
where {\tt common\_vars/3} collects the variables that occur
both in {\tt P} and {\tt Q}.
The control operator, {\tt do\_all/2} is defined as an infix operator
with precedence 1150.


\end{description}

%-------------------------------------------------------------------------
% Comparison and unification of terms.
\input{comparison}

%------------------------------------------------------------------------------------------------
\section{Meta-Logical}\label{MetaLogical}

To facilitate manipulation of terms as objects in themselves,
XSB provides a number meta-logical predicates.  These
predicates include the standard meta-logical predicates of Prolog,
along with their usual semantics.  In addition are provided predicates
which provide special operations on HiLog terms.  For a full
discussion of Prolog and HiLog terms see Section~\ref{TermSyntax}.

\begin{description}
\isoitem{var(?X)}{var/1}
    Succeeds if {\tt X} is currently uninstantiated (i.e.\ is still a 
    variable); otherwise it fails.  

    Term {\tt X} is uninstantiated if it has not been bound to anything, 
    except possibly another uninstantiated variable. Note in particular,
    that the HiLog term X(Y,Z) is considered to be instantiated.  There 
    is no distinction between a Prolog and a HiLog variable.

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- var(X).
                yes
                | ?- var([X]).
                no
                | ?- var(X(Y,Z)).
                no
                | ?- var((X)).
                yes
                | ?- var((X)(Y)).
                no
     \end{verbatim}}


\isoitem{nonvar(?X)}{nonvar/1}
    Succeeds if {\tt X} is currently instantiated to a non-variable term;
    otherwise it fails. This has exactly the opposite behavior of 
    {\tt var/1}\@.

\isoitem{atom(?X)}{atom/1}
    Succeeds only if the {\tt X} is currently instantiated to an atom, that
    is to a Prolog or HiLog non-numeric constant.

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- atom(HiLog).
                no
                | ?- atom(10).
                no
                | ?- atom('HiLog').
                yes
                | ?- atom(X(a,b)).
                no
                | ?- atom(h).
                yes
                | ?- atom(+).
                yes
                | ?- atom([]).
                yes
     \end{verbatim}}

\isoitem{integer(?X)}{integer/1}
    Succeeds if {\tt X} is currently instantiated to an integer; 
    otherwise it fails. 

\isoitem{float(?X)}{ISO}{float/1}
    Same as {\tt real/1}. Succeeds if {\tt X} is currently instantiated 
    to a floating point number; otherwise it fails.  
	
\standarditem{real(?X)}{real/1}
%
Succeeds if {\tt X} is currently instantiated to a floating point
number; otherwise it fails. This predicate is included for
compatibility with earlier versions of XSB.

\isoitem{number(?X)}{number/1}
    Succeeds if {\tt X} is currently instantiated to either an integer or 
    a floating point number (real); otherwise it fails.

\isoitem{atomic(?X)}{atomic/1}
    Succeeds if {\tt X} is currently instantiated to an atom or a number;
    otherwise it fails.

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- atomic(10).
                yes
                | ?- atomic(p).
                yes
                | ?- atomic(h).
                yes
                | ?- atomic(h(X)).
                no
                | ?- atomic("foo").
                no
                | ?- atomic('foo').
                yes
                | ?- atomic(X).
                no
                | ?- atomic(X((Y))).
                no
     \end{verbatim}}

\isoitem{compound(?X)}{compound/1}
    Succeeds if {\tt X} is currently instantiated to a compound term (with 
    arity greater that zero), i.e.\ to a non-variable term that is not atomic;
    otherwise it fails.

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- compound(1).
                no
                | ?- compound(foo(1,2,3)).
                yes
                | ?- compound([foo, bar]).
                yes
                | ?- compound("foo").
                yes
                | ?- compound('foo').
                no
                | ?- compound(X(a,b)).
                yes
                | ?- compound((a,b)).
                yes	
     \end{verbatim}}

\standarditem{structure(?X)}{structure/1}
    Same as {\tt compound/1}\@. Its existence is only for compatibility 
    with previous versions.

\standarditem{is\_list(?X)}{is\_list/1}
    Succeeds if {\tt X} is a {\em proper list}. In other words if it is 
    either the atom {\tt []} or {\tt [H|T]} where H is any Prolog or HiLog
    term and T is a proper list; otherwise it fails.

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- is_list([p(a,b,c), h(a,b)]).
                yes
                | ?- is_list([_,_]).
                yes
                | ?- is_list([a,b|X]).
                no
                | ?- is_list([a|b]).
                no
     \end{verbatim}}

\standarditem{is\_charlist(+X)}{is\_charlist/1}
    Succeeds if {\tt X} is a Prolog string, {\it i.e.}, a list of
    characters.
    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- is_charlist("abc").
                yes
                | ?- is_charlist(abc).
                no
     \end{verbatim}}

\standarditem{is\_charlist(+X,-Size)}{is\_charlist/2}
    Works as above, but also returns the length of that string in the second
    argument, which must be a variable.

\index{attributed variables}
\standarditem{is\_attv(+Term)}{is\_attv/1}
    Succeeds is {\tt Term} is an attributed variable, and fails otherwise.

\standarditem{is\_most\_general\_term(?X)}{is\_most\_general\_term/1}
    Succeeds if {\tt X} is compound term with all distinct variables
as arguments, or if {\tt X} is an atom. (It fails if X is a cons node.)
    {\footnotesize
     \begin{verbatim}
                | ?- is_most_general_term(f(_,_,_,_)).
                yes
                | ?- is_most_general_term(abc).
                yes
                | ?- is_most_general_term(f(X,Y,Z,X)).
                no
                | ?- is_most_general_term(f(X,Y,Z,a)).
                no
                | ?- is_most_general_term([_|_]).
                no
     \end{verbatim}}

\standarditem{is\_number\_atom(?X)}{is\_number\_atom/1}

    Succeeds if {\tt X} is an atom (e.g. {\tt '123'}) (as opposed to a
    number {\tt 123}) which can be converted to a numeric atom
    (integer or float) and fails otherwise.  In particular, if {\tt
      is\_number\_atom(X)} succeeds, then {\footnotesize
     \begin{verbatim}
                | ?- atom_codes(X,Codes),number_codes(N,Codes).
     \end{verbatim}}
    will succeed.

\isoitem{callable(?X)}{callable/1}
    Succeeds if {\tt X} is currently instantiated to a term that standard
    predicate {\tt call/1} could take as an argument and not give an 
    instantiation or type error.  Note that it only checks for errors of
    predicate {\tt call/1}.  In other words it succeeds if {\tt X}
    is an atom or a compound term; otherwise it fails.  Predicate
    {\tt callable/1} has no associated error conditions.

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- callable(p).
                yes
                | ?- callable(p(1,2,3)).
                yes
                | ?- callable([_,_]).
                yes
                | ?- callable(_(a)).
                yes
                | ?- callable(3.14).
                no
     \end{verbatim}}

\ourstandarditem{proper\_hilog(?X)}{proper\_hilog/1}{HiLog}
%
   Succeeds if {\tt X} is a proper HiLog term -- i.e. a HiLog term
   that is not a Prolog term; otherwise the predicate fails.

    Examples:
    (In this example and the rest of the examples of this section we assume
     that {\tt h} is the only parameter symbol that has been declared a HiLog
     symbol).

    {\footnotesize
     \begin{verbatim}
                | ?- proper_hilog(X).
                no
                | ?- proper_hilog(foo(a,f(b),[A])).
                no
                | ?- proper_hilog(X(a,b,c)).
                yes
                | ?- proper_hilog(3.6(2,4)).
                yes
                | ?- proper_hilog(h).
                no
                | ?- proper_hilog([a, [d, e, X(a)], c]).
                yes
                | ?- proper_hilog(a(a(X(a)))).
                yes
     \end{verbatim}}

\isoitem{functor(?Term, ?Functor, ?Arity)}{functor/3}
    Succeeds if the {\em functor} of the Prolog term {\tt Term} is 
    {\tt Functor} and the {\em arity} (number of arguments) of {\tt Term} is
    {\tt Arity}\@.  {\tt Functor} can be used in either the following two 
    ways:
    \begin{enumerate}
    \item If {\tt Term} is initially instantiated, then
          \begin{itemize}
          \item If {\tt Term} is a compound term, {\tt Functor} and 
                {\tt Arity} are unified with the name and arity of 
                its principal functor, respectively. 
          \item If {\tt Term} is an atom or a number, {\tt Functor} is 
                unified with {\tt Term}, and {\tt Arity} is unified with 0.
          \end{itemize}
    \item If {\tt Term} is initially uninstantiated, then either both 
          {\tt Functor} and {\tt Arity} must be instantiated, or {\tt Functor}
          is instantiated to a number, and
          \begin{itemize}
          \item If {\tt Arity} is an integer in the range 1..255, then
                {\tt Term} becomes instantiated to {\em the most general 
                Prolog term} having the specified {\tt Functor} and 
                {\tt Arity} as principal functor and number of arguments,
                respectively. The variables appearing as arguments of 
                {\tt Term} are all distinct.
          \item If {\tt Arity} is 0, then {\tt Functor} must be either an 
                atom or a number and it is unified with {\tt Term}. 
          \item If {\tt Arity} is anything else, then {\tt functor/3} aborts.
          \end{itemize}
    \end{enumerate}

{\bf Error Cases}
    \begin{description}
    \item[{\tt atom\_or\_variable}]
	{\tt Functor} is not an atom or variable.
    \item[{\tt instantiation\_error}]
	Both {\tt Term}, and either {\tt Functor}, or {\tt Arity} are 
	uninstantiated.
    \end{description}

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- functor(p(f(a),b,t), F, A).
                F = p
                A = 3

                | ?- functor(T, foo, 3).
                T = foo(_595708,_595712,_595716)

                | ?- functor(T, 1.3, A).
                T = 1.3
                A = 0

                | ?- functor(foo, F, 0).
                F = foo

                | ?- functor("foo", F, A).
                F = .
                A = 2

                | ?- functor([], [], A).
                A = 0

                | ?- functor([2,3,4], F, A).
                F = .
                A = 2

                | ?- functor(a+b, F, A).
                F = +
                A = 2

                | ?- functor(f(a,b,c), F, A).
                F = f
                A = 3

                | ?- functor(X(a,b,c), F, A).
                F = apply
                A = 4

                | ?- functor(map(P)(a,b), F, A).
                F = apply
                A = 3

                | ?- functor(T, foo(a), 1).
                ++Error: Wrong type in argument 2 of functor/3
                Aborting...

                | ?- functor(T, F, 3).
                ++Error: Uninstantiated argument 2 of functor/3
                Aborting...

                | ?- functor(T, foo, A).
                ++Error: Uninstantiated argument 3 of functor/3
                Aborting...
     \end{verbatim}}

\ourstandarditem{hilog\_functor(?Term, ?F, ?Arity)}{hilog\_functor/3}{HiLog}
%
    The XSB standard predicate {\tt hilog\_functor/3} succeeds 
    \begin{itemize}
    \item when {\tt Term} is a Prolog term and the principal function 
          symbol ({\em functor}) of {\tt Term} is {\tt F} and the
          {\em arity} (number of arguments) of {\tt Term} is 
          {\tt Arity}, or
    \item when {\tt Term} is a HiLog term, having {\em name} {\tt F} 
          and the number of arguments {\tt F} is applied to, in the 
          HiLog term, is {\tt Arity}.
    \end{itemize}
    The first of these cases corresponds to the ``usual'' behavior of
    Prolog's {\tt functor/3}, while the second is the extension of
    {\tt functor/3} to handle HiLog terms. Like the Prolog's {\tt
    functor/3} predicate, {\tt hilog\_functor/3} can be used in either
    of the following two ways:
    \begin{enumerate}
    \item If {\tt Term} is initially instantiated, then
          \begin{itemize}
          \item If {\tt Term} is a Prolog compound term, {\tt F} and 
                {\tt Arity} are unified with the name and arity of 
                its principal functor, respectively.
          \item If {\tt Term} is an atom or a number, {\tt F} is unified 
                with {\tt Term}, and {\tt Arity} is unified with 0.
          \item If {\tt Term} is any other HiLog term, {\tt F} and {\tt Arity} 
                are unified with the name and the number of arguments 
                that {\tt F} is applied to. Note that in this case {\tt F}
                may still be uninstantiated.
          \end{itemize}
    \item If {\tt Term} is initially uninstantiated, then at least
          {\tt Arity} must be instantiated, and
          \begin{itemize}
          \item If {\tt Arity} is an integer in the range 1..255, then
                {\tt Term} becomes instantiated to {\em the most general 
                Prolog or HiLog term} having the specified {\tt F} and 
                {\tt Arity} as name and number of arguments {\tt F} is 
                applied to, respectively. The variables appearing as 
                arguments are all unique.
          \item If {\tt Arity} is 0, then {\tt F} must be a Prolog or
                HiLog constant, and it is unified with {\tt Term}\@. Note
                that in this case {\tt F} cannot be a compound term.
          \item If {\tt Arity} is anything else, then {\tt hilog\_functor/3}
                aborts.
          \end{itemize}
    \end{enumerate}
    In other words, the standard predicate {\tt hilog\_functor/3} either
    decomposes a given HiLog term into its {\em name} and {\em arity}, or
    given an arity ---and possibly a name--- constructs the corresponding 
    HiLog term creating new uninstantiated variables for its arguments. 
    As happens with {\tt functor/3} all constants can be their own 
    principal function symbols.

    Examples:
    {\footnotesize
     \begin{verbatim}
               | ?- hilog_functor(f(a,b,c), F, A).
               F = f
               A = 3

               | ?- hilog_functor(X(a,b,c), F, A).
               X = _595836
               F = _595836
               A = 3

               | ?- hilog_functor(map(P)(a,b), F, A).
               P = _595828
               F = map(_595828)
               A = 2

               | ?- hilog_functor(T, p, 2).
               T = p(_595708,_595712)

               | ?- hilog_functor(T, h, 2).
               T = apply(h,_595712,_595716)

               | ?- hilog_functor(T, X, 3).
               T = apply(_595592,_595736,_595740,_595744)
               X = _595592

               | ?- hilog_functor(T, p(f(a)), 2).
               T = apply(p(f(a)),_595792,_595796)

               | ?- hilog_functor(T, h(p(a))(L1,L2), 1).
               T = apply(apply(apply(h,p(a)),_595984,_595776),_596128)
               L1 = _595984
               L2 = _595776

               | ?- hilog_functor(T, a+b, 3).
               T = apply(a+b,_595820,_595824,_595828)
     \end{verbatim}}

\isoitem{arg(+Index, +Term, ?Argument)}{arg/3} 
%
  Unifies {\tt Argument} with the ${\tt Index}^{th}$ argument of {\tt
    Term}\@, where the index is taken to start at $1$.  In accordance
  with ISO semantics, {\tt Index} must be instantiated to a
  non-negative integer, and {\tt Term} to a compound term, otherwise
  an error is thrown as described below.  If {\tt Index} is {\tt 0} or
  a number greater than the arity of {\tt Term}, the predicate quietly
  fails.

    Examples:
    {\footnotesize
     \begin{verbatim}
                   | ?- arg(2, p(a,b), A).
                   A = b

                   | ?- arg(2, h(a,b), A).
                   A = a

                   | ?- arg(0, foo, A).
                   no

                   | ?- arg(2, [a,b,c], A).
                   A = [b,c]

                   | ?- arg(2, "HiLog", A).
                   A = [105,108,111,103]

                   | ?- arg(2, a+b+c, A).
                   A = c

                   | ?- arg(3, X(a,b,c), A).
                   X = _595820 
                   A = b 

                   | ?- arg(2, map(f)(a,b), A).
                   A = a

                   | ?- arg(1, map(f)(a,b), A). 
                   A = map(f)

                   | ?- arg(1, (a+b)(foo,bar), A).
                   A = a+b
     \end{verbatim}}

{\bf Error Cases} 
\bi
\item 	{\tt Index} is a variable
\bi
\item    {\tt instantiation\_error}
\ei
\item 	{\tt Index} neither a variable nor an integer
\bi
\item    {\tt type\_error(integer,Index)}
\ei
\item 	{\tt Index} is less than 0
\bi
\item    {\tt domain\_error(not\_less\_than\_zero,Index)}
\ei
\item 	{\tt Term} is a variable
\bi
\item    {\tt instantiation\_error}
\ei
\item 	{\tt Term} is neither a variable nor a compound term
\bi
\item    {\tt type\_error(integer,Index)}
\ei
\ei

\standarditem{arg0(+Index, +Term, ?Argument)}{arg0/3}
    Unifies {\tt Argument} with the ${\tt Index}^{th}$ argument of {\tt Term}
    if {\tt Index} $>$ 0, or with the functor of {\tt Term} if {\tt Index} = 0.

\ourstandarditem{hilog\_arg(+Index, +Term, ?Argument)}{hilog\_arg/3}{HiLog}
    If {\tt Term} is a Prolog term, it has the same behavior as {\tt arg/3},
    but if {\tt Term} is a proper HiLog term, {\tt hilog\_arg/3} unifies 
    {\tt Argument} with the 
    $({\tt Index}+1)^{th}$ argument of the Prolog representation of 
    {\tt Term}\@.  Semantically, {\tt Argument} is the ${\tt Index}^{th}$ 
    argument to which the {\em HiLog functor} of {\tt Term} is applied.
    The arguments of the {\tt Term} are numbered from~1 upwards. An atomic term 
    is taken to have $0$ arguments.  
    
    Initially, {\tt Index} must be instantiated to a positive integer and 
    {\tt Term} to any non-variable Prolog or HiLog term.
    If the initial conditions are not satisfied or~$I$ is 
    out of range, the call quietly fails. Note that like {\tt arg/3}
    this predicate does not succeed for {\tt Index}=0.

    Examples:
    {\footnotesize
     \begin{verbatim}
                   | ?- hilog_arg(2, p(a,b), A).
                   A = b

                   | ?- hilog_arg(2, h(a,b), A).
                   A = b

                   | ?- hilog_arg(3, X(a,b,c), A).
                   X = _595820
                   A = c

                   | ?- hilog_arg(1, map(f)(a,b), A).
                   A = a

                   | ?- hilog_arg(2, map(f)(a,b), A).
                   A = b

                   | ?- hilog_arg(1, (a+b)(foo,bar), A).
                   A = foo

                   | ?- hilog_arg(1, apply(foo), A). 
                   A = foo

                   | ?- hilog_arg(1, apply(foo,bar), A).
                   A = bar
     \end{verbatim}}

    Note the difference between the last two examples. The difference is 
    due to the fact that {\tt apply/1} is a Prolog term, while 
    {\tt apply/2} is a proper HiLog term.

\isoitem{?Term =.. ?List}{=../2}
%
Given proper instantiation of the arguments, {\tt =../2} (pronounced
{\em univ}) succeeds when (1) {\tt Term} unifies with a compound
Prolog or HiLog term and {\tt List} unifies with a list whose head is
the functor of {\tt Term} and whose tail is a list of the arguments of
{\tt Term}; or (2) when {\tt Term} unifies with an atomic term and
{\tt List} unifies with a list whose only element is {\tt Term}.  More
precisely,
    \begin{itemize}
    \item If initially {\tt Term} is uninstantiated, then {\tt List}
      must be instantiated either to a {\em proper list} (list of
      determinate length) whose head is an atom, or to a list of
      length 1 whose head is a number.
    \item If the arguments of {\tt =../2} are both uninstantiated, or
      if either of them is not what is expected, {\tt =../2} throws
      the appropriate error message.
    \end{itemize}

    Examples:
    {\footnotesize
     \begin{verbatim}
           | ?- X - 1 =.. L.
           X = _h112
           L = [-,_h112,1]

           | ?- p(a,b,c) =.. L.
           L = [p,a,b,c]

           | ?- h(a,b,c) =.. L.
           L = [apply,h,a,b,c]

           | ?- map(p)(a,b) =.. L.
           L = [apply,map(p),a,b]

           | ?- T =.. [foo].
           T = foo

           | ?- T =.. [apply,X,a,b].
           T = apply(X,a,b)

           | ?- T =.. [1,2].
           ++Error[XSB/Runtime/P]: [Type (1 in place of atomic)] in arg 2 of predicate =../2

           | ?- T =.. [a+b,2].
           ++Error[XSB/Runtime/P]: [Type (a + b in place of atomic)] in arg 2 of predicate =../2

           | ?- X =.. [foo|Y].
           ++Error[XSB/Runtime/P]: [Instantiation]  in arg 2 of predicate =../2
     \end{verbatim}}

% Not ISO compliant in that X =.. [] should give domain error -- not
% a big deal 
{\bf Error Cases}
\begin{itemize}
\item {\tt Term} is a variable and {\tt List} is a variable, a partial list,
a  or a list whose head is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt List} is neither a variable nor a non-empty list
\bi
\item {\tt type\_error(list, H)}
\ei
\item {\tt List} is a list whose head {\tt H} is neither an atom nor a
  variable, and whose tail is not the empty list 
\bi
\item {\tt type\_error(atomic, H)}
\ei
\item {\tt Term} is a variable and the tail of {\tt List} has a length
  greater than XSB's maximum arity for terms (65535) 
\bi
\item {\tt representation\_error(max\_arity)}
\ei
\ei

%in the following line I used a very ``dirty'' LaTeX hack! -- Kostis.

\ourstandarditem{?Term \^{ }=.. [?F |?ArgList]}{\^{ }=../2}{HiLog}
When {\tt Term} is a Prolog term, this predicate behaves exactly like
the Prolog {\tt =../2}. However when {\tt Term} is a proper HiLog
term, {\tt \verb|^|=../2} succeeds unifying {\tt F} to its HiLog
functor and {\tt ArgList} to the list of the arguments to which this
HiLog functor is applied. Like {\tt =../2}, the use of {\tt
  \verb|^|=../2} can nearly always be avoided by using the more
efficient predicates {\tt hilog\_functor/3} and {\tt
  hilog\_arg/3}. The behavior of {\tt \verb|^|=../2}, on HiLog terms
is as follows:
    \begin{itemize}
    \item If initially {\tt Term} is uninstantiated, then the list in the 
          second argument of {\tt \verb|^|=../2} must be instantiated to 
          a {\em proper list} (list of determinate length) whose head can 
          be any Prolog or HiLog term.
    \item If the arguments of {\tt \verb|^|=../2} are both uninstantiated, 
          or if the second of them is not what is expected, 
          {\tt \verb|^|=../2} aborts, producing an appropriate error message.
    \end{itemize}
    Examples:
    {\footnotesize
     \begin{verbatim}
                   | ?- p(a,b,c) ^=.. L.
                   L = [p,a,b,c]

                   | ?- h(a,b,c) ^=.. L.
                   L = [h,a,b,c]

                   | ?- map(p)(a,b) ^=.. L.
                   L = [map(p),a,b]

                   | ?- T ^=.. [X,a,b].
                   T = apply(X,a,b)

                   | ?- T ^=.. [2,2].
                   T = apply(2,2)

                   | ?- T ^=.. [a+b,2].
                   T = apply(a+b,2)

                   | ?- T ^=.. [3|X].
                   ++Error: Argument 2 of ^=../2 is not a proper list
                   Aborting...
     \end{verbatim}}

{\bf Error Cases}
     \begin{description}
     \item[{\tt instantiation\_error}]
	Argument 2 of {\tt \verb|^|=../2} is not a proper list.
     \end{description}

\isoitem{copy\_term(+Term, -Copy)}{copy\_term/2} Makes a {\tt Copy} of
        {\tt Term} in which all variables have been replaced by brand
        new variables which occur nowhere else.  Variable attributes
        are also copied.  It can be very handy when writing
        (meta-)interpreters for logic-based languages.  The version of
        {\tt copy\_term/2} provided is {\em space efficient} in the
        sense that it never copies ground terms.  Predicate {\tt
          copy\_term/2} has no associated errors or exceptions.

    Examples:
    {\footnotesize
     \begin{verbatim}
                   | ?- copy_term(X, Y).

                   X = _598948
                   Y = _598904

                   | ?- copy_term(f(a,X), Y).

                   X = _598892
                   Y = f(a,_599112)
     \end{verbatim}}

\ourmoditem{copy\_term\_nat(+Term, -Copy)}{copy\_term\_nat/2}{basics}
%
Behaves as {\tt copy\_term/2}, however it replaces attributed
variables with non-attributed variables in the copy.\footnote{The name
  of this predicate was chosen for consistency with SWI Prolog, and
  stands for {\em copy\_term no attributes}.}

\isoitem{term\_variables(+Term,-Variableust)}{term\_variables/2}
    Collects the variables in {\tt Term} into the list {\tt
    VariableList}.  The variables are in the order of their first
    occurrences in a depth-first traversal of {\tt Term}.

\index{term depth!definition}
\index{terms!cyclic}
\index{attributed variables}
\standarditem{term\_depth(+Term, -Depth)}{term\_depth/2}
%
    {\tt term\_depth/2} provides an efficient way to find the maximal
    depth of a term.  Term depth is defined recursively as follows:
%
\bi
\item The depth of a structure is defined as 1 + the maximal depth of
  any argument of that structure.
\item The depth of an attributed variable is the depth of the
  attribute structure associated with that variable.
\item The depth of a list {\tt [H|T]} is defined as 1 + the maximal
  depth of {\tt H} and {\tt T}.
\item The depth of any other element is 1.
\ei
%
Note that according to this definition, the depth of the list {\tt
  [a,b]} is 3, since the list is equivalent to the structure {\tt
  .(a,.(b,[]))} whose depth is 3.  
%Also, this definition treats attributed variables as having depth of
%1, regardless of the depth of their attribute.

{\tt term\_depth/2} does not check for cyclic structures, so it must
be ensured that {\tt Term} is acyclic.

\index{term size!definition}
\index{terms!cyclic}
\index{attributed variables}
\standarditem{term\_size(+Term, -Size)}{term\_size/2}
%
{\tt term\_size/2} provides an efficient way to find the total number
of constituents of a term. Term size is defined recursively as
follows:
\begin{itemize}
\item The size of an attributed variable is 1 (the variable size) +
  the size of the attribute structure.
\item The size of a non-compound term is 1.
\item The size of a compound term is defined as 1 + the sum of the
  sizes of all arguments of that term.  
\item The size of a list {\tt [H|T]} is defined as the size of the
  term {\tt '.'(H,T)}.
\end{itemize}
%Note that this definition treats attributed variables as having size
%of 1, regardless of the size of their attribute.  
{\tt term\_size/2} does not check for cyclic structures, so it must be
ensured that {\tt Term} is acyclic.

\ourmoditem{intern\_term(+Term,-InternedTerm)}{intern\_term/2}{machine}
\index{interned terms} 
\noindent
{\tt intern\_term} makes an ``interned'' version of its first argument
and returns that term in its second argument.  The terms are equal
terms (i.e., {\tt Term == InternedTerm} would succeed.)  The interned
term has all its ground subterms represented (uniquely) in a global
space.  Subterms that contain variables are not copied but remain on
the heap.  The interned representation of ground terms can save space
and/or time in some situations.  Note that already interned subterms
or {\tt Term} do not need to be traversed in this operation.

\ourmoditem{intern\_termhash(?Term,?TermHash)}{intern\_termhash/2}{machine}
\index{interned terms} \label{interntermhash} 
\noindent
The predicate \texttt{intern\_termhash/2} allows a user to create a
perfect hash integer for a ground list or structure.  If {\tt Term} is
bound to a ground term, it term\_intern's it and returns an integer in
{\tt TermHash} that uniquely represents that ground term.  (If {\tt
  Term} is a nonground structure or list, the goal fails.)  If {\tt
  TermHash} is bound to an integer, that integer value must have been
generated and returned by an earlier call to {\tt intern\_termhash},
in which case {\tt Term} will be unified with the ground list or
structure that the value of {\tt TermHash} represents.

This predicate can be used to generate integers to represent large
ground terms, and then passed through tabled predicates, and when the
value of the large term is needed, it can be used to reconstruct the
ground term.  In this case the tables need to store only the integer
hashes, which can be more efficient.  In this way a programmer can
explicitly get the effect of tabling with interned terms (see Section
\ref{section:interned-terms}), but with slightly different control.
In particular one can use this technique to get a subsumptive tabling
with interned terms.

Note that getting a hash for a ground term is linear in the size of
the non-interned subcomponents of that term, and getting the ground
term given the hash is constant time (and quite fast.)  This means
that generating and using hashes for ground terms can be quite
efficient.

\end{description}

%-----------------------------------------------------------------------------------------------
\section{Cyclic Terms}\label{sec:cyclic}
\index{occurs check}
\index{terms!cyclic}
\index{Prolog flags!{\tt max\_table\_subgoal\_depth}}
\index{Prolog flags!{\tt max\_answer\_term\_depth}}
\index{Prolog flags!{\tt max\_answer\_list\_depth}}
\index{Prolog flags!{\tt max\_table\_subgoal\_action}}
\index{Prolog flags!{\tt max\_answer\_term\_action}}
\index{Prolog flags!{\tt max\_answer\_list\_action}}
\index{Prolog flags!{\tt unify\_with\_occurs\_check}}
\subsection{Unification with and without Occurs Check}
%

    Cyclic terms are created when Prolog unifies two terms whose
    variables have not been standardized apart: for instance
\[
    X = f(X)
\]
    will produce the cyclic term f(f(f(f(f(f(...)))))) -- in other
    words, a term with an ``infinite'' depth.  Note that according to
    the mathematical definition of unification, {\tt X} should not
    unify with a term containing itself.  There are two reasons why
    XSB (along with virtually all other Prologs) has this {\em
      default} behavior.

\begin{itemize}
%
\item The default unification algorithm, when it unifies a variable
  {\em V} with a term {\em T}, does not check for the occurrence of
  {\em V} in {\tt T}, in other words it does not perform an {\em
  occurs check}.  Unification without an occurs check is linear in the
  size of the smaller of the terms to be unified.  Unification with
  occurs check is (essentially) linear in the size of the larger term.
  Since unification is often used to assign a value to a variable, it
  is important in a programming language that assignment be constant
  time, and not linear in the size of the term being assigned.
%
\item Some programs purposefully construct cyclic terms: this occurs
  with various constraint libraries such as CHR.  These libraries do
  not perform as expected when a mathematically correct unification
  algorithm is used.
\end{itemize}

XSB provides two mechanisms for overriding this default behavior for
unification.

\begin{itemize}
\item First, there is a Prolog flag {\tt unify\_with\_occurs\_check}
  which when set to {\tt on} ensures that all unification is
  mathematically correct.  Care should be taken when using this flag,
  for the above two reasons.
%
\item For more detailed usages, the ISO predicate {\tt
  unify\_with\_occurs\_check/2} can be used syntactically rather than
  Prolog's default unification operator {\tt =/2}.
\end{itemize}

\index{Silk}
\index{Flora-2}
\index{tries!depth limit}
\subsection{Cyclic Terms}
%
    Fortunately, the creation of cyclic terms is uncommon for most
    types of programming; even when cyclic terms arise they can often
    be avoided by the proper use of {\tt copy\_term/2} or other
    predicates.  Nevertheless cyclic terms do arise when XSB is used
    for meta-programming or if XSB is used as the basis of a
    high-level knowledge representation language such as Flora-2 or
    Silk.  It is important that XSB's behavior be {\em cycle-safe} in
    the sense that the creation of cyclic terms per se will not create
    infinite loops in XSB's tabling or XSB's built-ins.  Like some
    other Prologs, XSB supports unification of cyclic terms.  In
    addition, most predicates like {\tt functor/3}, or {\tt =../2}
    that either take non-compound terms or that do not require term
    traversal are cycle-safe.  A few built-ins that require
    term-traversal are ``safe'' for cyclic terms.  For instance
    writing in XSB is subject to a depth check, which terminates for
    cyclic terms.  Most importantly, the XSB heap garbage collector is
    guarenteed to be safe for cyclic terms.

    Variant tabling can also handle cyclic terms if the proper flags
    are set.  These flags are {\tt max\_table\_subgoal\_depth} which
    determines the maximal ``reasonable'' depth of a subgoal; and {\tt
      max\_table\_answer\_depth}, {\tt
      max\_table\_answer\_list\_depth} which determine the maximal
    ``reasonable'' depth for non-list terms or lists (respectively) in
    answers.  These last two flags also determine a ``reasonable''
    depth for interned tries.  Each of these depth flags have an
    associated answer flag: {\tt max\_table\_subgoal\_action}, {\tt
      max\_table\_answer\_action} and {\tt
      max\_table\_answer\_list\_action} respectively.  The actions can
    be of three types: {\tt error} which throws an error if a term
    with a certain depth is encountered as a tabled subgoal or answer
    (regardless of whether that term is tabled); {\tt failure} which
    causes failure for these cases; and {\tt fail\_on\_cycles} which
    fails on cyclic terms, and otherwise throws an error for a term of
    a certain depth~\footnote{We hope to efficiently integrate cycle
      checking into XSB's subsumptive tabling in the reasonably near
      future.}.

    While the above operations cycle-safe, cyclic terms can cause
    problems in XSB for built-ins or predicates that require term
    traversal.  For instance the library predicates {\tt length/2} and
    {\tt append/2} currently go into infinite loops with cyclic terms;
    unless otherwise specified it is the user's responsibility to
    check library predicates (as opposed to standard built-ins) for
    acyclicity using {\tt is\_acyclic/1} or {\tt is\_cyclic/1}.  In
    addition the following XSB built-ins are {\tt not} cycle-safe:

\bi
\item {\tt bagof/3}, {\tt copy\_term/2}, {\tt ground/1} {\tt
  numbervars/[1,3,4]}, {\tt setof/3}, {\tt subsumes/2}, {\tt
  subsumes\_chk/2}, {\tt term\_depth/2}, {\tt term\_size/2},
  {term\_to\_atom/[2,3]}, {\tt term\_to\_codes/[2,3]}, {\tt
    term\_variables/2}, {\tt unifiable/2} and {\tt
    variant/2}~\footnote{The predicate {\tt ground\_or\_cyclic/1} is
      safe for cyclic terms.}.
%
\item Various table inspection built-ins based on {\tt
        get\_call/2} or similar routines (including {\tt
        get\_residual/2}).
\ei

    Arguably, programs should not intentionally create cyclic terms,
    and the above flags, as well as the following predicates, can help
    debug when cyclic terms are created.

\begin{description}
\standarditem{is\_cyclic(?X)}{is\_cyclic/1}
    Succeeds if {\tt X} is a cyclic term.  
\end{description}

\begin{description}
\repeatstandarditem{is\_acyclic(?X)}{is\_acyclic/1}
\isoitem{acyclic\_term(?X)}{acyclic\_term/1}
    Succeeds if {\tt X} is not a cyclic term.  
\end{description}

%-----------------------------------------------------------------------------------------------
\section{Manipulation of Atomic Terms}

This section lists some of XSB's predicates for manipulating atomic
terms.  For other libraries pertaining to atoms, see
Chapter~\ref{library_utilities} along with Volume 2, Chapter 7 7 for
wildcard matching, and Volume 2 Section 8 for an interfae to the PCRE
library.

\begin{description}
\index{Unicode!UTF-8}

\isoitem{atom\_codes(?Atom, ?CharCodeList)}{atom\_codes/2}
    The standard predicate {\tt atom\_codes/2} performs the conversion 
    between an atom and its character list representation. 
    If {\tt Atom} is supplied (and is an atom), {\tt CharList} 
    is unified with a list of UTF-8 codes representing the {\em ``name''} 
    of that atom.  In that case, {\tt CharList} is exactly the list of 
    UTF-8 character codes that appear in the printed representation of 
    {\tt Atom}.  If on the other hand {\tt Atom} is a variable, 
    then {\tt CharList} must be a proper list of UTF-8 character codes. 
    In that case, {\tt Atom} is instantiated to an atom containing
    exactly those characters, even if the characters look like the
    printed representation of a number.

    Examples:
    {\footnotesize
     \begin{verbatim}
                   | ?- atom_codes('Foo', L).
                   L = [70,111,111]

                   | ?- atom_codes([], L).
                   L = [91,93]

                   | ?- atom_codes(X, [102,111,111]).
                   X = foo
 
                   | ?- atom_codes(X, []).
                   X = ''

                   | ?- atom_codes(X, "Foo").
                   X = 'Foo'

                   | ?- atom_codes(X, [52,51,49]).
                   X = '431'

                   | ?- atom_codes(X, [52,51,49]), integer(X).
                   no

                   | ?- atom_codes(X, [52,Y,49]).
                   ++Error[XSB/Runtime/P]: [Instantiation]  in arg 2 of predicate atom_codes/2
                   Forward Continuation...

                   | ?- atom_codes(431, L).
                   ++Error[XSB/Runtime/P]: [Type (431 in place of atom)] in arg 1 of predicate 
                   atom_codes/2
                   Forward Continuation...

                   | ?- atom_codes(X, [52,300,49]).
                   [Representation (300 is not character code)] in arg 2 of predicate 
                   atom_codes/2
                   Forward Continuation...
     \end{verbatim}}

{\bf Error Cases}
\begin{itemize}
\item {\tt Atom} is a variable and {\tt CharCodeList} is a partial
  list or a list with an element which is a variable
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
\item {\tt Atom} is neither a variable nor an atom 
\bi
\item {\tt type\_error(atom, Atom)}
\ei
\item {\tt Atom} is a variable and {\tt CharCodeList} is neither a
  list nor a partial list 
\bi
\item {\tt type\_error(list, CharCodeList)}
\ei
\item {\tt Atom} is a variable and an element {\tt E} of {\tt CharCodeList} is neither a
variable nor a character code
\bi
\item {\tt representation\_error(character\_code, E)}
\ei
\end{itemize}

\isoitem{number\_codes(?Number, ?CharCodeList)}{number\_codes/2}
%
    The standard predicate {\tt number\_codes/2} performs the
    conversion between a number and its character list representation.
    If {\tt Number} is supplied (and is a number), {\tt CharList} is
    unified with a list of UTF-8 ( = ASCII) codes comprising the
    printed representation of that {\tt Number}.  If on the other hand
    {\tt Number} is a variable, then {\tt CharList} must be a proper
    list of UTF-8 (ASCII) character codes that corresponds to the
    correct syntax of a number (either integer or float) In that case,
    {\tt Number} is instantiated to that number, otherwise {\tt
      number\_codes/2} will simply fail.

    Examples:
    {\footnotesize
     \begin{verbatim}
                   | ?- number_codes(123, L).
                   L = [49,50,51];

                   | ?- number_codes(N, [49,50,51]), integer(N).
                   N = 123

                   | ?- number_codes(31.4e+10, L).
                   L = [51,46,49,51,57,57,57,55,69,43,49,48]

                   | ?- number_codes(N, "314e+8").
                   N = 3.14e+10

                   | ?- number_codes(foo, L).
                   ++Error[XSB/Runtime/P]: [Type (foo in place of
                     number)] in arg 1 of predicate 
                   number_codes
                   Forward Continuation...
     \end{verbatim}}

{\bf Error Cases}
\begin{itemize}
\item {\tt Number} is a variable and {\tt CharCodeList} is a partial
  list or a list with an element which is a variable
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
\item {\tt Number} is neither a variable nor a number
\bi
\item {\tt type\_error(number, Number)}
\ei
\item {\tt Number} is a variable and {\tt CharCodeList} is neither a
  list nor a partial list 
\bi
\item {\tt type\_error(list, CharCodeList)}
\ei
\item {\tt Number} is a variable and an element {\tt E} of {\tt CharCodeList} is neither a
variable nor a character code
\bi
\item {\tt representation\_error(character\_code, E)}
\ei
\end{itemize}

\standarditem{name(?Constant, ?CharList)}{name/2}
%
The standard predicate {\tt name/2} performs the conversion between a
constant and its character list representation.  If {\tt Constant} is
supplied (and is any atom or number), {\tt CharList} is unified with a
list of UTF-8 codes representing the {\em ``name''} of the constant.
In that case, {\tt CharList} is exactly the list of UTF-8 character
codes that appear in the printed representation of {\tt Constant}\@.
If on the other hand {\tt Constant} is a variable, then {\tt CharList}
must be a proper list of UTF-8 character codes.  In that case, {\tt
  name/2} will convert a list of UTF-8 characters that can represent a
number to a number rather than to a character string.  As a
consequence of this, there are some atoms (for example \verb|'18'|)
which cannot be constructed by using {\tt name/2}\@.  If conversion to
an atom is preferred in these cases, the standard predicate {\tt
  atom\_codes/2} should be used instead. The syntax for numbers that
is accepted by {\tt name/2} is exactly the one which {\tt read/1}
accepts.  

%Predicate {\tt name/2} is provided for backwards
%compatibility.  It is advisable that new programs use the predicates
%{\tt atom\_codes/2} and {\tt number\_codes/2} described below.
%In \version\ predicate {\tt name/2} is not yet implemented for
%converting from a real number to its character list representation,
%%and if the representation of a real is provided as {\tt CharList}, it
%will be converted to an atom.  If both of the arguments of {\tt
%  name/2} are uninstantiated or {\tt CharList} is not a proper list of
%ASCII characters, {\tt name/2} will abort and an error message will be
%sent to the standard error stream.

    Examples:
    {\footnotesize
     \begin{verbatim}
                   | ?- name('Foo', L).
                   L = [70,111,111]

                   | ?- name([], L).
                   L = [91,93]

                   | ?- name(431, L).
                   L = [52,51,49]

                   | ?- name(X, [102,111,111]).
                   X = foo
 
                   | ?- name(X, []).
                   X = ''

                   | ?- name(X, "Foo").
                   X = 'Foo'

                   | ?- name(X, [52,51,49]).
                   X = 431

                   | ?- name(X, [45,48,50,49,51]), integer(X).
                   X = -213

                   | ?- name(3.14, L).
                   ++Error[XSB/Runtime/P]: [Miscellaneous] Predicate name/2 for reals is not implemented yet
                   Aborting...
     \end{verbatim}}

\begin{itemize}
\item {\tt Constant} is a variable and {\tt CharCodeList} is a partial
  list or a list with an element which is a variable
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
\item {\tt Constant} is neither a variable nor atomic
\bi
\item {\tt type\_error(atomic, Constant)}
\ei
\item {\tt Constant} is a variable and {\tt CharCodeList} is neither a
  list nor a partial list 
\bi
\item {\tt type\_error(list, CharCodeList)}
\ei
\item {\tt Constant} is a variable and an element {\tt E} of {\tt
  CharCodeList} is neither a variable nor a character code 
\bi
\item {\tt representation\_error(character\_code, E)}
\ei
\end{itemize}
\index{Unicode!UTF-8}

\isoitem{atom\_chars(?Number, ?CharList)}{atom\_chars/2}
    Like \verb|atom_codes/2|, but the list returned (or input) is a list of
    characters \emph{as atoms} rather than UTF-8 codes. For instance, 
    \verb|atom_chars(abc,X)| binds {\tt X} to the list {\tt [a,b,c]}
    Instead of {\tt [97,98,99]}.

{\bf Error Cases}
\begin{itemize}
\item {\tt Atom} is a variable and {\tt CharList} is a partial
  list or a list with an element which is a variable
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
\item {\tt Atom} is neither a variable nor an atom 
\bi
\item {\tt type\_error(atom, Atom)}
\ei
\item {\tt Atom} is a variable and {\tt CharList} is neither a
  list nor a partial list 
\bi
\item {\tt type\_error(list, CharList)}
\ei
\item An element {\tt E} of {\tt CharList} is not a single-character
atom
\bi
\item {\tt type\_error(character, E)}
\ei
\item {\tt Atom} is a variable and an element {\tt E} of {\tt
  CharCodeList} is not a single-character atom
\bi
\item {\tt representation\_error(character, E)}
\ei
\end{itemize}

\isoitem{number\_chars(?Number, ?CharList)}{number\_chars/2}
%
    Like \verb|number_codes/2|, but the list returned (or input) is a
    list of characters \emph{as atoms} rather than codes. For
    instance, \verb|number_chars(123,X)| binds {\tt X} to the list
    {\tt ['1','2','3']} instead of {\tt [49,50,51]}.

{\bf Error Cases}
\begin{itemize}
\item {\tt Number} is a variable and {\tt CharList} is a partial
  list or a list with an element which is a variable
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
\item {\tt Number} is neither a variable nor a number
\bi
\item {\tt type\_error(number, Number)}
\ei
\item {\tt Number} is a variable and {\tt CharList} is neither a
  list nor a partial list 
\bi
\item {\tt type\_error(list, CharList)}
\ei
\item An element {\tt E} of {\tt CharList} is not a single-character
atom
\bi
\item {\tt type\_error(character, E)}
\ei
\item {\tt CharList} is a list of single-character atoms but is not
  parsable as a number (by XSB)
\bi
\item {\tt syntax\_error(CharList)}
\ei
\end{itemize}

\standarditem{number\_digits(?Number, ?DigitList)}{number\_digits/2}
Like \verb|number_codes/2|, but the list returned (or input) is a list
of digits \emph{as numbers} rather than UTF-8 codes (for floats, the
atom '.', '+' or '-', and 'e' will also be present in the list). For
instance, \verb|number_digits(123,X)| binds {\tt X} to the list {\tt
  [1,2,3]} instead of {\tt ['1','2','3']}, and
\verb|number_digits(123.45,X)| binds {\tt X} to {\tt
  [1,.,2,3,4,5,0,0,e,+,0,2]}.

Error cases are the same as {\tt number\_chars/2}.

\isoitem{char\_code(?Character, ?Code)}{char\_code/2}
%
The standard predicate {\tt char\_code/2} is true if {\tt Code} is the
current code for {\tt Character}.  In XSB it is defined as {\tt
  atom\_codes(Character,[Code])}.

\isoitem{atom\_length(+Atom1,?Length)}{atom\_length/2}
%
This standard predicate succeeds if {\tt Length} unifies with the
length of (the name of) {\tt Atom}.

{\bf Example}
{\small
\begin{verbatim}
|?- atom_length(trilobyte,L).

L = 9
\end{verbatim}
}

{\bf Error Cases}
\begin{itemize}
  \item {\tt Atom} is a variable
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
\item {\tt Atom} is neither a variable nor an atom
\begin{itemize}      
\item   {\tt type\_error(atom,Atom)}
\end{itemize}
\item {\tt Length} is neither a variable nor an integer
\begin{itemize}      
\item   {\tt type\_error(integer,Length)}
\end{itemize}
\end{itemize}

\ourmoditem{concat\_atom(+AtomList,?Atom)}{concat\_atom/2}{string}
%
If {\tt Atom} is a variable, then {\tt AtomList} must be a list
structure containing atoms, integers and/or floats.  This predicate
flattens {\tt AtomList} and concatenates the atoms and integers into a
single atom, returned in {\tt Atom}.  Integers and floats are
converted to character strings using {\tt
  number\_codes/2}. \footnote{Admittedly, the module {\tt string}
  should have been named something else, but it's too late to change
  the name.}

If {\tt Atom} is an atom, then {\tt AtomList} must be a list
containing atoms, and/or variables.  In this case {\tt atom\_codes}
binds the variables in the list to atoms in such a way that the atoms
of {\tt AtomList} concatenate to the atom {\tt Atom}.  For example,
{\tt concat\_atom([X,abb,Y,cc],aabbabbdefcc)} will succeed twice,
first binding X to {\tt a} and Y to {\tt abbdef}, and then binding X
to {\tt aabb} and Y to {\tt def}.

This is a somewhat more general predicate than the ISO {\tt
  atom\_concat/2} described below, and can be more efficient if
numerous atoms are to be concatenated together.

\ourmoditem{concat\_atom(+AtomList,+Sep,?Atom)}{concat\_atom/3}{string}

{\tt AtomList} must be a list containing atoms, integers and/or
floats, and {\tt Sep} must be an atom.  This predicate concatenates
the atoms and integers into a single atom, separating each by {\tt
Sep}, return the resulting atom in {\tt Atom}.  Integers and floats
are converted to character strings using {\tt number\_codes/2}.

This is a somewhat more general predicate than the ISO {\tt
  atom\_concat/2} described below, and can be more efficient if
numerous atoms are to be concatenated together.

\ourisousageitem{atom\_concat(Atom1,Atom2,Atom3)}{atom\_concat/3}
\ourusage{atom\_concat(?Atom,?Atom,+Atom)}
\ourusage{atom\_concat(+Atom,+Atom,-Atom)}
%
Succeeds if {\tt Atom12} is the concatenation of {\tt Atom1} and {\tt Atom2}.

{\bf Examples}
{\small
\begin{verbatim}
| ?- atom_concat(hello,world,F).

F = hello world

| ?- atom_concat(X,Y,'hello world').

X =
Y = hello world;

X = h
Y = ello world 
\end{verbatim}
}
The last query will re-succeed for all combinations of atoms that
produce {\tt hello world}.

{\bf Error Cases}
\begin{itemize}
  \item {\tt Atom1} and {\tt Atom3} are both variables
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
  \item {\tt Atom2} and {\tt Atom3} are both variables
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
\item {\tt Atom1} is neither a variable nor an atom
\begin{itemize}      
\item   {\tt type\_error(atom,Atom1)}
\end{itemize}
\item {\tt Atom2} is neither a variable nor an atom
\begin{itemize}      
\item   {\tt type\_error(atom,Atom2)}
\end{itemize}
\item {\tt Atom3} is neither a variable nor an atom
\begin{itemize}      
\item   {\tt type\_error(atom,Atom3)}
\end{itemize}
\end{itemize}

\isoitem{sub\_atom(+Atom,?LeftLength,?CenterLength,?RightLength,?CenterAtom}{sub\_atom/5 }
%
Succeeds if {\tt Atom} can be broken into three pieces: A left atom of
length {\tt LeftLength}, a center atom {\tt CenterAtom} of length {\tt
  CenterLength} and a right atom of length {\tt RightLength}.  If
sufficient arguments are uninstantiated to produce {\tt CenterAtom} in
non-deterministic starting positions, the predicate will backtrack
through all center atoms for which the left atom length is the
smallest , up to those whose left atom length is greatest (see
examples below).

{\bf Examples}
{\small
\begin{verbatim}
| ?- sub_atom(trilobyte,5,4,RL,CA).

RL = 0
CA = byte
| ?- sub_atom(trilobyte,1,CL,2,CA).

CL = 6
CA = riloby
| ?- sub_atom(trilobyte,LL,6,RL,riloby).

LL = 1
RL = 2
| ?- sub_atom(trilobyte,RL,4,LL,CA).

RL = 0
LL = 5
CA = tril;

RL = 1
LL = 4
CA = rilo;

RL = 2
CL = 3
CA = ilob
| ?- sub_atom(trilobyte,LL,CL,RL,CA).

LL = 0
CL = 0
RL = 9
CA = ;

LL = 0
CL = 1
RL = 8
CA = t;

LL = 0
CL = 2
RL = 7
CA = tr;

: /* after more backtracking */

LL = 0
CL = 9
RL = 0
CA = trilobyte;

LL = 1
CL = 0
RL = 8
CA = ;

Ll = 1
CL = 1
RL = 7
CA = r;
\end{verbatim}
}

{\bf Error Cases}
\bi
\item  {\tt Atom} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item  {\tt Atom} is neither a variable nor an atom
\bi
\item {\tt type\_error(atom, Atom)}
\ei
\item  {\tt CenterAtom} is neither a variable nor an atom
\bi
\item {\tt type\_error(atom, CenterAtom)}
\ei
\item  {\tt LeftLength} is neither a variable nor an integer
\bi
\item  {\tt  type\_error(integer, LeftLength)}
\ei
\item  {\tt CenterLength} is neither a variable nor an integer
\bi
\item  {\tt  type\_error(integer, CenterLength)}
\ei
\item  {\tt RightLength} is neither a variable nor an integer
\bi
\item  {\tt type\_error(integer, RightLength)}
\ei
\item  {\tt LeftLength} is an integer that is less than zero
\bi
\item  {\tt  domain\_error(not\_less\_than\_zero, LeftLength)}
\ei
\item  {\tt CenterLength} is an integer that is less than zero
\bi
\item  {\tt  domain\_error(not\_less\_than\_zero, CenterLength)}
\ei
\item  {\tt RightLength} is an integer that is less than zero
\bi
\item  {\tt  domain\_error(not\_less\_than\_zero, RightLength)}
\ei
\ei

\ourmoditem{string\_substitute(+InpStr, +SubstrList, +SubstitutionList, -OutStr)}{string\_substitute/4}{string}


{\tt InputStr} can an atom or a list of characters.  {\tt SubstrList} must
be a list of terms of the form {\tt s(BegOffset, EndOffset)}, where the
name of the functor is immaterial.  The meaning of the offsets is the same
as for {\tt substring/4}. (In particular, negative offsets represent
offsets from the first character past the end of {\tt String}.)  Each such
term specifies a substring (between {\tt BegOffset} and {\tt EndOffset};
negative {\tt EndOffset} stands for the end of string) to be replaced.
{\tt SubstitutionList} must be a list of atoms or character lists.

Offsets start from 0, as in C/Java.

This predicate replaces the substrings specified in {\tt SubstrList} with
the corresponding strings from {\tt SubstitutionList}.  The result is
returned in {\tt OutStr}. {\tt OutStr} is a list of characters, if so is
{\tt InputStr}; otherwise, it is an atom.

If {\tt SubstitutionList} is shorter than {\tt SubstrList} then the last
string in {\tt SubstitutionList} is used for substituting the extra
substrings specified in {\tt SubstitutionList}. As a special case, this
makes it possible to replace all specified substrings with a single string.

As in the case of {\tt re\_substring/4}, if {\tt OutStr} is an atom, it is
not interned.  The user should either intern this string or convert it into
a list, as explained previously.

The \verb|string_substitute/4| predicate always succeeds.

Here are some examples:
%%
\begin{verbatim}
| ?- string_substitute('qaddf', [s(2,4)], ['123'] ,L).

L = qa123f

| ?- string_substitute('qaddf', [s(2,-1)], ['123'] ,L).

L = qa123

| ?- string_substitute("abcdefg", [s(4,-1)], ["123"],L).

L = [97,98,99,100,49,50,51]

| ?- string_substitute('1234567890123', [f(1,5),f(5,7),f(9,-2)], ["pppp", lll],X).

X = 1pppplll89lll

| ?- string_substitute('1234567890123', [f(1,5),f(6,7),f(9,-2)], ['---'],X).

X = 1---6---89---
\end{verbatim}
%%

\ourmoditem{term\_to\_atom(+Term,-Atom,+Options)}{term\_to\_atom/3}{string}
%
Converts {\tt +Term} to an atomic form according to a list of write
options, {\tt Options}, that are similar to those used by {\tt
write\_term/[2,3]}.  The various options of {\tt
term\_to\_atom/[2,3]} are especially useful for the interface from C
to XSB (see {\em Calling XSB from C} in Volume 2 of this manual).
%
\begin{itemize}
%
\item {\tt quoted(+Bool)}.  If {\tt Bool = true}, then atoms and
    functors that can't be read back by {\tt read/1} are quoted, if
    {\tt Bool = false}, each atom and functor is written as its
    unquoted name. Default value is {\tt false}.
%
\item {\tt ignore\_ops(+Bool)}. If {\tt Bool = true} each compound term
is output in functional notation; list braces are ignored, as are all
explicitly defined operators.  If {\tt Bool = canonical}, bracketed list
notation is used.  Default value is {\tt canonical}.  The
corresponding value of {\tt false}, that would enable operator
precedence, is not yet implemented.
%
 \item {\tt numbervars(+Bool)}.  If {\tt Bool = true}, a term of the
form {\tt '\$VAR'(N)} where {\tt N} is an integer, is output as a
variable name consisting of a capital letter possibly followed by an
integer.  A term of the form {\tt '\$VAR'(Atom)} where {\tt Atom} is an
atom, is output as itself (without quotes).  Finally, a term of the
form {\tt '\$VAR'(String)} where {\tt String} is a character string, is
output as the atom corresponding to this character string.  If
{\tt bool} is {\tt false} this cases are not treated in any special
way.  Default value is {\tt false}.
%
\end{itemize}

{\bf Error Cases} 
\bi
\item 	{\tt Options} is a variable
\bi
\item    {\tt instantiation\_error}
\ei
\item 	{\tt Options} neither a variable nor a list
\bi
\item    {\tt type\_error(list,Options)}
\ei
\item 	{\tt Options} contains a variable element, {\tt O}
\bi
\item    {\tt instantiation\_error}
\ei
\item 	{\tt Options} contains an element {\tt O} that is neither a variable
nor a write option.
\bi
\item    {\tt domain\_error(write\_option,O)}
\ei
\ei

Examples:
{\footnotesize
\begin{verbatim}
| ?- term_to_atom(f(a,1,X,['3cpio',d(3),'$VAR'("Foo")]),F,[]).

X = _h131
F = f(a,1,_h0,[3cpio,d(3),$VAR([70,111,111])])

yes
| ?- term_to_atom(f(a,1,X,['3cpio',d(3),'$VAR'("Foo")]),F,[numbervars(true)]).

X = _h131
F = f(a,1,_h0,[3cpio,d(3),Foo])

yes
| ?- term_to_atom(f(a,1,X,['3cpio',d(3),'$VAR'("Foo")]),F,[numbervars(true),quoted(true)]).

X = _h131
F = f(a,1,_h0,['3cpio',d(3),Foo])

yes
| ?- term_to_atom(f(a,1,X,['3cpio',d(3),'$VAR'("Foo")]),F,[numbervars(true),quoted(true),ignore_ops(true)]).

X = _h131
F = f(a,1,_h0,'.'('3cpio','.'(d(3),'.'(Foo,[]))))

yes
\end{verbatim}}
% $

\ourmoditem{term\_to\_atom(+Term,-Atom)}{term\_to\_atom/2}{string}
%
This predicate converts an arbitrary Prolog term {\tt Term} into an
atom, putting the result in {\tt Atom}.  It is defined using the
default options for {\tt term\_to\_atom/3}, e.g. {\tt
ignore\_ops(canonical)}, {\tt quoted(false)}, and {\tt
numbervars(false)}.

\index{Unicode!UTF-8}
\ourmoditem{term\_to\_codes(+Term,-CodeList,+OptionList)}{term\_to\_codes/3 }{string}
%
This predicate is used in the definition of {\tt term\_to\_atom/3} but
only converts a term into a list of UTF-8 codes, and does not intern
the list as an atom.  Allowed values for {\tt OptionList} and error
cases are the same as in {\tt term\_to\_atm/3}.

\ourmoditem{term\_to\_codes(+Term,-CodeList)}{term\_to\_codes/2}{string}
%
This predicate converts a term to a list of UTF-8 codes.  It is
defined using the default options for {\tt term\_to\_atom/3},
e.g. {\tt ignore\_ops(canonical)}, {\tt quoted(false)}, and {\tt
  numbervars(false)}.

\ourmoditem{split\_atom(+Atom,+Sep,-AtomList)}{split\_atom/3}{string}
%
Splits the atom, {\tt Atom} into a list of atoms using the separator
character {\tt Sep}.  In this manner its functionality is similar to
the split methods in Python, Java and other languages.

\standarditem{gc\_atoms}{gc\_atoms/0}
\index{garbage collection!atoms}
\index{Prolog flags!{\tt atom\_garbage\_collection}}
%
Explicitly invokes the garbage collector for atoms that are created,
but no longer needed.  By default, {\tt gc\_atoms/1} is called
automatically, unless the Prolog\_flag {\tt atom\_garbage\_collection}
is set to {\tt false}, or if more than one thread is active.  However
there are reasons why a user may need to invoke atom table garbage
collection.  First, in \version{}, if atom table garbage collection is
invoked automatically, it occurs periodically on heap garbage
collection, or if numerous asserts and retracts have taken place.
These heuristics overlook certain cases where numerous atoms may be
created without invoking the garbage collector -- e.g. through
repeated uses of {\tt format\_write\_string/3}.  In addition if
user-defined C code contains pointers to XSB's atom table, atom table
garbage collection will be unsafe, as \version{} of XSB does not
detect such pointers in external code.  In such cases, atom table
garbage collection should be turned off via the Prolog flag {\tt
  atom\_garbage\_collection}, and reinvoked at a point where the
external pointers are no longer used.

\end{description}


\section{All Solutions and Aggregate Predicates}
\index{sets, bags} \index{aggregate predicates!prolog}
%-----------------------------------------------------
Often there are many solutions to a problem and it is necessary
somehow to compare these solutions with one another.  The most general
way of doing this is to collect all the solutions into a list, which
may then be processed in any way desired.  So XSB provides
ISO-standard predicates such as {\tt setof/3}, {\tt bagof/3}, and {\tt
findall/3} to collect solutions into lists.  Sometimes however, one
wants simply to perform some aggregate operation over the set of
solutions, for example to find the maximum or minimum of the set of
solutions.  XSB uses answer subsumption to produce a 
powerful aggregation facility as discussed in Section
\ref{sec:table-aggregation}

\begin{description}
\isoitem{setof(?Template, +Goal, ?Set)}{setof/3}
    This predicate may be read as ``{\tt Set} is the set of all instances 
    of {\tt Template} such that {\tt Goal} is provable''.
    If~{\tt Goal} is not provable, {\tt setof/3} fails.
    The term {\tt Goal} specifies a goal or goals as in {\tt call(Goal)}.
    {\tt Set} is a set of terms represented as a list of those terms,
    without duplicates, in the standard order for terms 
    (see Section~\ref{Comparison}).
    If there are uninstantiated variables in {\tt Goal} which do not also 
    appear in {\tt Template}, then a call to this evaluable predicate may backtrack,
    generating alternative values for~{\tt Set} corresponding to different
    instantiations of the free variables of~{\tt Goal}.
    Variables occurring in {\tt Goal} will not be treated as free if they 
    are explicitly bound within~{\tt Goal} by an existential quantifier.
    An existential quantification can be specified as:
    \begin{center}
    {\tt Y \^\ G}\index{\^}
    \end{center}
    meaning there exists a {\tt Y} such that {\tt G} is true,
    where {\tt Y} is some Prolog term (usually, a variable).
  
    Error cases are the same as predicate {\tt call/1} (see
    Section~\ref{meta_predicates}).

Example: Consider the following predicate: 
%
\begin{verbatim}
    p(red,high,1).
    p(green,low,2).
    p(blue,high,3).
    p(black,low,4).
    p(black,high,5).
\end{verbatim}
%
The goal \verb|?- setof(Color,Height^Val^p(Color,Height,Val),List)|
returns a single solution:
\begin{verbatim}
    Color = _h73
    Height = _h87
    Val = _h101
    L = [black,blue,green,red]
\end{verbatim}

If {\tt Height} is removed from the sequence of existential variables, so
that the goal becomes:
\begin{verbatim}
?- setof(Color,Val^p(Color,Height,Val),List)
\end{verbatim}
the first solution is:
\begin{verbatim}
    Color = _h73
    Val = _h87
    Height = high
    L = [black,blue,red];
\end{verbatim}
%
upon backtracking, a second solution is produced: 
%
\begin{verbatim}
    Color = _h73
    Val = _h87
    Height = low
    L = [black,green]
\end{verbatim}

\isoitem{bagof(?Template, +Goal, ?Bag)}{bagof/3}
%
This predicate has the same semantics as {\tt setof/3} except that the
third argument returns an unsorted list that may contain duplicates.

Error Cases are the same as predicate {\tt call/1} (see
Section~\ref{meta_predicates}).

Example: 
%
For the predicate {\tt p/3} in the example for {\tt setof/3}, the
goal\\ 
\verb|?- bagof(Color,Height^Val^p(Color,Height,Val),L)| returns
the single solution:
\begin{verbatim}
    Color = _h73
    Height = _h87
    Val = _h101
    L = [red,green,blue,black,black];
\end{verbatim}
If {\tt Height} is removed from the sequence of existential variables, so
that the goal becomes: 
\verb|?- bagof(Color,Val^p(Color,Height,Val),List)|, the first solution is:
\begin{verbatim}
    Color = _h73
    Val = _h87
    Height = high
    L = [red,blue,black];
\end{verbatim}
%
upon backtracking, a second solution is produced: 
%
\begin{verbatim}
    Color = _h73
    Val = _h87
    Height = low
    L = [green,black];
\end{verbatim}

%----------

\isoitem{findall(?Template, +Goal, ?List)}{findall/3}
Similar to predicate {\tt bagof/3}, except that variables in {\tt
  Goal} that do not occur in {\tt Template} are treated as
existential, and alternative lists are not returned for different
bindings of such variables.  Note that this means that {\tt Goal}
should not contain existential variables.  This makes {\tt findall/3}
deterministic (non-backtrackable).  Unlike {\tt setof/3} and {\tt
  bagof/3}, if {\tt Goal} is unsatisfiable, {\tt findall/3} succeeds
binding {\tt List} to the empty list.

Error cases are the same as {\tt call/1} (see
Section~\ref{meta_predicates}).

Example: 
%
For the predicate {\tt p/3} in the example for {\tt setof/3}, the goal \\
{\tt findall(Color,p(Color,Height,Val),L)} returns a single solution: 
%
\begin{verbatim}
    Color = _h73
    Height = _h107
    Val = _h121
    F = [red,green,blue,black,black]
\end{verbatim}

%----------
\standarditem{findall(?Template, +Goal, ?List,?Tail)}{findall/4}
%
Acts as {\tt findall/3}, but returns the result as the difference-list
{\tt Bag-Tail}. In fact, the 3-argument version is defined in terms of
the 4-argument version:
\begin{verbatim}
findall(Templ, Goal, Bag) :- findall(Templ, Goal, Bag, [])
\end{verbatim}

Error cases are the same as {\tt findall/3} (or {\tt call/1}).

\ourstandarditem{tfindall(?Template, +Goal, ?List)}{tfindall/3}{Tabling}
%
\label{tfindall/3}

    Like {\tt findall/3}, {\tt tfindall/3} treats all variables in
    {\tt Goal} that do not occur in {\tt Template} as existential.  However,
    in {\tt tfindall/3}, the {\tt Goal} must be a call to a single
    tabled predicate.
	
    {\tt tfindall/3} allows {\tt findall} functionality to be used
    safely with tabling by throwing an error if it is called
    recursively.  Its use can be seen by considering the following
    series of programs.

    {\footnotesize
    \begin{verbatim}
            p1(X):- findall(Y,p1(Y),X).
    \end{verbatim}
} 
%
When executing the goal {\tt p(X)}, XSB will throw an error when it
reaches the maximum number of recursive invocations of findall.

Next, consider the program
    {\footnotesize
    \begin{verbatim}
            :- table t/1.
            t(X):- findall(Y,t(Y),X).
            t(a).
    \end{verbatim}
} 
%
The query {\tt t(X)} will terminate without error, but will return two
answers: {\tt X = []} and {\tt X = a}.  These answers are hard to
defend semantically, since there is an implicit domain closure axiom
in findall-like predicates.  On the other hand, for the program
%
{\footnotesize
    \begin{verbatim}
            :- table t2/1.
            t2(X):- tfindall(Y,t2(Y),X).
            t2(a).
    \end{verbatim}
}
%
the query {\tt t2(X)} will throw a table error, indicating that a call
to {\tt tfindall/3} is apparently non-stratified~footnote{Detection of
  non-stratification is based on the approximate detection of
  dependencies among subgoals maintained by XSB.  This approximation
  is quite close for local evaluation, but is less close for batched
  evaluation.}.  Other behavior for tabled aggregation is provided by
answer subsumption as discussed in Section~\ref{sec:table-aggregation}

% Other differences between predicates {\tt findall/3} and {\tt
%   tfindall/3} can be seen from the following example:
% 
%     {\footnotesize
%     \begin{verbatim}
%             | ?- [user].
%             [Compiling user]
%             :- table p/1.
%             p(a).
%             p(b).
%             [user compiled, cpu time used: 0.639 seconds]
%             [user loaded]
% 
%             yes
%             | ?- p(X), findall(Y, p(Y), L).
% 
%             X = a
%             Y = _922928
%             L = [a];
% 
%             X = b
%             Y = _922820
%             L = [a,b];
% 
%             no
%             | ?- abolish_all_tables.
% 
%             yes
%             | ?- p(X), tfindall(Y, p(Y), L).
% 
%             X = b
%             Y = _922820
%             L = [b,a];
% 
%             X = a
%             Y = _922820
%             L = [b,a];
% 
%             no
%     \end{verbatim}
%     }

Error cases include those of {\tt findall/3} (see above), along with 
    \begin{description}
    \item[{\tt table\_error}]
	Upon execution {\tt Goal} is not a subgoal of a tabled predicate.
    \item[{\tt table\_error}]
	A call to {\tt tfindall/3} is apparently non-stratified
    \end{description}

%\ourrepeatstandarditem{tsetof(?X, +Goal, ?List)}{tsetof/3}{Tabling}
%\ourstandarditem{tbagof(?X, +Goal, ?List)}{tbagof/3}{Tabling}

%    {\em Note: {\tt tbagof/3} and {\tt tsetof/3} may be deprecated in
%    current versions.  Please use the predicates described in
%    Section~\ref{tabling_aggregate_predicates} if possible.}

%The standard predicates {\tt tbagof/3} and {\tt tsetof/3} provide
%tabled versions of {\tt bagof/3} and {\tt setof/3} in a similar manner
%to the way in which {\tt tfindall/3} provides a tabled version of {\tt
%findall/3}.

\isoitem{X \^\ Goal}{\^\ /2}
%
Within {\tt setof/3}, {\tt bagof/3} and the like, the {\tt \^\ /2}
operator means there exists an {\tt X} such that {\tt Goal} is true.

\ourmoditem{excess\_vars(+Term, +ExistVarTerm, +AddVarList, -VarList)}{excess\_vars/4}{setof}
Returns in {\tt VarList} the list of (free) variables found in {\tt
Term} concatenated to the end of {\tt AddVarList}.  (In normal usage
{\tt AddVarList} is passed in as an empty list.)  {\tt ExistVarTerm}
is a term containing variables assumed to be quantified in {\tt Term}
so none of these variables are returned in the resulting list (unless
they are in {\tt AddVarList}.)  Subterms of {\tt Term} of the form
{\tt (VarTerm \^\ SubTerm)} are treated specially: all variables in {\tt VarTerm} are
assumed to be quantified in {\tt SubTerm}, and so no occurrence of these
variables in {\tt SubTerm} is collected into the resulting list.

{\bf Error Cases}
    \begin{description}
    \item[{\tt type\_error}]
	{\tt AddVarList} is not a list of variables
     \item[{\tt memory}]
	Not enough memory to collect the variables.
    \end{description}

\ourmoditem{find\_n(+N,?Template, +Goal, ?List)}{find\_n/4}{setof}
%
Acts as {\tt findall/3} but returns only the first {\tt N} bindings of
{\tt Template} to {\tt List}.

\end{description}

%\input{aggreates}
% TLS: took out old bagPO, etc.

%-------------------------------------------------------------------------

\section{Meta-Predicates} \label{meta_predicates}
\begin{description}
\isoitem{call(\#X)}{call/1}
%
    If {\tt X} is a non-variable term in the program text, then it is 
    executed exactly as if {\tt X} appeared in the program text instead 
    of {\tt call(X)},
    e.g.
    \begin{center}
        {\tt $\ldots$, p(a), call( (q(X), r(Y)) ), s(X), $\ldots$}
    \end{center}
    is equivalent to
    \begin{center}
        {\tt $\ldots$, p(a), q(X), r(Y), s(X), $\ldots$}
    \end{center}
    However, if {\tt X} is a variable in the program text,
    then if at runtime {\tt X} is instantiated to a term which 
    would be acceptable as the body of a clause, the goal 
    {\tt call(X)} is executed as if that
    term appeared textually in place of the {\tt call(X)},
    {\em except that} any cut (`!')\predrefindex{"!/0}\index{cut}
    occurring in {\tt X} will remove only those choice points in~{\tt X}.
    If~{\tt X} is not instantiated as described above,
    an error message is printed and {\tt call/1} fails.

{\bf Error Cases}
    \begin{description}
    \item[{\tt instantiation\_error}]
	{\tt X} is a variable
     \item[{\tt type\_error(callable,X)}]
	{\tt X} is not callable.
    \end{description}

\ouritem{\#X}					      
    (where {\tt X} is a variable) executes exactly the same as 
    {\tt call(X)}.
    However, the explicit use of {\tt call/1} is considered better
    programming practice.  The use of a top level variable subgoal
    elicits a warning from the compiler.

\isoitem{call(Goal,Arg,...)}{call/[2,10]}
%
{\tt call(Goal,Arg)} where {\tt Goal} is an N-ary callable term first
constructs a new N+1-ary term {\tt NewGoal} with the same functor and
first N arguments as {\tt Goal} and with {\tt Arg} as its N+1th
argument, and then calls {\tt NewGoal}.  As an example,

{\tt call(member(X),[a,b,c])}

is equivalent to {\tt call(member(X,[a,b,c])}.  {\tt Goal} must be a
callable term, but can be prepended by a module name using the {\tt
  :/2} symbol.  {\tt call(Goal,Arg1,Arg2,...)} will act similarly. 
Note that {\tt Goal} should usually be atomic -- if the outer functor 
of {\tt Goal} is, say, {\tt ,/2}, {\tt call/[2-10]} will try to add 
the extra argument(s) to the comma functor, which is generally not 
the intended behavior.

While meta calls are generally fast in XSB, the extra term
manipulation of {\tt call/[2-10]} makes it somewhat slower than {\tt
  call/1}.

\ourstandarditem{call\_tv(\#Goal,-TV)}{call\_tv/2}{}
%
Calls {\tt Goal} just as with {\tt call/1}, and if {\tt Goal} does not
fail, instantiates {\tt TV} with either {\tt true} or {\tt undefined},
depending on the truth value of {\tt Goal} {\bf {\em at the current
    stage of the evaluation.}}  {\tt Goal} need not be tabled itself.
Note that {\tt Goal} might succeed with truth value {\tt undefined}
before succeeding with truth value {\tt true}.
%, so that to avoid confusion,
%{\tt call\_tv/2} should usually be invoked as a top-level goal.

Since {\tt call\_tv/2} is a meta-preducate that actually calls {\tt
  Goal}, {\tt call\_tv/2} will have the same truth value as {\tt
  Goal}.  In other words, if {\tt Goal} fails, {\tt call\_tv/2} will
fail; if {\tt Goal} succeeds unconditionally (is true in the
well-founded semantics), {\tt call\_tv/2} will succeed
unconditionally; and if {\tt Goal} succeeds conditionally (is neither
true nor false in the well-founded semantics) {\tt call\_tv/2} will
itself succeed conditionally.  An alternative approach is provided by
{\tt truth\_value/2}.

{\bf Examples}

The following example shows that {\tt call\_tv/2} propagates the truth
value of {\tt Goal}:
\begin{small}
\begin{verbatim}
| ?-  call_tv(undefined,_TV),writeln(has_value(_TV)).
has_value(undefined)

undefined
\end{verbatim}
\end{small}

The second example shows that {\tt call\_tv/2} shows the truth value
of {\tt Goal} alone, regardless of where in larger derivation {\tt
  Goal} is called.
%
\begin{small}
\begin{verbatim}
call_tv(undefined,_TV1),writeln(call1(_TV1)),call_tv(true,_TV2),writeln(call2(_TV2)).
call1(undefined)
call2(true)

undefined   << top-level conjunctive query is undefined.
\end{verbatim}
\end{small}

Error cases are the same as {\tt call/1}.

\ourmoditem{truth\_value(\#Goal,?TruthValue)}{truth\_value/2}{tables}
% 
{\tt truth\_value(Goal,TruthValue)} succeeds only if {\tt TruthValue} is
the truth value of {\tt Goal} in the well-founded model of the
program.  
%{\tt Goal} must be tabled.  
The predicate acts as follows.
\begin{enumerate}
\item {\tt Goal} is executed;
\begin{enumerate}
\item If {\tt Goal} is incomplete a permission error is thrown.
\item Otherwise if {\tt Goal} is complete
\begin{enumerate}
\item If {\tt Goal} has no answers, {\tt TruthValue} is unified with
  {\tt false}.
\item Otherwise, {\tt truth\_value/2} backtracks through all answers for
  {\tt Goal}, setting {\tt TruthValue} to {\tt true} or {\tt
    undefined} as appropriate.
\end{enumerate}
\end{enumerate}
\end{enumerate}

{\bf Examples}
Consider the program
\begin{verbatim}
:- table p/2.            :- table p/1.
p(a,b).                  p(F):- truth_value(p(_),F).
p(a,c):- undefined.
\end{verbatim}
The goal {\tt ?- truth\_value(p(X,Y),TV)} will succeed twice, setting
{\tt TV} once to {\tt true} and once to {\tt undefined}.  On the other
hand, the goal {\tt ?- truth\_value(p(c,Y),TV)} will set {\tt TV} to
{\tt false} since the goal {\tt p(c,Y)} has no answers of any kind.
The goal {\tt ?- truth\_value(p(Y),TV)} will throw a permission error,
since proving the goal relies on a call to {\tt
  truth\_value(p(Y),\_)}.  

{\bf Error Cases}
Error cases are the same as those for {\tt call/1} with the addition
\begin{itemize}
%\item   {\tt Goal} is not tabled.
%\bi
%\item {\tt permission\_error(obtain\_models\_truth\_value,non\_tabled\_subgoal,{\tt Goal})}
%\ei
\item
{\tt Goal} is incomplete after being called.
\bi
\item {\tt permission\_error(obtain\_models\_truth\_value,incomplete\_subgoal,{\tt Goal})}
\ei
\ei

\label{not3}
\ourmoditem{not3(\#Goal)}{not3/1}{tables}
% 
{\tt not3(Goal)} determines the truth value of an atomic {\tt Goal};
it succeeds unconditionally if the truth value of {\tt Goal} is false
and fails if the truth value of {\tt Goal} is true.  If {\tt Goal}
succeeds conditionally with delay set {\em D} (i.e., {\tt Goal} is
undefined in the well founded semantics or completion semantics), {\tt
  not3(Goal)} also succeeds conditionally with delay set {\em D}.

{\tt not3/1} should be used in program that exploit 3-valued
reasoning, such as the well-founded semantics or the (weak) completion
semantics, {\em and} if {\tt Goal} may be non-tabled.  Using {\tt
  not/1} or {\tt $\backslash$+/1} in such a case will give incorrect
answers.  On the other hand, if evaluation of {\tt Goal} produces a
positive or negative loop, an exception will be thrown.  For this
reason, if {\tt Goal} is known to be tabled, it is better to use {\tt
  not\_exists/1} or {\tt tnot/1}, and {\tt not3/1} should not be seen
as a replacement for these predicates.


\isoitem{once(\#X)}{once/1}
%
    {\tt once/1} is defined as {\tt once(X):- call(X),!.}  {\tt
    once/1} should be used with care in tabled programs.  The compiler
    can not determine whether a tabled predicate is called in the
    scope of {\tt once/1}, and such a call may lead to runtime errors.
    If a tabled predicate may occur in the scope of {\tt once/1}, use
    {\tt table\_once/1} instead.

    Error cases are the same as {\tt call/1}.

\standarditem{forall(Generate,Test)}{forall/2}
%
{\tt forall(Generate, Test)} is true iff for all possible bindings of
{\tt Generate}, the goal {\tt Test} is true. Procedurally, abstracting
error checking, the predicate shall behave as being defined by 
\verb|\+ (call(Generator), \+ call(Test))|.

    Error cases are the same as {\tt call/1}.

\ourmoditem{table\_once(\#X)}{table\_once/1}{aggregs}
    {\tt table\_once/1} is a weaker form of {\tt once/1}, suitable for
    situations in which a single solution is desired for a
    subcomputation that may involve a call to a tabled predicate.  {\tt
    table\_once(?Pred)} succeeds only once even if there are many
    solutions to the subgoal {\tt Pred}.  However, it does not ``cut
    over'' the subcomputation started by the subgoal {\tt Pred},
    thereby ensuring the correct evaluation of tabled subgoals.

The exceptions to {\tt table\_once(Goal)} are the same as those for
{\tt call(Goal)}.

{\em Warning:} since {\tt table\_once/1} uses a tabled meta-predicate,
it must be explicitly abolished.  As an example, suppose {\tt Goal} is
tabled, {\tt table\_once(Goal)} is called, and later the tabled
subgoal {\tt Goal} is abolished.  Then the table {\tt
  table\_once(Goal)} will persist until it is either explicitly
abolished or is abolished through a general abolish predicate such as
{\tt abolish\_all\_tables/0}.

\ourmoditem{table\_random(\#Goal)}{table\_random/1}{aggregs} 
%
{\tt  table\_random/1} allows  one to  get a  random solution  to {\tt
  Goal}: {\tt Goal} need not be  tabled, or even atomic.  Each call to
{\tt  table\_random(Goal)}  will  succeed  with a  new,  independently
chosen solution (as long as {\tt Goal} has at least one solution).

From an operational perspective, {\tt table\_random/1} makes use of
the tabled meta-call {\tt table\_random\_1/1}.  If {\tt
  table\_random\_1(Goal)} has not been called, {\tt table\_random/1}
first makes this meta-call.  Once the call has been made, an answer
$A$ to {\tt table\_random\_1(Goal)} is chosen at random from its
current (possibly incomplete) set of answers.  If $A$ is undefined
with delay list $D$, then the solution to {\tt table\_random/1} will
also be undefined with delay list $D$.

The exceptions to {\tt table\_random(Goal)} are the same as those for
{\tt call(Goal)}.

{\em Warning:} since {\tt table\_random\_1/1} is a tabled
meta-predicate, it must be explicitly abolished.  As an example,
suppose {\tt Goal} is tabled, {\tt table\_random\_1(Goal)} is called
(via {\tt table\_random(Goal)}), and later the tabled subgoal {\tt
  Goal} is abolished.  Then the table {\tt table\_random\_1(Goal)} will
persist until it is either explicitly abolished or is abolished
through a general abolish predicate such as {\tt
  abolish\_all\_tables/0}.

\standarditem{call\_cleanup(\#Goal,\#Handler)}{call\_cleanup/2}
%
{\tt call\_cleanup(Goal, Cleanup)} calls {\tt Goal} just as if it were
called via {\tt call/1}, but it is ensures that {\tt Handler} will be
called after {\tt Goal} finishes execution.  {\tt call\_cleanup/2} is
thus useful when {\tt Goal} uses a resource, (such as a stream, mutex,
database cursor, etc.) that should be released when {\tt Goal}
finishes execution.

More precisely, {\tt Goal} finishes execution either 1) by failure, 2)
by determining that the success of {\tt Goal} is deterministic, 3)
when an error is thrown and not handled by {\tt Goal} or one of its
subgoals; or 4) when {\tt Goal} is cut over.  In all of these cases,
{\tt Handler} will be called and must succeed (but can be non-deterministic).
We illustrate these cases through examples.
\begin{itemize}
\item Failure of {\tt Goal}:
\begin{verbatim}
   ?- call_cleanup(fail,writeln(failed(Goal))).
\end{verbatim}
In this case, {\tt Goal} has no solutions, and the handler is invoked
when the engine backtracks out of {\tt Goal}.
%
\item Deterministic success of {\tt Goal}.  Assume that {\tt p(1)} and
  {\tt p(2)} have been asserted.  Then
\begin{verbatim}
   ?- call_cleanup((p(X),writeln(got(p(X)))),writeln(handled(p(X)))).
   got(p(1))

   X = 1;
   got(p(2))
   handled(p(2))

   X = 2;

  no
\end{verbatim}
Note that {\tt Handler} is called only after the last solution of the
goal {\tt p(X)} has been obtained.  XSB decides to call {\tt Handler}
only when it can be determined that the success of {\tt Goal} has left
no choice points.  In such a case, the final solution has been
obtained for {\tt Goal}.  Of course, it may be that a solution $S$ to
{\tt Goal} leaves a choice point but the choice point will produce no
further solutions for {\tt Goal}.  XSB will not call {\tt Handler} in
this case, rather it will wait until there are no choice points left
for {\tt Goal}.

\item An uncaught error $E$ is thrown out of {\tt Goal}.  In this
  case, {\tt Handler} will be called, and then, if $E$ is uncaught,
  $E$ will be rethrown.  This is illustrated in the following example
  (Error handling is discussed further in Section~\ref{sec:catch}):
\begin{verbatim}
   ?- catch(call_cleanup(throw(my_error),writeln(invoking_handler)),
            Ball,
            write(Ball)).
   invoking_handler
   my_error
   yes
\end{verbatim}
Of course, {\tt Handler} itself can be wrapped in a {\tt catch/3} so
that any errors will be caught by {\tt call\_cleanup/2}.

\item Choice points for {\tt Goal} are removed via a cut.  Consider an
  example in which {\tt p/1} has the same extension as above ({\tt p(1),p(2)}:
\begin{verbatim}
   call_cleanup(p(X),writeln(handled_1)),!.
   handled_1

X = 1

yes	
\end{verbatim}
The handler is invoked immediately when the choice point laid down by
{\tt p(X)} is cut over -- before returning to the command line.  If a
cut cuts over more than goal to be cleaned, more than one handler will be executed:
\begin{verbatim}
   ?-call_cleanup(p(X),writeln(handled_4_1)),
       call_cleanup(p(Y),writeln(handled_4_2)),
       call_cleanup(p(Z),writeln(handled_4_3)),
       !.
   handled_4_3
   handled_4_2
   handled_4_1
 
   X = 1
   Y = 1
   Z = 1
\end{verbatim}
\end{itemize}

{\tt call\_cleanup/2} is thus an extremely powerful and flexible
mechanism when used in a simple manner.  While {\tt Handler} is
``guaranteed'' to be invoked whenever {\tt Goal} finishes
execution~\footnote{In fact we don't guarantee anything, see XSB's
  license.}, it may be difficult to predict when {\tt Handler} will be
invoked, as {\tt Handler} may be invoked because of deeply non-local
cuts over {\tt Goal}, and even when such cuts are not present, the
invocation depends on XSB determining when the last solution for {\tt
  Goal} has been obtained.  Baroque usages, such as invoking {\tt
  call\_cleanup/2} and cuts in the handler are supported, but may lead
to code that is difficult to debug, since handlers may be invoked
based on the state of XSB's choice point stack.  

{\bf Error Cases}
\begin{description}
\item  {\tt Goal} is a variable
\bi
\item {\tt instantiation error}
\ei
\item  {\tt Goal} is neither a variable nor a callable term
\bi
\item  {\tt type error(callable, Goal)}
\ei
\item  {\tt Handler} is a variable
\bi
\item  {\tt instantiation error}
\ei
\item  {\tt Handler} is neither a variable nor a callable term
\bi
\item {\tt type error(callable, Handler)}
\ei
\end{description}

\end{description}

%----------------------------------------------------------------------

\subsection{Timed Calls and Co-routining} \label{sec:timed-call}
\index{tripwires!timed call}
When XSB is used in multi-threaded mode, one XSB thread $t_1$ may send
a signal goal $G$ to another thread $t_2$, which causes $t_2$ to
interrupt its computation, execute $G$, and then resume its
computation.
%(Section~\ref{chap:threads}).
{\tt timed\_call/2} and
related predicates provide similar functionality within the
single-threaded engine, a useful addition since not all of tabling
features are currently available in the multi-threaded engine.  {\tt
  timed\_call/2} invokes a {\em base goal} which is interrupted either
once or repeatedly at specified time intervals; when interrupted the
engine invokes a handler that can implement a fairly general
co-routine.  In this way, monitors, logs, specialized debuggers --
even adaptive behavior -- can be implemented for large and complex
tabled evaluations.

Within the timed call paradigm, it is important that the execution of
the handler be independent of the base goal.  For instance, any tables
called by the handler should not depend on incomplete tables called by
the base goal.  On the other hand, the handler may inspect and analyze
the evaluation state of the base goal through XSB's growing set of
inspection routines (Section~\ref{sec:suspend-analyze}).

\subsubsection{Interpreter Indices}
%
One use of timed calls is to have the handler suspend the base
computation, and then start an interpreter that can be used to execute
queries about the base computation.  In the classic command-line
interpreter of XSB, this is done by {\tt break/0}.  However, XSB can
be called in a variety of ways other than the
command-line-interpreter.  It can be invoked as an executable via its
{\tt -e} option, called from a socket, called directly from C, or
called from Java via Interprolog or some other bridge.  To represent
the generality of the interpreters that may be used, we make use of
the notion of {\em interpreter indices} in this section and in
Section~\ref{sec:suspend-analyze}, which discusses inspection
predicates.  Conceptually, a computation starts at index 0 -- even if
XSB was not invoked with a command-line interpreter.  The handler
executes at index 1, which might or might not be associated with a new
command-line interpreter.  In principle, an index $N$ interpreter is
invoked through the handler of a suspended goal that was executed at
level $N-1$.

\subsubsection{Timed Call and related predicates}

\begin{description}
%\ourrepeatstandarditem{timed\_call(\#Goal,+Interval,\#Handler,+Option)}{timed\_call/4}{}
\ourstandarditem{timed\_call(\#Goal,\#Options)}{timed\_call/2}{}
%
This predicate calls {\tt Goal} and may interrupt {\tt Goal} to call
handlers as specified in {\tt Options}.  In the case where a handler
succeeds, the execution of {\tt Goal} will be continued; if the
handler fails, {\tt Goal} will fail; and if a handler throws an
uncaught exception the execution of {\tt Goal} may be aborted. In
these ways {\tt timed\_call/2} can be used to allow co-routining of
{\tt Goal} with a repetition handler and/or timing {\tt Goal} out with
a (separate) handler.

{\tt Options} is a list that may contain the following terms
\bi
\item The term {\tt max(+MaxInterval,\#MaxHandler)} specifies that {\tt
  MaxHandler} will be called when it is determined that the total elapsed
  time to execute {\tt Goal} exceeds {\tt MaxInterval} milliseconds.  As
  a use case, if {\tt MaxHandler} throws an exception, {\tt Goal} can be
  aborted; and if {\tt MaxHandler} fails, {\tt Goal} will fail.
%
\item The term {\tt repeating(+RepInterval,\#RepHandler)} specifies that
  {\tt RepHandler} will be repeatedly called whenever {\tt Goal} has
  executed an additional {\tt RepInterval} milliseconds of elapsed time.
  The time taken to execute {\tt RepHandler} is not counted as part of
  {\tt RepInterval} milliseconds (or that of {\tt MaxInterval}, if a
  maximum handler is also specified).
%
\item The term {\tt nesting} indicates that nested timed calls should
  be allowed within the same interpreter index.  In this case, the
  nested timed call is simply treated as a call to {\tt Goal}: in
  other words the interval(s) and handlers for the nested call are
  ignored.  Otherwise, if {\tt Options} does not contain the term {\tt
    nesting} an attempt to nest calls will raise a permission
  exception.  \ei

Executing a timed call for {\tt Goal} is more expensive than simply
calling {\tt Goal}, so it should not be used for frequent calls to
goals that whose derivation is simple.

{\tt timed\_call/2} is based on XSB's internal interrupt mechanism,
used for attributed variable handlers and thread signaling.  As such,
the ability to execute complex actions upon interrupt and then to
resume {\tt Goal} is very robust.  However, checks for interrupts are
only made whenever XSB's SLG-WAM engine is executing.  Because of
this, if XSB is suspended on I/O, calling a C or java function, in a
C-implemented built-in, or otherwise outside of its virtual machine,
the interrupt will not be executed until computation returns to XSB's
virtual machine.

{\tt timed\_call/2} is integrated with XSB's break levels with a
different timed call possible at each break level.  In this way, a
handler can call a break statement, and the base computation inspected
using one of XSB's built-ins.  As mentioned, the time that is spent in
a break level is not counted as part of the repetition or maximum intervals associated with the base goal.

%{\tt timed\_call/3} is not implemented for the multi-threaded engine
%but its functionality is easily duplicated using thread signaling
%(Section`\ref{sec:thread-signals}).

{\bf Examples}
Consider the simple (and non-tabled) program fragment
\begin{verbatim}
loop :- loop.
\end{verbatim}
which goes into an infinite loop on the query {\tt ?- loop.}  However,
the query
\begin{verbatim}
timed_call(loop,[max(5000,abort)]).
\end{verbatim}
will interrupt {\tt loop} and abort its computation after 5000
milliseconds.  Alternately, the query
\begin{verbatim}
timed_call(loop,[max(5000,fail)]).
\end{verbatim}
will fail the query.  Finally, the query
\begin{verbatim}
timed_call(loop,[repeating(500,statistics)]).
\end{verbatim}
will interrupt the computation every 500 milliseconds, print out
statistics, and resume the computation where it left off.

These approaches can be combined: 
\begin{verbatim}
timed_call(loop,[repeating(500,statistics),max(5000,break)]).
\end{verbatim}
will interrupt the computation every 500 milliseconds to print
statistics, and then will enter a break after 5000 milliseconds, so
that the state of computation can be explored after 5000 milliseconds.
Handlers can be quite complex, and can support UI-based monitors, and
even analysis routines that may modify the parameters of the
computation when possible (e.g., by changing one form of tabling to
another, when permitted).

{\bf Error Cases} 
%
Error cases are the same as {\tt call/1} for the first argument of
{\tt timed\_call/3} and for handlers.  In addition {\tt timed\_call/1}
also throws these other errors.
%
\begin{description}
\item {\tt Options} is non-ground
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Options} is not a list
\bi
\item {\tt type\_error}
\ei
\item {\tt Interval} as contained in the first argument of {\tt max/2}
  or {\tt repeating/2} is not a positive  integer
\bi
\item {\tt type\_error}
\ei
\item {\tt Options} contains neither a term of the form {\tt max/2}
  nor of the form {\tt repeating/2}
\bi
\item {\tt misc\_error}
\ei
\item A call {\tt C} to {\tt timed\_call/3} is made within the scope
  of some other call to {\tt timed\_call/3}
%
\bi
\item {\tt permission\_error(nested\_call,predicate,{\tt C})}
\ei
\item {\tt timed\_call/3} is called from the multi-threaded engine
\bi
\item {\tt misc\_error}
\ei
\end{description}

%-------------------------------------------------------

\ourstandarditem{current\_timed\_call(?Index,?DisplayOptions)}{current\_timed\_call/2}{}
%
If there is an active timed call, invoked by {\tt
  timed\_call(Goal,Options)}, at interpreter index {\tt Index}, this
predicate returns information representing {\tt Options}.  {\tt
  DisplayOptions} differs from {\tt Options} only in the following
case.  If {\tt Options} contains a term {\tt max(Interval,Handler)},
{\tt DisplayOptions} will contain a corresponding term {\tt
  max(Used/Interval,Handler)}, indicating both the original interval
(in milliseconds) and the number of milliseconds used so far.

{\bf Example}

As above, assume that the following goal is called from the
command-line interpreter:

{\tt ?- timed\_call(loop,[max(5000,abort)]).}

After a few seconds, the user interrupts the goal with a Ctrl-C,
sending XSB into a break level.  At that point the goal 

{\tt 1: ?- current\_timed\_call(Index,Options).} 

succeeds with {\tt Index = 0} and {\tt Options = [max(3539 / 5000,abort)]}.

%-------------------------------------------------------
%-------------------------------------------------------
\ourstandarditem{timed\_call\_modify(\#NewOptions)}{timed\_call\_modify/1}{}
%
When called from interpreter index $N>1$, this predicate modifies the
behavior of the suspended derivation.  
%
\bi
\item If current state is in the scope of the suspended goal {\tt
  timed\_call(Goal,OldOptions)} at interpreter index $N-1$, {\tt Goal}
  is made to behave as if it had been called with {\tt
    timed\_call(Goal,NewOptions)}.  I.e., {\tt NewOptions} rather than
  {\tt OldOptions} takes effect as soon as the suspended goal is
  resumed.  If {\tt NewOptions} is the empty list, this has the effect
  of removing any interrupts that would be due to the timed call.
%
\item If the current suspended state is {\em not} in the scope of a
  timed call as described above, the {\em top-level} goal $G_T$ of
  interpreter level $N-1$ is made to behave as if it had been called
  as {\tt timed\_call($G_T$,NewOptions)}.
\ei

{\bf Example} 
%
This rather fanciful example shows the essential points about how {\tt
  timed\_call\_modify/1} can be used in practice.  Suppose a user sets
up a monitor for the infinite loop program (introduced above) using
the goal:

{\tt timed\_call(loop,[repeating(500,writeln(interruption\_interval(500)))]).}

which produces the output 

\begin{verbatim}
interruption_interval(500)
interruption_interval(500)
interruption_interval(500)
:
\end{verbatim}
%
At this point, the user realizes that too much information is being
printed out, and decides to back off somewhat.  The user obtains a
break level by executing Ctrl-C as before, and calls the goal: 

{\small
\begin{verbatim}
1: ?- timed_call_modify([repeating(1000,writeln(new_interruption_interval(1000)))]).
\end{verbatim}
}

When the break is exited, information is presented in an undoubtedly
more useful manner:

\begin{verbatim}
1: ?- [ End break (level 1) ]
new_interruption_interval(1000)
new_interruption_interval(1000)
new_interruption_interval(1000)
\end{verbatim}

Additions and deletions of timed call parameters is done in a similar
manner.

{\bf Error Cases} 
%
Error cases are the same those for the options list of 
{\tt timed\_call/2} and for handlers.  In addition {\tt timed\_call/1}
also throws the following error.

\bi
\item {\tt timed\_call\_modify/1} is called in the top-level interpreter.
\bi
\item {\tt permissions\_error}
\ei
\ei
%

\ourstandarditem{timed\_call\_cancel}{timed\_call\_cancel/0}{}
%
When called at interpreter index $N$ removes any handlers for a timed
call invoked at level $N-1$.  That is, if {\tt Goal} was called at
interpreter level $N$ via {\tt timed\_call/2}, cancelling will remove
any repeating or maximum interrupts.  When interpreter level $N-1$ is
later resumed, {\tt Goal} will continue execution as if it were called
via the normal calling mechanism.  If there is no timed call active at
level $N-1$, the predicate succeeds with no effects.

%-------------------------------------------------------

\ourrepeatmoditem{bounded\_call(\#Goal,+MaxMemory,+MaxCPU,\#Handler)}{bounded\_call/4}{standard}
\ourmoditem{bounded\_call(\#Goal,+MaxMemory,+MaxCPU)}{bounded\_call/3}{standard}
%
These predicates call {\tt Goal} and check once per second
whether the total CPU time to execute {\tt Goal} is greater than {\tt
  MaxCPU} seconds, and whether the total memory taken by XSB is
greater than {\tt MaxMemory} bytes.  Under {\tt bounded\_call/4} if
either of these conditions arise, {\tt Handler} is called; under {\tt
  bounded\_call/3} a resource exception is thrown for memory or CPU
time.  

These predicates are implemented directly using {\tt timed\_call/3}
and inherit the advantages and limitations of that predicate.  As an
advantage, the ability to execute complex actions upon interrupt and
to resume is very robust.  However, checks for interrupts are only
made whenever XSB's SLG-WAM engine is executing.  Because of this, if
XSB is suspended on I/O, calling a C or java function, in a
C-implemented built-in, or otherwise outside of its virtual machine,
the interrupt will not be executed until computation is back within
XSB's virtual machine.

{\tt Handler} cannot cause {\tt timed\_call/3} to be executed as a
subgoal; but otherwise {\tt Handler} has no restrictions.

%{\tt bounded\_call/[3,4]} is not yet implemented for the
%multi-threaded engine but its functionality is easily duplicated using
%thread signaling (Section`\ref{sec:thread-signals}).

{\bf Error Cases} 
%
Error cases are the same as in {\tt call/1} for the first argument of
{\tt bounded\_call/3}, and are the same as that of {\tt timed\_call}
for {\tt Handler}.  
%
\begin{description}
\item {\tt MaxCPU} or {\tt MaxMemory} is not an integer
\bi
\item {\tt type\_error(integer)}
\ei
\item {\tt MaxCPU} or {\tt MaxMemory}  is not a positive integer
\bi
\item {\tt domain\_error(positive\_integer)}
\ei
\end{description}

\end{description}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual1"
%%% End: 

